<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker-IDAPro</title>
    <url>/2019/10/30/docker-IDAPro/</url>
    <content><![CDATA[<p>docker与IDAPRO搭建二进制漏洞环境</p>
<a id="more"></a>
<h2 id="1-docker安装与基本操作"><a href="#1-docker安装与基本操作" class="headerlink" title="1. docker安装与基本操作"></a>1. docker安装与基本操作</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p><a href="https://www.docker.com/" target="_blank" rel="noopener">官网</a><br><a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">runoob安装教程</a></p>
<h3 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h3><h4 id="导入镜像-别人已经准备好的"><a href="#导入镜像-别人已经准备好的" class="headerlink" title="导入镜像(别人已经准备好的)"></a>导入镜像(别人已经准备好的)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ubuntu.17.04.amd64 | docker import - ubuntu/17.04.amd64(可自己命名)</span><br></pre></td></tr></table></figure>

<p>ubuntu.17.04.amd64是一个本地的镜像文件，后面一个名字可以自己定义</p>
<h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><p>导入成功后，可以使用命令查看docker所有的已经导入的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="/images/docker-idapro/doker01.png" alt="pic1"></p>
<h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><p>可以看作是启动一个任务<br><code>docker run</code>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it -p 23946:23946 ubuntu/17.04.amd64 /bin/bash</span><br><span class="line">#或者</span><br><span class="line">docker run -i -t -p 23946:23946 ubuntu/17.04.amd64 /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-i</code> 允许对容器内的标准输入<br><code>-t</code> 在新的容器内指定一个伪终端或者终端<br><code>-p</code> 容器内部使用的网络端口映射到使用的主机上面，<strong>前面一个是本地主机端口</strong><br><code>ubuntu/17.04.amd64</code> 这是镜像名字<br><code>/bin/bash</code> 运行的命令</p>
</blockquote>
<h4 id="查看docker运行的所有容器"><a href="#查看docker运行的所有容器" class="headerlink" title="查看docker运行的所有容器"></a>查看docker运行的所有容器</h4><p>在运行的主机上打开一个新的shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps #查看所有正在运行的容器</span><br></pre></td></tr></table></figure>

<p><img src="/images/docker-idapro/d02.png" alt="pic1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container ls -a #查看所有的容器情况</span><br></pre></td></tr></table></figure>

<p><img src="/images/docker-idapro/d03.png" alt="pic1"></p>
<blockquote>
<p>拓展：可以修改容器的名字<br><code>docker container rename  [autoname] [yourname]</code><br><code>docker start id/name</code> 启动容器</p>
</blockquote>
<h4 id="在已经运行的镜像或者容器内打开一个新的bash-shell"><a href="#在已经运行的镜像或者容器内打开一个新的bash-shell" class="headerlink" title="在已经运行的镜像或者容器内打开一个新的bash shell"></a>在已经运行的镜像或者容器内打开一个新的bash shell</h4><p>有时候一个容器的shell阻塞了，我们需要新的bash shell，可以使用如下的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it ubuntu17.04 /bin/bash</span><br><span class="line">#或者  containerID是一个id号</span><br><span class="line">docker exec -it containerID /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="容器和主机之间的文件传送"><a href="#容器和主机之间的文件传送" class="headerlink" title="容器和主机之间的文件传送"></a>容器和主机之间的文件传送</h4><p><strong>可以使用如下命令在容器和主机之间双向传送文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container cp [localhostFilePath] [imageName]|[containerID]:[filePath]</span><br></pre></td></tr></table></figure>

<p>eg: <code>docker container cp linux_server ubuntu.17.04.i386:/root/linux_server</code></p>
<blockquote>
<p><strong>注意</strong>这个imageName指的是某一个容器的名字，而非镜像名字，id也是容器的id。</p>
</blockquote>
<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><p>此时拥有shell，使用命令<code>exit</code>或者键盘<code>ctrl+D</code><br>如果没有shell，先<code>docker ps</code>得到容器id或者name，然后使用<code>docker stop id/name</code>结束容器</p>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm id/name</span><br></pre></td></tr></table></figure>

<h2 id="2-IDAPro简单使用"><a href="#2-IDAPro简单使用" class="headerlink" title="2. IDAPro简单使用"></a>2. IDAPro简单使用</h2><p>在远程连接时候，需要<strong>关闭docke远程执行命令保护</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --security-opt seccomp:unconfined -it -p 23946:23946 ubuntu.17.04.i386 /bin/bash</span><br></pre></td></tr></table></figure>

<p>将IDA所在文件夹下的dbgsrv的linux_server或则linux_server64复制到主机上，并使用<code>docker container cp</code>命令传送到容器的某一个路径下。<br>加权限然后运行，可以看到侦听端口，新打开一个bash shell。</p>
<table>
 <tr><th>快捷键</th><th>功能</th></tr>
 <tr><td>F2</td><td>设置断点/取消断点</td></tr>
 <tr><td>F7</td><td>单步进入函数</td></tr>
 <tr><td>F8</td><td>单步跨过函数</td></tr>
 <tr><td>F9</td><td>运行程序</td></tr>
</table>

<h2 id="3-ubuntu16-04安装pwntools模块"><a href="#3-ubuntu16-04安装pwntools模块" class="headerlink" title="3.ubuntu16.04安装pwntools模块"></a>3.ubuntu16.04安装pwntools模块</h2><p><a href="https://docs.pwntools.com/en/stable/install.html" target="_blank" rel="noopener">官网链接</a><br>先升级setuptools</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U setuptools</span><br></pre></td></tr></table></figure>

<p>然后安装pwntools模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install --upgrade pwntools</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能出现错误<br><code>ERROR: Package &#39;more-itertools&#39; requires a different Python: 2.7.15 not in &#39;&gt;=3.4&#39;</code><br>解决办法：单独安装more-itertools模块<br><code>pip install more-itertools==5.0.0</code><br>然后再次安装<code>pip install pwntools</code></p>
</blockquote>
<p>测试安装成功，没有报错误就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">import pwn</span><br><span class="line">pwn.asm(&quot;xor eax,eax&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="4-pwntools和IDA调试程序"><a href="#4-pwntools和IDA调试程序" class="headerlink" title="4.pwntools和IDA调试程序"></a>4.pwntools和IDA调试程序</h2><p>期间使用IDAPro远程attach的时候报了一个错<br><code>This can perhaps indicate the process was just terminated, or that you don&#39;t have the necessary privileges.</code></p>
<blockquote>
<p>解决办法<br>重新启动容器，使用如下命令运行<br><code>docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -it -p 23900:23946 ubuntu:18.04 /bin/bash</code></p>
</blockquote>
<h3 id="设置程序的IO转发"><a href="#设置程序的IO转发" class="headerlink" title="设置程序的IO转发"></a>设置程序的IO转发</h3><ul>
<li><p>打开一个新的bash，切换到容器的运行程序目录下。</p>
</li>
<li><p><code>ifconfig</code>查看ip地址</p>
</li>
<li><p>执行命令，设置IO转发到10001<br><code>socat tcp-listen:10001,reuseaddr,fork EXEC:./heapTest_x86,pty,raw,echo=0</code><br><code>socat</code>命令介绍查看<a href="#ref3">参考文献3</a></p>
</li>
<li><p>主机python使用pwntools</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = remote(&quot;172.17.0.2&quot;, 10001)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="IDA中的操作"><a href="#IDA中的操作" class="headerlink" title="IDA中的操作"></a>IDA中的操作</h3><p><code>call ___isoc99_scanf</code>处设置断点<br><code>Debugger-&gt;Attach to process...</code>附加到<code>./heapTest_x86</code>的进程上<br>回到python程序<br><code>io.recv( )</code>用于接收显示的数据<br><code>io.send( )</code>发送数据<br><code>io.sendline( )</code>用于回车</p>
<h3 id="结束调试"><a href="#结束调试" class="headerlink" title="结束调试"></a>结束调试</h3><p>python程序中<code>io.close( )</code><br>ida软件中<code>CTRL+F2</code></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://blog.csdn.net/asd413850393/article/details/101349924" target="_blank" rel="noopener">https://blog.csdn.net/asd413850393/article/details/101349924</a><br>[2] <a href="https://github.com/Sp4n9x/blog_backup/blob/master/_posts/2018-04-05.Pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E2%80%94Ubuntu16.04.md" target="_blank" rel="noopener">https://github.com/Sp4n9x/blog_backup/blob/master/_posts/2018-04-05.Pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E2%80%94Ubuntu16.04.md</a><br>[3] <span id="ref3"><a href="http://brieflyx.me/2015/linux-tools/socat-introduction/" target="_blank" rel="noopener">http://brieflyx.me/2015/linux-tools/socat-introduction/</a></span><br>[4] <a href="https://zhuanlan.zhihu.com/p/71914632" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71914632</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>IDAPro</tag>
      </tags>
  </entry>
  <entry>
    <title>languageEnvConf</title>
    <url>/2019/10/28/languageEnvConf/</url>
    <content><![CDATA[<h1 id="语言环境的安装和配置"><a href="#语言环境的安装和配置" class="headerlink" title="语言环境的安装和配置"></a>语言环境的安装和配置</h1><a id="more"></a>
<h2 id="ubuntu16-04下的python3-7安装"><a href="#ubuntu16-04下的python3-7安装" class="headerlink" title="ubuntu16.04下的python3.7安装"></a>ubuntu16.04下的python3.7安装</h2><blockquote>
<p>ubuntu16.04默认安装有python3.5和python2.7<br>安装路径在<code>/usr/local/lib</code>下</p>
</blockquote>
<p>可以通过如下命令查看python的指向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll /usr/bin | grep python</span><br></pre></td></tr></table></figure>

<p>可以知道python的默认指向时python2.7</p>
<ul>
<li><p>step1： 下载python3.7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 解压安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf Pyhon-3.7.1.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>step3: 编译安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python-3.7.1</span><br><span class="line">./configure --prefix=/usr/local/python3.7.1</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>经过上面步骤有</p>
<table>
<tr><td>文件</td><td>路径</td></tr>
<tr><td>可执行文件</td><td>/usr/local/python3.7.1/bin</td></tr>
<tr><td>库文件</td><td>/usr/local/python3.7/lib</td></tr>
<tr><td>配置文件</td><td>/usr/local/python3.7/share</td></tr>
</table>

<ul>
<li><p>step4：配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看环境变量</span><br><span class="line">echo $PATH</span><br><span class="line">vim ~/bashrc</span><br><span class="line">#添加如下的语句</span><br><span class="line">PATH=$PATH:$HOME/bin:/usr/local/python3.7.1/bin</span><br><span class="line">source ~/bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>step5: 测试：<br>输入<code>python3.7</code>可进入python解释器即可<br><code>python -V</code>查看版本。<br>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">print(sys.version)</span><br><span class="line">print(sys.version_info)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>zlib模块缺失的解决方法</strong>：<br>官网下载zlib<code>wget http://zlib.net/zlib-1.2.11.tar.gz</code>，可以查看最新版本<br>然后解压，配置，安装<br>tar -xvf zlib-1.2.11.tar.gz<br>cd zlib-1.2.11<br>./configure<br>make<br>make install<br>最后重新编译安装python3.7</p>
</blockquote>
<blockquote>
<p><strong>No module named ‘_ctypes’解决方案</strong><br><code>sudo apt-get install libffi-dev</code><br>最后重新编译安装python3.7</p>
</blockquote>
<ul>
<li>step6: 修改系统默认指向<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除原有链接备份</span><br><span class="line">mv /usr/bin/python /usr/bin/python.bak</span><br><span class="line">建立新的链接</span><br><span class="line">ln -s /usr/local/python3.7.1/bin/python3.7 /usr/bin/python</span><br><span class="line">修改pip</span><br><span class="line">mv /usr/bin/pip /usr/bin/pip.bak</span><br><span class="line">建立新的pip</span><br><span class="line">ln -s /usr/local/python3.7.1/bin/pip3 /usr/bin/pip</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/u014775723/article/details/85213793" target="_blank" rel="noopener">https://blog.csdn.net/u014775723/article/details/85213793</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>语言环境安装配置</tag>
      </tags>
  </entry>
  <entry>
    <title>IISFTP</title>
    <url>/2019/10/24/IISFTP/</url>
    <content><![CDATA[<h1 id="win10搭建ftp服务实践"><a href="#win10搭建ftp服务实践" class="headerlink" title="win10搭建ftp服务实践"></a>win10搭建ftp服务实践</h1><p>win10下面用自带的iis搭建ftp服务用于文件传输</p>
<a id="more"></a>
<h2 id="1-开启IIS服务"><a href="#1-开启IIS服务" class="headerlink" title="1.开启IIS服务"></a>1.开启IIS服务</h2><p><img src="/images/iisftp/01.png" alt="pic"><br><img src="/images/iisftp/02.png" alt="pic"></p>
<h2 id="2-使用搜索功能打开IIS，添加ftp站点"><a href="#2-使用搜索功能打开IIS，添加ftp站点" class="headerlink" title="2.使用搜索功能打开IIS，添加ftp站点"></a>2.使用搜索功能打开IIS，添加ftp站点</h2><p><img src="/images/iisftp/03.png" alt="pic"><br><img src="/images/iisftp/04.png" alt="pic"><br><br>经过上面的步骤在本机上是可以访问到文件的，在局域网或者其它网络的机器是无法访问的。接下来继续配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftp://ip</span><br></pre></td></tr></table></figure>

<h2 id="3-配置防火墙"><a href="#3-配置防火墙" class="headerlink" title="3.配置防火墙"></a>3.配置防火墙</h2><p>一个简单的方法是关闭防火墙，这里配置其他方法不用关闭防火墙。</p>
<h3 id="3-1-放行21端口"><a href="#3-1-放行21端口" class="headerlink" title="3.1 放行21端口"></a>3.1 放行21端口</h3><p><img src="/images/iisftp/05.png" alt="pic"><br>点击高级设置<br><br><img src="/images/iisftp/06.png" alt="pic"><br>入站规则-&gt; 新建规则<br><br><img src="/images/iisftp/07.png" alt="pic"><br>选择端口，下一步<br><br><img src="/images/iisftp/08.png" alt="pic"><br>然后一直下一步。</p>
<h3 id="3-2-设置ftp允许通过防火墙"><a href="#3-2-设置ftp允许通过防火墙" class="headerlink" title="3.2 设置ftp允许通过防火墙"></a>3.2 设置ftp允许通过防火墙</h3><p><img src="/images/iisftp/09.png" alt="pic"><br><img src="/images/iisftp/10.png" alt="pic"><br>然后点击允许其他应用<br><img src="/images/iisftp/11.png" alt="pic"><br>大功告成。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>字符串格式化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>gccAndgdb</title>
    <url>/2019/10/09/gccAndgdb/</url>
    <content><![CDATA[<h1 id="linux下的c编程工具的使用"><a href="#linux下的c编程工具的使用" class="headerlink" title="linux下的c编程工具的使用"></a>linux下的c编程工具的使用</h1><a id="more"></a>
<p>test.c的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello, World\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-gcc工具的使用"><a href="#1-gcc工具的使用" class="headerlink" title="1.gcc工具的使用"></a>1.gcc工具的使用</h2><ul>
<li>不带任何参数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.c</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>会在同一个目录下面生成一个<code>a.out</code>文件，输入命令<code>./a.out</code>就可直接运行。</p>
<blockquote>
<p>直接经历了四个步骤：预处理Preprocessing，编译Compilation，汇编Assembly，链接Linking。</p>
</blockquote>
<ul>
<li>指定生成的文件名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>不会使用默认的a.out。</p>
<ul>
<li><p>gcc保留中间文件<br>gcc编译过程中，会删除中间的文件，可通过下面命令参数来保留各个阶段的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -save_temps test.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>gcc生成调试信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o test</span><br></pre></td></tr></table></figure>
</li>
<li><p>gcc编译生成32bit代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 hello.c -o hello</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果<code>-m32</code>无法运行，请安装下载相关包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential module-assistant  </span><br><span class="line">sudo apt-get install gcc-multilib g++-multilib</span><br></pre></td></tr></table></figure>

<ul>
<li>gcc版本信息查看<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-gcc的各个阶段分析"><a href="#2-gcc的各个阶段分析" class="headerlink" title="2.gcc的各个阶段分析"></a>2.gcc的各个阶段分析</h2><h3 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<p>功能：主要处理源代码中以 “#” 开始的预编译指令<br>生成文件：<code>test.i</code><br>指定参数: <code>-E</code></p>
<h3 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -S test.c -o test.s</span><br><span class="line">#或者</span><br><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>

<p>输入的文件可以是源文件，也可以是预处理后的文件<br>功能：对预处理完的文件进行一系列<strong>词法分析、语法分析、语义分析</strong>及优化后生成相应的<strong>汇编代码</strong>文件<br>生成文件：<code>test.s</code><br>指定参数：<code>-S</code></p>
<h3 id="2-3-汇编"><a href="#2-3-汇编" class="headerlink" title="2.3 汇编"></a>2.3 汇编</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c test.c -o test.o</span><br><span class="line">#或者</span><br><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>

<p>输入的文件可以是源文件，也可以是编译后的文件<br>功能：汇编器将汇编代码转变成机器可以执行的指令<br>生成文件：<code>test.o</code>(<strong>不能直接执行</strong>)<br>指定参数：<code>-c</code></p>
<blockquote>
<p>objdump：一种可阅读的格式让你更多地了解二进制文件（反汇编）</p>
</blockquote>
<p><code>objdump -sd hello.o</code>可查看test.o的信息<br><img src="/images/gccAndgdb/objdump.png" alt="objdump"></p>
<h3 id="2-4-链接"><a href="#2-4-链接" class="headerlink" title="2.4 链接"></a>2.4 链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.o -o test</span><br></pre></td></tr></table></figure>

<p>输入文件可以是源文件也可以是汇编后的文件<br>指定参数：无<br>生成文件：<code>test</code>(<strong>可以执行</strong>)<br>目标文件需要链接一大堆文件才能得到最终的可执行文件<br>通过以下命令可查看反汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -d -j .text text</span><br></pre></td></tr></table></figure>

<h2 id="3-gdb的使用"><a href="#3-gdb的使用" class="headerlink" title="3.gdb的使用"></a>3.gdb的使用</h2><p>测试程序如下<code>test.c</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">   int a = 1;</span><br><span class="line">   int b = a;</span><br><span class="line">   printf(&quot;a = %d, b =%d\n&quot;, a, b);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GDB主要帮助你完成下面四个方面的功能：</p>
<ol>
<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。<h3 id="3-1-gbd调试程序的简易入门操作"><a href="#3-1-gbd调试程序的简易入门操作" class="headerlink" title="3.1 gbd调试程序的简易入门操作"></a>3.1 gbd调试程序的简易入门操作</h3></li>
</ol>
<ul>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动调试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#编译文件，加上调试信息。不加参数-g可能无法调试</span><br><span class="line">gcc -g test.c -o test</span><br><span class="line">#开始启动调试</span><br><span class="line">gdb test</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>拓展: 启动调试的时候输入<code>gdb -tui test</code>会有一个漂亮的交互窗口</p>
</blockquote>
<ul>
<li>调试的操作</li>
<li><em>注意*</em>  :括号内的东西不用输入</li>
</ul>
<ol>
<li><p>显示当前的代码，一次10行，继续输入<code>l</code>继续显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br></pre></td></tr></table></figure>
</li>
<li><p>单步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这个时候会进入程序运行状态，单步运行需要输入<code>n</code>，输入一次执行一条语句。<code>s</code>单步会进入子程序中去。</p>
<ol start="3">
<li>断点+单步<br>启动的时候<code>start</code>程序会在第一行停止。<br>这个时候可以设置断点，如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b 5</span><br><span class="line">(gdb) c #运行程序到断点处，一般在设置完断点后使用</span><br><span class="line">(gdb) r #重新运行程序 run</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>表示在第5行设置断点，输入命令<code>c</code>会直接运行到第5行；其中b后面的参数也可以是一个函数名。可以按照单步的方法继续运行。<br>可以同时设置多个断点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) display b</span><br></pre></td></tr></table></figure>

<p>这个display 可以查看变量的值</p>
<ol start="4">
<li>查看所有断点和删除<br>查看已经设置的断点<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br><span class="line">#可以简写成</span><br><span class="line">(gdb) i b</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/images/gccAndgdb/gdbInfo.png" alt="gdbInfo"><br>注意到每一个断点有编号，使用编号可删除断点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) delete 2</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>设置条件断点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b 5 if a == 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>观察变量改变的地方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) watch b</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>变量内存值被修改的时候会展示出来</p>
<ol start="7">
<li>反汇编命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">#可简写成</span><br><span class="line">(gdb) disas main</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>其中的main是一个函数名称。</p>
<h3 id="3-2-gdb插件—gdb-peda"><a href="#3-2-gdb插件—gdb-peda" class="headerlink" title="3.2 gdb插件—gdb-peda"></a>3.2 gdb插件—gdb-peda</h3><p>PEDA(<strong>Python Exploit Development Assistance for GDB</strong>)是一个强大的 gdb 插件。它提供了高亮显示反汇编代码、寄存器、内存信息等人性化的功能。同时，PEDA 还有一些实用的新命令，比如checksec 可以查看程序开启了哪些安全机制等等。</p>
<ul>
<li>安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">$ echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-Linux代码执行漏洞分析实战"><a href="#4-Linux代码执行漏洞分析实战" class="headerlink" title="4. Linux代码执行漏洞分析实战"></a>4. Linux代码执行漏洞分析实战</h2><p>主要工作：出发一个NoIP本地运行的栈溢出漏洞，用gdb调试工具找出漏洞发生的地点。</p>
<h3 id="4-1-准备"><a href="#4-1-准备" class="headerlink" title="4.1 准备"></a>4.1 准备</h3><p>NoIP本地栈溢出漏洞</p>
<ul>
<li><p>step1 注册NO-IP账号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://my.noip.com/#!/account</span><br><span class="line">https://www.noip.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2 在Linux下安装No-ip<br><a href="https://www.noip.com/support/knowledgebase/installing-the-linux-dynamic-update-client/" target="_blank" rel="noopener">官网</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget http://www.no-ip.com/client/linux/noip-duc-linux.tar.gz</span><br><span class="line">tar xzf noip-duc-linux.tar.gz</span><br><span class="line">cd no-ip-2.1.9</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>由PoC出发漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb noip2</span><br><span class="line">run -i $(python -c &apos;print (&quot;\x41&quot;*500)&apos;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>如果没有触发漏洞，将数值可以加大为1000，直到有漏洞触发</p>
</blockquote>
<p><img src="/images/gccAndgdb/noipPoc.png" alt="图片"><br>图1</p>
<ul>
<li>使用静态反汇编工具idaPro<br>win系统下远程连接linux编译文件调试参考文献<a href="#r01">1</a></li>
</ul>
<h3 id="4-2实验过程"><a href="#4-2实验过程" class="headerlink" title="4.2实验过程"></a>4.2实验过程</h3><p>由图1可知，漏洞发生之前，打印输出了字符串<code>IP address detected on command line.</code>我们先定位到这个字符串输出的位置。</p>
<ul>
<li>step1: IDAPro远程连接到Noip程序<br>打开搜索框，输入上面的那个字符串进行搜索。<br><img src="/images/gccAndgdb/findIPString.png" alt="pic"><blockquote>
<p>可以看到这里有一个mov操作，之后调用了<code>call Msg</code>。</p>
</blockquote>
</li>
</ul>
<p>因此我们在这个地点下一个断点，红色框框对应的地址()。</p>
<ul>
<li>step2: 切换回linux，设置断点<br>退出之前的gdb, <code>quit</code><br>重新进入<code>gdb noip2</code><br>通过第一步得到的地址设置断点<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b *0x00000000004021AB</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/images/gccAndgdb/bAddress.png" alt="pic"><br>可观察到在源码中对应的行数为line 607</p>
<ul>
<li>step3: 执行得到漏洞的命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run -i $(python -c &apos;print (&quot;\x41&quot;*1000)&apos;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/images/gccAndgdb/againRun1.png" alt="pic"><br>可以看到在<code>0x4021ab</code>处发生了中断，即我们设置的断点的地方。</p>
<ul>
<li>step4: 单步执行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ni</span><br><span class="line">#或者</span><br><span class="line">n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在这个过程中，可以看到运行到了<code>call Msg</code>，并且打印出了字符串<br><img src="/images/gccAndgdb/callMsg.png" alt="pic"><br>继续单步执行，可以看到输出另一串<code>Running in single use mode.</code><br>如果之前进行了<code>push</code>操作，可以使用命令这可以查看栈顶的的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/10x $esp</span><br><span class="line"># 查看内存的值</span><br><span class="line">(gdb) x/10x 0x4083b5(视情况)</span><br><span class="line">(gdb) x/100x 0x4083b5</span><br><span class="line"># 也可以以字符串形式输出内存的值</span><br><span class="line">(gdb) x/10s 0x4083b5</span><br></pre></td></tr></table></figure>

<p><img src="/images/gccAndgdb/xsStr.png" alt="pic"></p>
<ul>
<li>step5 继续单步，一直到出现漏洞<br><img src="/images/gccAndgdb/findError.png" alt="pic"></li>
</ul>
<p>可以发现，当程序调用<code>dynamic_update</code>的前中后出现了问题。<strong>有可能是在这个函数里面出现问题，也有可能是该函数嵌套的函数出现了问题。</strong><br>得到调用<code>dynamic_update</code>函数的地址为：<code>0x40233c</code></p>
<ul>
<li><p>step6: 重新设置断点<br>切换回IDAPro，以此选择<code>jump</code>-&gt;<code>jump address</code>输入上面得到的函数地址。切换到<code>graph view</code>按住<strong>F5</strong>可查看c伪代码。<br>找到调用<code>dynamic_update</code>函数之前的一个地址<code>0x402337</code>，重新设置断点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b *0x0x402337</span><br><span class="line">(gdb) run -i $(python -c &apos;print (&quot;\x41&quot;*1000)&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>step7 进入到函数内部<br>这里使用<code>si</code>或者<code>s</code>进行单步。<br>进入到<code>dynamic_update</code>函数后，使用<code>n</code>来单步，确定程序崩溃的地方。</p>
</li>
</ul>
<p>[1] <span id="r01"><a href="https://blog.csdn.net/lacoucou/article/details/71079552" target="_blank" rel="noopener">https://blog.csdn.net/lacoucou/article/details/71079552</a></span> windows下使用IDA远程调试linux(ubuntu)下编译的程序</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>balanceLvs</title>
    <url>/2019/10/08/balanceLvs/</url>
    <content><![CDATA[<h1 id="负载均衡之lvs"><a href="#负载均衡之lvs" class="headerlink" title="负载均衡之lvs"></a>负载均衡之lvs</h1><p><a href="http://www.linuxvirtualserver.org/zh/index.html" target="_blank" rel="noopener">官方文档</a></p>
<a id="more"></a>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-1-linux命令"><a href="#1-1-linux命令" class="headerlink" title="1.1 linux命令"></a>1.1 linux命令</h3><ul>
<li><p><code>route</code> 查看本机的路由表<br><img src="/images/balanceLvs/route.png" alt="route"></p>
<blockquote>
<p>-n 不带地址转换，IP显示<code>route -n</code></p>
</blockquote>
</li>
<li><p><code>netstat -natp</code> 查看本机的TCP链接程序<br><img src="/images/balanceLvs/netstat.png" alt="netstat"></p>
<blockquote>
<p>-n 不进行转换，全以IP地址显示<br>-a 是所有的链接<br>-t tcp链接</p>
</blockquote>
</li>
<li><p><code>arp -a</code>查看MAC地址表</p>
<h3 id="1-2-一些名称"><a href="#1-2-一些名称" class="headerlink" title="1.2 一些名称"></a>1.2 一些名称</h3><table>
<thead>
<tr>
<th align="center">全称</th>
<th align="center">缩写</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">虚拟IP地址Virtual IP address</td>
<td align="center">VIP</td>
<td align="center">提供服务的IP地址,如<a href="http://www.baidu.com通过DNS得到的地址" target="_blank" rel="noopener">www.baidu.com通过DNS得到的地址</a></td>
</tr>
<tr>
<td align="center">转发的网络地址Director IP address</td>
<td align="center">DIP</td>
<td align="center">负载均衡器上面的IP</td>
</tr>
<tr>
<td align="center">真实IP地址Real IP address</td>
<td align="center">RIP</td>
<td align="center">后端集群主机</td>
</tr>
<tr>
<td align="center">客户端地址IP Client IP address</td>
<td align="center">CIP</td>
<td align="center">源IP地址</td>
</tr>
</tbody></table>
</li>
</ul>
<p>lvs负载均衡的拓扑结构<br><img src="/images/balanceLvs/topuGraph1.png" alt="tupu"></p>
<blockquote>
<p>说明</p>
<ol>
<li>负载均衡器工作在网络层，只转发数据包，不进行握手连接</li>
<li>要保证同一个客户端三次握手，四次分手不可分割，即转发到同一个服务器镜像</li>
<li>后端的真实服务器都是镜像，一模一样的。</li>
</ol>
</blockquote>
<h3 id="1-3-模型概述"><a href="#1-3-模型概述" class="headerlink" title="1.3 模型概述"></a>1.3 模型概述</h3><h4 id="1-3-1-D-NAT与S-NAT"><a href="#1-3-1-D-NAT与S-NAT" class="headerlink" title="1.3.1 D_NAT与S_NAT"></a>1.3.1 D_NAT与S_NAT</h4><p>客户端请求的数据包源地址和目的地址<code>CIP-VIP</code><br>当其到达负载均衡器入口时，如果不对该数据包做处理就转发，那么RealServer看到的目的IP地址就是VIP，不属于RealServer的IP,不会做出回应。<br><strong>因此在负载均衡器中需要对数据包中的目的地址进行转换</strong><br>修改目的地址(<strong>D_NAT技术</strong>)，数据包变为<code>CIP-RIP</code>,这个时候RealServer可处理该数据包</p>
<blockquote>
<p><strong>问题</strong> 此时RealServer建立的Sockt连接是：<code>RIP:Port---CIP:Port</code>,所以响应包的源地址和目的地址是：<code>RIP-CIP</code>。当这个数据包达到客户端的时候，与客户端发的请求包中的地址不对应了？</p>
</blockquote>
<p>因此，负载均衡器还需要负责将响应包的源地址修改为VIP(<strong>S_NAT技术</strong>)。<br>为了实现这个，RealServer的默认网关(default/0.0.0.0)需要指向LVS负载均衡器。</p>
<blockquote>
<p>缺点：所有数据(上行，下行)都要经过LVS，I/O瓶颈在这里会产生。<br>可行方案： 每一个RealServer不要将响应数据发给LVS,直接将响应包发给客户端。</p>
</blockquote>
<h4 id="1-3-2-DR模型"><a href="#1-3-2-DR模型" class="headerlink" title="1.3.2 DR模型"></a>1.3.2 DR模型</h4><blockquote>
<p>让RealServer拥有一个VIP这样的IP地址，但是不暴露在公网，自己有一个隐藏的VIP地址</p>
</blockquote>
<p>客户端发送<code>CIP-VIP</code>数据包，经过LVS到达RealServer,因为RealServre有一个隐藏的VIP地址，所以会接收该数据包，然后将响应包<code>VIP-CIP</code>直接发送给客户端，不用通过lvs负载均衡器。</p>
<ul>
<li>问题： 客户端的数据包是<code>CIP-VIP</code>，RealServer暴露的IP是RIP，lvs如何将客户端数据包发给RealServer。<blockquote>
<p>解答： 通过arp欺骗。lvs与RealServer必须在同一个局域网内</p>
</blockquote>
</li>
</ul>
<p><strong>缺点</strong> :要求lvs与RealServer在同一个局域网内，对分布在地理位置不同的数据中心无法做负载均衡。</p>
<h4 id="1-3-3-Tunnel与VPN模型"><a href="#1-3-3-Tunnel与VPN模型" class="headerlink" title="1.3.3 Tunnel与VPN模型"></a>1.3.3 Tunnel与VPN模型</h4><p>客户端发出数据包<code>CIP-VIP</code>。数据包到达lvs的时候，建立一个新的请求，发送数据包<code>DIP-RIP</code>,这个数据包会将客户端的所有数据都封装起来。然后通过公网到RealServer。<br>RealServer会拆包，得到里面的<code>CIP-VIP</code>请求。自己有隐藏的VIP地址。</p>
<h3 id="1-4-linux隐藏IP的方法"><a href="#1-4-linux隐藏IP的方法" class="headerlink" title="1.4 linux隐藏IP的方法"></a>1.4 linux隐藏IP的方法</h3><p>对内可见，对外隐藏。<br><strong>需要隐藏的IP配置到外部无法访问的网卡上</strong>就是lo网卡，环回接口<br>注意：一个网卡可以添加多个IP地址，所以环回地址127.0.0.1不受影响。</p>
<blockquote>
<p>基础知识：在一个局域网内，如果主机A的arp表中无主机B的mac地址且要发送数据包到主机B，就会进行arp请求。这个时候主机B会发送响应请求，告诉主机A它的IP和对应的MAC地址。</p>
</blockquote>
<p>配置文件：<code>/proc/sys/net/ipv4/conf/</code></p>
<ul>
<li>对于<code>arp_ignore</code>控制系统在收到外部的arp请求时，是否要返回arp响应,<strong>配置为1</strong><blockquote>
<p>arp_ignore为0：回应任何网络接口（网卡）上对任何本机IP地址的arp查询请求<br>为1：只回答目标IP地址是本机上来访网络接口（网卡）IP地址的ARP查询请求 。比如eth0=192.168.0.1/24,eth1=10.1.1.1/24,那么即使eth0收到来自10.1.1.2这样地址发起的对192.168.0.1的查询会回应，而对10.1.1.1 的arp查询不会回应。</p>
</blockquote>
</li>
<li><code>arp_announce</code>定义将自己地址向外通告时的通告级别，<strong>配置为2</strong><blockquote>
<p>0：将本地任何接口上的任何地址向外通告；<br>1：试图仅向目标网络通告与其网络匹配的地址；<br>2：仅向与本地接口上地址匹配的网络进行通告</p>
</blockquote>
</li>
</ul>
<h2 id="2-DR实验"><a href="#2-DR实验" class="headerlink" title="2. DR实验"></a>2. DR实验</h2><h3 id="2-1-lvs简介"><a href="#2-1-lvs简介" class="headerlink" title="2.1 lvs简介"></a>2.1 lvs简介</h3><p>lvs： Linux Virtual Server，linux虚拟服务器。<br>核心程序：ipvs（嵌入到了Linux内核中）<br>管理程序：ipvsadm<br>调度算法：</p>
<table>
<tr><td colspan="2">调度方式</td><td>英文</td><td>描述</td></tr>
<tr><td rowspan="4">静态调度</td><td>轮询调度</td><td>Round Robin 简称'RR'</td><td>依次循环的方式将请求调度到不同的服务器上</td></tr>
<tr><td>加权轮询调度</td><td>Weight Round Robin 简称'WRR'</td><td>权值越高的服务器，处理的请求越多</td></tr>
<tr><td>目标地址散列调度</td><td>Destination Hashing 简称'DH'</td><td>算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空</td></tr>
<tr><td>源地址散列调度</td><td>Source Hashing  简称'SH'</td><td>先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</td></tr>
<tr><td rowspan="6">动态调度</td><td>最小连接调度</td><td>Least Connections 简称'LC'</td><td>新的连接请求分配到当前连接数最小的服务器</td></tr>
<tr><td>加权最小连接调度</td><td>Weight Least Connections 简称'WLC'</td><td>加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值</td></tr>
<tr><td>最短的期望的延迟</td><td>Shortest Expected Delay 简称'SED'</td><td>请求交给得出运算结果最小的服务器</td></tr>
<tr><td>最少队列调度</td><td>Never Queue 简称'NQ'</td><td>无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。</td></tr>
<tr><td>带复制的基于局部性的最少连接</td><td>Locality-Based Least Connections with Replication  简称'LBLCR'</td><td>按'最小连接'原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按'最小连接'原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</td></tr>
<tr><td>基于局部的最少连接</td><td>Locality-Based Least Connections 简称'LBLC'</td><td>LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用'最少连接'的原则选出一个可用的服务器，将请求发送到服务器。</td></tr>
</table>

<h3 id="2-2-ipvsadm的使用"><a href="#2-2-ipvsadm的使用" class="headerlink" title="2.2 ipvsadm的使用"></a>2.2 ipvsadm的使用</h3><p>配置主要分为两个阶段，第一配置哪些数据包需要进行转发，第二配置数据包转发到哪里去。</p>
<ul>
<li><p>安装管理模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centOS: yum install ipvsadm -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置哪些数据包需要lvs转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式： ipvsadm -A -t|u|f ServerAddress [-s schduler]</span><br><span class="line">-t: tcp协议的集群 地址为IP:PORT</span><br><span class="line">-u: udp协议的集群 地址为IP:PORT</span><br><span class="line">-f: 防火墙标记 地址为MarkNumber</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>eg：<code>ipvsadm -A -t 192.168.10.10:80 -s rr</code> 目的地址为192.168.10.10:80的tcp协议的数据包需要进行lvs，使用rr调度算法进行负载均衡。</p>
<ul>
<li>配置数据包转发到RealServer<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：ipvsadm -a -t|u|f service-address -r server-address [-g|i|m] [-w weight]</span><br><span class="line">前部分是配置的哪些数据包需要lvs转发，即配置的集群服务</span><br><span class="line">-r 该参数后面是RealServer的地址，可以是IP:PORT</span><br><span class="line">-g DR模式</span><br><span class="line">-i Tunnel模式</span><br><span class="line">-m NAT模式</span><br><span class="line">-w 该参数和值定义服务器权重</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>eg: <code>ipvsadm -a -t 192.168.10.10:80 -r 192.168.10.8 –g</code></p>
<h3 id="2-3-实验拓扑"><a href="#2-3-实验拓扑" class="headerlink" title="2.3 实验拓扑"></a>2.3 实验拓扑</h3><p><img src="/images/balanceLvs/drModel1.png" alt="topu"><br>蓝色的路径是请求数据包的路线，绿色的是响应数据包的路线。忽略了网关。</p>
<h3 id="2-4-实验过程"><a href="#2-4-实验过程" class="headerlink" title="2.4 实验过程"></a>2.4 实验过程</h3><ul>
<li>step1: 三台虚拟机，eth0在同一个网络192.168.10.0</li>
<li>step2: 配置node1(lvs)的VIP<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig eth0:0 192.168.10.10/24</span><br><span class="line">echo “1” &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意：当计算机收到一个目的地址不属于自己IP的数据包时候默认会丢弃，因此lvs这个需要设置ip_forward的值为1，充当路由器的功能，将数据包转发出去。</p>
<ul>
<li>step3: 修改RealServer的arp响应和通告级别</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo “1” &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">echo 1  &gt; /proc/sys/net/ipv4/conf/eth0/arp_ignore</span><br><span class="line">echo 2  &gt; /proc/sys/net/ipv4/conf/eth0/arp_announce</span><br><span class="line">echo 1  &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">echo 2  &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br></pre></td></tr></table></figure>

<ul>
<li>step4: 配置每一台RealSerer的VIP(隐藏IP)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig lo:8 192.168.10.10 netmask 255.255.255.255</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意: 响应和通告级别一定要先配置，不然VIP后被通告出去。</p>
</blockquote>
<p>至此，三个节点的信息如下<br><img src="/images/balanceLvs/nodes.png" alt="nods"></p>
<ul>
<li>step5: 启动RrealServer上的httpd<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install httpd -y</span><br><span class="line">#启动命令</span><br><span class="line">service httpd start</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>静态网页的路径<code>/var/www/html</code></p>
<p>#参考文献<br>[1] <a href="http://www.linuxvirtualserver.org/zh/index.html" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/zh/index.html</a><br>[2] <a href="https://www.cnblogs.com/gaoxu387/p/7941381.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaoxu387/p/7941381.html</a><br>[3] <a href="https://blog.csdn.net/weixin_40470303/article/details/80541639" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40470303/article/details/80541639</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>configurationARGS</title>
    <url>/2019/10/07/configurationARGS/</url>
    <content><![CDATA[<h1 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h1><h2 id="1-vim的配置参数"><a href="#1-vim的配置参数" class="headerlink" title="1. vim的配置参数"></a>1. vim的配置参数</h2><a id="more"></a>
<p>针对每一个用户修改，在/etc/vimrc中是所有用户生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></table></figure>

<p>输入如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;关闭vim一致性原则</span><br><span class="line">set nocompatible</span><br><span class="line">&quot;显示行号</span><br><span class="line">set number</span><br><span class="line">&quot;设置在编辑过程中右下角显示光标的行列信息</span><br><span class="line">set ruler</span><br><span class="line">&quot;在状态栏显示正在输入的命令</span><br><span class="line">set showcmd</span><br><span class="line">&quot;设置历史记录条数</span><br><span class="line">set history=1000</span><br><span class="line">&quot;设置取消备份 禁止临时文件的生成</span><br><span class="line">set nobackup</span><br><span class="line">set noswapfile</span><br><span class="line">&quot;设置匹配模式</span><br><span class="line">set showmatch</span><br><span class="line">&quot;设置C/C++方式自动对齐</span><br><span class="line">set autoindent</span><br><span class="line">set cindent</span><br><span class="line">&quot;开启语法高亮功能</span><br><span class="line">syntax on</span><br><span class="line">&quot;指定配色方案为256色</span><br><span class="line">set t_Co=256</span><br><span class="line">&quot;设置搜索时忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line">&quot;配置backspace的工作方式</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line">&quot;设置在vim中可以使用鼠标</span><br><span class="line">set mouse=a</span><br><span class="line">&quot;设置tab宽度</span><br><span class="line">set tabstop=4</span><br><span class="line">&quot;设置自动对齐空格数</span><br><span class="line">set shiftwidth=4</span><br><span class="line">&quot;设置退格键时可以删除4个空格</span><br><span class="line">set smarttab</span><br><span class="line">set softtabstop=4</span><br><span class="line">&quot;将tab键自动转换为空格</span><br><span class="line">set expandtab</span><br></pre></td></tr></table></figure>

<p>最后使配置生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.vimrc</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>conf</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorchEnvInUbuntu1604</title>
    <url>/2019/10/07/pytorchEnvInUbuntu1604/</url>
    <content><![CDATA[<h1 id="ubuntu16-04中搭建PyTorch环境"><a href="#ubuntu16-04中搭建PyTorch环境" class="headerlink" title="ubuntu16.04中搭建PyTorch环境"></a>ubuntu16.04中搭建PyTorch环境</h1><p><a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">官网链接</a></p>
<a id="more"></a>
<h2 id="1-选择的环境"><a href="#1-选择的环境" class="headerlink" title="1.选择的环境"></a>1.选择的环境</h2><ul>
<li><p>Anaconda<br>原因：python搭建torch，numpy等模块太费劲，需要下载源代码编译安装等。直接选择anaconda比较简单。不需要处理复杂的包依赖关系</p>
<h2 id="2-安装过程"><a href="#2-安装过程" class="headerlink" title="2.安装过程"></a>2.安装过程</h2></li>
<li><p>step1: 安装Anaconda</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The version of Anaconda may be different depending on when you are installing`</span><br><span class="line">curl -O https://repo.anaconda.com/archive/Anaconda3-5.2.0-Linux-x86_64.sh</span><br><span class="line">sh Anaconda3-5.2.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 使配置文件生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>还可以通过重启来使之生效reboot</p>
<ul>
<li>step3: 安装pyTorch</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision cpuonly -c pytorch</span><br></pre></td></tr></table></figure>

<h2 id="3-安装过程的一些麻烦事"><a href="#3-安装过程的一些麻烦事" class="headerlink" title="3.安装过程的一些麻烦事"></a>3.安装过程的一些麻烦事</h2><p>Anaconda安装后默认使用它带的python环境，为了不影响其他python程序的运行，如（VNCServer），会出现<strong>终端调不出来</strong>的情况。<br>需要重新配置环境变量。<br><br>找到~/.bashrc文件中的如下语句（路径可能随系统不同而变化）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;/root/anaconda2/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>修改为下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;$PATH:/root/anaconda2/bin&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时候在终端运行<code>python --version</code>是系统配置的python环境了，需要anaconda的python环境，只需要找到anaconda安装目录下的bin文件即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>numpyPractice</title>
    <url>/2019/10/05/numpyPractice/</url>
    <content><![CDATA[<h1 id="numpy-Numerical-Python-数值计算基础"><a href="#numpy-Numerical-Python-数值计算基础" class="headerlink" title="numpy (Numerical Python)数值计算基础"></a>numpy (Numerical Python)数值计算基础</h1><p><a href="https://numpy.org/" target="_blank" rel="noopener">官网链接</a></p>
<a id="more"></a>
<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h1><ul>
<li>python 语言数值计算扩充库</li>
<li>强大的高维数组处理和矩阵运算能力</li>
<li>NumPy 的主要对象是多维数组 Ndarray</li>
</ul>
<h1 id="二-应用demo"><a href="#二-应用demo" class="headerlink" title="二. 应用demo"></a>二. 应用demo</h1><h2 id="1-导入模块与查看版本信息"><a href="#1-导入模块与查看版本信息" class="headerlink" title="1.导入模块与查看版本信息"></a>1.导入模块与查看版本信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print(np.__version__)</span><br></pre></td></tr></table></figure>

<h2 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2.创建数组"></a>2.创建数组</h2><blockquote>
<p>主要创建数组的途径<br></p>
<ul>
<li>从 Python 数组结构列表，元组等转换。</li>
<li>使用 np.arange、np.ones、np.zeros 等 NumPy 原生方法。</li>
<li>从存储空间读取数组。</li>
<li>通过使用字符串或缓冲区从原始字节创建数组。</li>
<li>使用特殊函&emsp;&emsp;数，如 random。</li>
</ul>
</blockquote>
<h3 id="2-1-通过列表创建数组"><a href="#2-1-通过列表创建数组" class="headerlink" title="2.1 通过列表创建数组"></a>2.1 通过列表创建数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一维数组</span><br><span class="line">a = np.array([1, 2, 3])</span><br><span class="line">print(a)</span><br><span class="line"># 二维数组</span><br><span class="line">b = np.array([(1, 2, 3), (4, 5, 6)])</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-使用原生方法"><a href="#2-2-使用原生方法" class="headerlink" title="2.2 使用原生方法"></a>2.2 使用原生方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建全为0的数组</span><br><span class="line">a = np.zeros((3, 3))</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">#创建全为1的数组</span><br><span class="line">b = np.ones((2, 2, 4))</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong> : numpy.ones(shape, dtype=None, order=’C’)，shape指定数组的形状,每个轴的长度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建一维等差数组</span><br><span class="line">a = np.arange(5)</span><br><span class="line">print(a)</span><br><span class="line"># 结果：[0 1 2 3 4]</span><br><span class="line"></span><br><span class="line">#创建二维等差数组</span><br><span class="line">b = np.arange(6).reshape(2, 3)</span><br><span class="line">print(b)</span><br><span class="line"># 结果：[[0 1 2]</span><br><span class="line">#       [3 4 5]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>arange说明</strong> <br></p>
<ul>
<li>格式： numpy.arange(start, stop, step, dtype=None)<br></li>
<li>[start, stop) 半开半闭区间内创建一系列均匀间隔的值</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建二维单位阵</span><br><span class="line">a = np.eye(3)</span><br><span class="line">print(a)</span><br><span class="line"># 结果：</span><br><span class="line"># [[1. 0. 0.]</span><br><span class="line">#  [0. 1. 0.]</span><br><span class="line">#  [0. 0. 1.]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>eye说明</strong> <br></p>
<ul>
<li>格式： numpy.eye(N, M=None, k=0, dtype=&lt;type ‘float’&gt;) <br></li>
<li>k：对角线索引：0（默认）是指主对角线，正值是指上对角线，负值是指下对角线</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建等间隔的一维数组</span><br><span class="line">a = np.linspace(1, 10, num=7)</span><br><span class="line">print(a)</span><br><span class="line"># 结果 [ 1 2.5 4 5.5 7 8.5 10. ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>linspace说明</strong> <br></p>
<ul>
<li>格式： numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 同arange<br></li>
<li>endpoint 指示是否最后一个样本包含在序列内</li>
</ul>
</blockquote>
<h3 id="2-3-使用特殊函数创建数组"><a href="#2-3-使用特殊函数创建数组" class="headerlink" title="2.3 使用特殊函数创建数组"></a>2.3 使用特殊函数创建数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建二维随机数组</span><br><span class="line">a = np.random.rand(2, 3)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"># 结果： [[0.72448631 0.19235668 0.00701753]</span><br><span class="line">        [0.05801567 0.9642479  0.22793563]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>rand()说明</strong> <br><br>括号内指定数组的形状 <br><br>使用[0, 1)之间的数随机填充</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建二维随机数组(数值&lt;5)</span><br><span class="line">a = np.random.randint(5, size=(2, 4))</span><br><span class="line">print(a)</span><br><span class="line"># 结果：</span><br><span class="line">[[3 1 2 0]</span><br><span class="line"> [1 4 2 2]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>randint()说明</strong> <br><br>格式： randint(low, high, size, dtype) <br><br>生成[low, high) 的随机数<br>一维数组的时候size参数可直接填数字  eg:<code>randint(1, 3, 10)</code></p>
</blockquote>
<h3 id="2-4-从已知数据创建"><a href="#2-4-从已知数据创建" class="headerlink" title="2.4 从已知数据创建"></a>2.4 从已知数据创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用lambda创建数组</span><br><span class="line">a = np.fromfunction(lambda i, j: i + j, (3, 3))</span><br><span class="line">print(a)</span><br><span class="line"># 结果：</span><br><span class="line">#[[0. 1. 2.]</span><br><span class="line">#[1. 2. 3.]</span><br><span class="line">#[2. 3. 4.]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>fromfunction说明</strong><br><br>格式： fromfunction（function，shape）：通过函数返回值来创建多维数组</p>
</blockquote>
<h2 id="3-数组运算"><a href="#3-数组运算" class="headerlink" title="3. 数组运算"></a>3. 数组运算</h2><h3 id="3-1-一维数组的四则运算"><a href="#3-1-一维数组的四则运算" class="headerlink" title="3.1 一维数组的四则运算"></a>3.1 一维数组的四则运算</h3><p>生成两个Ndarry<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([10, 20, 30, 40, 50])</span><br><span class="line">b = np.arange(1, 6)</span><br><span class="line">#b数组：[1 2 3 4 5]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c = a + b</span><br><span class="line">print(&quot;c: &quot;, end=&quot;&quot;)</span><br><span class="line">#结果： [11 22 33 44 55]</span><br><span class="line">c = a - b</span><br><span class="line">c = a * b</span><br><span class="line">c = a / b</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> ：<strong>数组大小不一样会发生异常</strong></p>
<h3 id="3-2-二维数组（矩阵）的运算"><a href="#3-2-二维数组（矩阵）的运算" class="headerlink" title="3.2 二维数组（矩阵）的运算"></a>3.2 二维数组（矩阵）的运算</h3><p>生成两个Ndarry <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([[1, 2], [3, 4]])</span><br><span class="line">b = np.array([[5, 6], [7, 8]])</span><br></pre></td></tr></table></figure>

<p>同一维数组一样，可以进行个元素分别的四则运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c = a + b</span><br><span class="line">c = a * b</span><br></pre></td></tr></table></figure>

<p>但是矩阵乘法是不一样的： 矩阵m*n与矩阵n*p的矩阵是m*p</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#矩阵乘法</span><br><span class="line">c = np.dot(a, b)</span><br><span class="line"></span><br><span class="line">c = np.mat(a) * np.mat(b)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong><br><br>这里的a, b都是二维数组，所以用dot进行运算<br><br>可以使用np.mat(a)将二维数组转换为矩阵，直接使用*</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 矩阵数乘</span><br><span class="line">c = 2 * a</span><br><span class="line"></span><br><span class="line"># 矩阵转置</span><br><span class="line">c = a.T</span><br><span class="line"></span><br><span class="line"># 矩阵求逆</span><br><span class="line">c = np.linalg.inv(a)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>np.linalg中涉及到矩阵的计算方法，求解特征值、特征向量、逆矩阵等</p>
</blockquote>
<h2 id="4-数组索引和切片"><a href="#4-数组索引和切片" class="headerlink" title="4. 数组索引和切片"></a>4. 数组索引和切片</h2><h3 id="4-1-一维数组"><a href="#4-1-一维数组" class="headerlink" title="4.1 一维数组"></a>4.1 一维数组</h3><p>一个一维数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure>

<p>一维数组索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(a[0], a[-1])</span><br><span class="line"># 结果： 1 5</span><br></pre></td></tr></table></figure>

<p>一维数组切片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([1, 2, 3, 4, 5])</span><br><span class="line"></span><br><span class="line">print(a[0:2])</span><br><span class="line"># 结果 [1 2]</span><br><span class="line"></span><br><span class="line">print(a[:-1])</span><br><span class="line"># 结果 [1 2 3 4]</span><br></pre></td></tr></table></figure>

<h3 id="4-2-二维数组"><a href="#4-2-二维数组" class="headerlink" title="4.2 二维数组"></a>4.2 二维数组</h3><p>一个二维数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)])</span><br></pre></td></tr></table></figure>

<p>二维数组索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)])</span><br><span class="line">print(a[0])</span><br><span class="line"># 结果： [1 2 3]</span><br><span class="line"></span><br><span class="line">print(a[-1])</span><br><span class="line"># 结果： [7 8 9]</span><br></pre></td></tr></table></figure>

<p>二维数组切片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)])</span><br><span class="line"></span><br><span class="line">print(a[0:3, 1]) #等价于a[:, 1]</span><br><span class="line"># 结果： [2 5 8]  取第2列</span><br><span class="line"></span><br><span class="line"># 取第二三行</span><br><span class="line">print(a[1:3, :])</span><br><span class="line"># 结果：</span><br><span class="line"># [[4 5 6]</span><br><span class="line"># [7 8 9]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>(a, c)括号前面控制的是选取的行， 后面控制的是列。</p>
</blockquote>
<h2 id="5-数组形状操作"><a href="#5-数组形状操作" class="headerlink" title="5. 数组形状操作"></a>5. 数组形状操作</h2><ul>
<li><p>查看数组形状</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.random((3, 2))</span><br><span class="line">print(a)</span><br><span class="line">print(a.shape)</span><br><span class="line"># result: (3, 2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改数组形状（不改变原始数组）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.randint(1, 10, 6).reshape(3, 2)</span><br><span class="line">print(a)</span><br><span class="line">c = a.reshape((2, 3))</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>说明</strong> <br></p>
<ol>
<li>numpy.reshape() 等效于 ndarray.reshape()。<br></li>
<li>numpy.reshape(a, newshape)。 其中newshape 用于指定新的形状(整数或者元组)。</li>
</ol>
</blockquote>
<ul>
<li><p>更改数组形状（改变原始数组）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.randint(1, 10, 6).reshape(3, 2)</span><br><span class="line">print(a)</span><br><span class="line">a.resize(2, 3)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组扁平化(变为一维数组)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.randint(1, 10, 6).reshape(3, 2)</span><br><span class="line">print(a)</span><br><span class="line">c = np.ravel(a)</span><br><span class="line">d = a.ravel()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>numpy.ravel(a, order=’C’) 按行读取<br>numpy.ravel(a, order=’F’) 按列读取</p>
</blockquote>
<ul>
<li>垂直方向堆叠数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.randint(10, size=(2, 2))</span><br><span class="line">b = np.random.randint(10, size=(2, 2))</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">c = np.vstack((a, b))</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出 <br><br>a: [[2 9] [8 1]] <br><br>b: [[1 5] [0 1]]<br>c: [[2 9] [8 1] [1 5] [0 1]] <br><br> 拓展 d = np.hstack((a, b))  水平方向上堆叠数组</p>
</blockquote>
<h2 id="6-数组排序与统计"><a href="#6-数组排序与统计" class="headerlink" title="6. 数组排序与统计"></a>6. 数组排序与统计</h2><ul>
<li><p>返回每列最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.max(a, axis=0)</span><br><span class="line">print(c)</span><br><span class="line"># result： [6 7 9]</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回每行最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.min(a, axis=1)</span><br><span class="line">print(c)</span><br><span class="line"># result: [1 2 2]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>返回每列最大值索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.argmax(a, axis=0)</span><br><span class="line">print(c)</span><br><span class="line"># result: [1 2 1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回每行最小值索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.argmin(a, axis=1)</span><br><span class="line">print(c)</span><br><span class="line"># result: [0 1 2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计数组各列的中位数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.median(a, axis=0)</span><br><span class="line">print(c)</span><br><span class="line"># result: [4. 4. 3.]</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他</p>
<blockquote>
<p> np.mean(a, axis=1)统计数组各行的算术平均值 <br><br>np.average(a, axis=0)统计数组各列的加权平均值 <br><br>np.var(a, axis=1)统计数组各行的方差 <br><br>np.std(a, axis=0) 统计数组各列的标准偏差<br></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu1604vnc</title>
    <url>/2019/10/05/ubuntu1604vnc/</url>
    <content><![CDATA[<h1 id="ubuntu16-04-VNC远程桌面"><a href="#ubuntu16-04-VNC远程桌面" class="headerlink" title="ubuntu16.04 VNC远程桌面"></a>ubuntu16.04 VNC远程桌面</h1><h2 id="1-VNC简介"><a href="#1-VNC简介" class="headerlink" title="1. VNC简介"></a>1. VNC简介</h2><a id="more"></a>
<ul>
<li>VNC(Virtual Network Console):虚拟网络控制台，一个远程控制的工具软件 <br></li>
<li>VNC包括四个命令：<strong>vncserver</strong>, <strong>vncviewer</strong>, vncpasswd, vncconnect.</li>
<li>VNC由两部分组成，客户端的应用软件(vncviewer)&emsp;+&emsp;服务器端的应用程序(vncserver)</li>
</ul>
<h2 id="2-ubuntu16-04中安装服务端程序"><a href="#2-ubuntu16-04中安装服务端程序" class="headerlink" title="2. ubuntu16.04中安装服务端程序"></a>2. ubuntu16.04中安装服务端程序</h2><p>使用SSH登录到系统<br></p>
<ul>
<li><p>step1 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>step 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vnc4server</span><br></pre></td></tr></table></figure>
</li>
<li><p>step 3<br>启动vncserver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>步骤三中会出现如下界面<br><img src="/images/ubuntu1604vnc/01.png" alt="pic01"><br>输入密码即可，这是客户端登陆密码。<br><br>出现如下界面说明服务端安装成功<br><img src="/images/ubuntu1604vnc/02.png" alt="pic02"></p>
<blockquote>
<p>此时使用vncviewer登录出现的界面如下所示，对此需要安装一个图形化桌面<br><img src="/images/ubuntu1604vnc/03.png" alt="pic03"></p>
</blockquote>
<h2 id="3-ubuntu16-04安装图形化桌面"><a href="#3-ubuntu16-04安装图形化桌面" class="headerlink" title="3. ubuntu16.04安装图形化桌面"></a>3. ubuntu16.04安装图形化桌面</h2><h3 id="3-1-全ubuntu16-04桌面-不推荐-gnome环境"><a href="#3-1-全ubuntu16-04桌面-不推荐-gnome环境" class="headerlink" title="3.1 全ubuntu16.04桌面(不推荐)gnome环境"></a>3.1 全ubuntu16.04桌面(不推荐)gnome环境</h3><blockquote>
<p>缺点：占用资源多</p>
<ul>
<li>step1&emsp;安装x-windows</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install x-window-system-core</span><br></pre></td></tr></table></figure>

<ul>
<li><p>step2&emsp;安装登录管理器(可不选)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdm</span><br></pre></td></tr></table></figure>
</li>
<li><p>step3&emsp;安装ubuntu桌面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ubuntu-desktop</span><br></pre></td></tr></table></figure>
</li>
<li><p>step4&emsp;安装gnome配套软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br></pre></td></tr></table></figure>
</li>
<li><p>step5&emsp;修改VNC配置文件，使桌面生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>变成如下文件配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Uncomment the following two lines for normal desktop:</span><br><span class="line">export XKL_XMODMAP_DISABLE=1</span><br><span class="line"> unset SESSION_MANAGER</span><br><span class="line"># exec /etc/X11/xinit/xinitrc</span><br><span class="line">unset DBUS_SESSION_BUS_ADDRESS</span><br><span class="line">gnome-panel &amp;</span><br><span class="line">gnmoe-settings-daemon &amp;</span><br><span class="line">metacity &amp;</span><br><span class="line">nautilus &amp;</span><br><span class="line">gnome-terminal &amp;</span><br></pre></td></tr></table></figure>

<p>重新启动就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver -kill :1  #杀掉原桌面进程（:1)就是</span><br><span class="line">vncserver :1 #重新启动</span><br></pre></td></tr></table></figure>

<h3 id="3-2-ubuntu16-04剪切版-推荐-emsp-gnome环境"><a href="#3-2-ubuntu16-04剪切版-推荐-emsp-gnome环境" class="headerlink" title="3.2 ubuntu16.04剪切版(推荐)&emsp;gnome环境"></a>3.2 ubuntu16.04剪切版(推荐)&emsp;gnome环境</h3><blockquote>
<p>优点：占用系统资源少，仅安装核心组件：不安装例如 office、浏览器、等等的额外组件</p>
<ul>
<li>step1&emsp;安装x-windows</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install x-window-system-core</span><br></pre></td></tr></table></figure>

<ul>
<li><p>step2&emsp;安装登录管理器(可不选)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdm</span><br></pre></td></tr></table></figure>
</li>
<li><p>step3&emsp;安装ubuntu桌面(剪切版)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install --no-install-recommends ubuntu-desktop</span><br></pre></td></tr></table></figure>
</li>
<li><p>step4&emsp;安装gnome配套软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br></pre></td></tr></table></figure>
</li>
<li><p>step5&emsp;修改VNC配置文件，使桌面生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>在文件最后添加如下记录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gnome-panel &amp;</span><br><span class="line">gnome-settings-daemon &amp;</span><br><span class="line">metacity &amp;</span><br><span class="line">nautilus &amp;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-安装xfce4桌面"><a href="#3-3-安装xfce4桌面" class="headerlink" title="3.3 安装xfce4桌面"></a>3.3 安装xfce4桌面</h3><blockquote>
<p>优点：Xfce占用的内存和CPU使用量非常小；Xfce桌面很简单，而且没有乱七八糟的东西<a href="#re3">参考文献</a></p>
<ul>
<li>step 1:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xfce4</span><br></pre></td></tr></table></figure>

<ul>
<li>step 2:修改配置文件<br>该文件路径一般在下面<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#x-window-manager &amp;</span><br><span class="line">sesion-manager &amp; xfdesktop &amp; xfce4-panel &amp;</span><br><span class="line">xfce4-menu-plugin &amp;</span><br><span class="line">xfsettingsd &amp;</span><br><span class="line">xfconfd &amp;</span><br><span class="line">xfwm4 &amp;</span><br></pre></td></tr></table></figure>

<h2 id="4-卸载桌面程序"><a href="#4-卸载桌面程序" class="headerlink" title="4. 卸载桌面程序"></a>4. 卸载桌面程序</h2><h3 id="4-1-卸载gnome桌面"><a href="#4-1-卸载gnome桌面" class="headerlink" title="4.1 卸载gnome桌面"></a>4.1 卸载gnome桌面</h3><ul>
<li><p>step1: 卸载掉gnome-shell主程序及其配套软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove gnome-shell</span><br><span class="line">sudo apt-get remove ubuntu-desktop</span><br><span class="line">sudo apt-get remove gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 清理安装gnome时候留下的缓存程序软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoclean</span><br><span class="line">sudo apt-get clean</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-2-卸载xfce4桌面"><a href="#4-2-卸载xfce4桌面" class="headerlink" title="4.2 卸载xfce4桌面"></a>4.2 卸载xfce4桌面</h3><ul>
<li><p>step1: 卸载xfce4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove xfce4</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 卸载相关软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove xfce4*</span><br></pre></td></tr></table></figure>
</li>
<li><p>step3: 自动卸载不必要的软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get  autoremove</span><br></pre></td></tr></table></figure>
</li>
<li><p>step4: 系统清理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get  clean</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="5-vnc相关的重要命令"><a href="#5-vnc相关的重要命令" class="headerlink" title="5. vnc相关的重要命令"></a>5. vnc相关的重要命令</h2><ol>
<li><p>启动vncserver</p>
<blockquote>
<p>:1是桌面号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver :1</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭vncserver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver -kill :1</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端连接vncserver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip:1</span><br><span class="line">ip:5901</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/u014389734/article/details/79513517" target="_blank" rel="noopener">https://blog.csdn.net/u014389734/article/details/79513517</a><br>[2] <a href="http://dblab.xmu.edu.cn/blog/1998-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/1998-2/</a><br>[3] <a href="https://www.cnblogs.com/chenmingjun/p/8506995.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenmingjun/p/8506995.html</a> <span id="re3">Linux的桌面环境gnome、kde、xfce、lxde 等等使用比较</span></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Linux VNC</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch01</title>
    <url>/2019/09/24/pytorch01/</url>
    <content><![CDATA[<h1 id="PyTorch入门之线性回归"><a href="#PyTorch入门之线性回归" class="headerlink" title="PyTorch入门之线性回归"></a>PyTorch入门之线性回归</h1><p><a href="http://pytorch.org/docs/0.3.0/tensors.html" target="_blank" rel="noopener">torch参考链接</a></p>
<a id="more"></a>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><blockquote>
<ul>
<li>python 3.7</li>
<li>Torch 1.2.0 用于计算</li>
<li>matplotlib 用于画图</li>
</ul>
</blockquote>
<p><strong>踩坑点</strong> <br><br>Torch安装需要用到pip命令，直接在pycharm中会失败 <br><br><strong>去官网获得pip的安装的命令</strong> <a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">Torch官网</a></p>
<h2 id="2-PyTorch基础知识"><a href="#2-PyTorch基础知识" class="headerlink" title="2. PyTorch基础知识"></a>2. PyTorch基础知识</h2><ul>
<li>Tensor是PyTorch的基础数据结构</li>
<li>另一个重要的变量是Variable变量，该变量进行自动微分运算<blockquote>
<p>反向传播算法随时进行<br><br>该变量三个重要的值： 数据（data），父节点（creator），以及梯度（grad）</p>
</blockquote>
</li>
<li>使用之前需要导入两个包</li>
</ul>
<p>创建变量方法如下<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">#导入自动梯度的运算包，主要用Variable这个类</span><br><span class="line">from torch.autograd import Variable</span><br><span class="line"></span><br><span class="line">#创建一个Variable，包裹了一个2*2张量，将需要计算梯度属性置为True</span><br><span class="line">x = Variable(torch.ones(2, 2), requires_grad=True)</span><br></pre></td></tr></table></figure>

<p>x变量如下所示 &emsp;&emsp;<strong>注意</strong> <code>.data</code> 可以返回一个 Variable 所包裹的 Tensor<br><br><img src="/images/pytorch01/t1.png" alt="x变量"></p>
<ul>
<li><code>torch.rand(5, 3)</code>产生[0,1]的均匀分布的随机数值，参数指定形状(一维时第二个参数可不要)</li>
<li><code>torch.randn(100)</code>产生均值为0，方差为1，正态分布随机数值(同样可以指定形状)</li>
<li><code>torch.linspace(start, end, steps=100, out=None) → Tensor</code>线性间隔的数值，返回一个一维张量</li>
<li><code>y.t()</code>完成张量的转置</li>
<li>Tensor可以与numpy.ndarray进行转换<blockquote>
<p>ndarray转换为Tensor<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.ones([5, 3]) #建立一个5*3全是1的二维数组（矩阵）</span><br><span class="line">b = torch.from_numpy(a) #利用from_numpy将其转换为tensor</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>Tensor转换为ndarry<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c = b.numpy() #b为Tensor</span><br></pre></td></tr></table></figure>

<p> <strong>区别</strong> ：Tesnsor可以在GPU上运算</p>
<ul>
<li>使用backward进行反向传播，计算一些导数信息，可通过<code>.grad</code>获得梯度</li>
</ul>
<h2 id="3-单变量线性回归"><a href="#3-单变量线性回归" class="headerlink" title="3. 单变量线性回归"></a>3. 单变量线性回归</h2><blockquote>
<p>y = ax + b</p>
</blockquote>
<h3 id="3-1-产生数据"><a href="#3-1-产生数据" class="headerlink" title="3.1 产生数据"></a>3.1 产生数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># linspace可以生成0-100之间的均匀的100个数字</span><br><span class="line">x = Variable(torch.linspace(0, 100).type(torch.FloatTensor))</span><br><span class="line"></span><br><span class="line"># 随机生成100个满足标准正态分布的随机数，均值为0，方差为1.</span><br><span class="line"># 将这个数字乘以10，标准方差变为10</span><br><span class="line">rand = Variable(torch.randn(100)) * 10</span><br><span class="line"></span><br><span class="line"># 将x和rand相加，得到伪造的标签数据y。</span><br><span class="line"># 所以(x,y)应能近似地落在y=x这条直线上</span><br><span class="line">y = x + rand</span><br></pre></td></tr></table></figure>

<p>使用画图工具画图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(10,8)) #设定绘制窗口大小为10*8 inch</span><br><span class="line"># 绘制数据，考虑到x和y都是Variable，</span><br><span class="line"># 需要用data获取它们包裹的Tensor，并专成numpy</span><br><span class="line">plt.plot(x.data.numpy(), y.data.numpy(), &apos;o&apos;)</span><br><span class="line">plt.xlabel(&apos;X&apos;) #添加X轴的标注</span><br><span class="line">plt.ylabel(&apos;Y&apos;) #添加Y轴的标注</span><br><span class="line">plt.show() #将图形画在下面</span><br></pre></td></tr></table></figure>

<p>结果如下所示<br><br><img src="/images/pytorch01/t2.png" alt="pic"></p>
<h3 id="3-2-递归下降"><a href="#3-2-递归下降" class="headerlink" title="3.2 递归下降"></a>3.2 递归下降</h3><p>step 1: 初始化参数（随机初始）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建a变量，并随机赋值初始化</span><br><span class="line">a = Variable(torch.rand(1), requires_grad = True)</span><br><span class="line">#创建b变量，并随机赋值初始化</span><br><span class="line">b = Variable(torch.rand(1), requires_grad = True)</span><br></pre></td></tr></table></figure>

<p>step 2: 训练1000次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">learning_rate = 0.0001 #设置学习率</span><br><span class="line">for i in range(1000):</span><br><span class="line">    ### 下面这三行代码非常重要，这部分代码，清空存储在变量a，b中的梯度信息，</span><br><span class="line">    ### 以免在backward的过程中会反复不停地累加</span><br><span class="line">    #如果a和b的梯度都不是空</span><br><span class="line">    if (a.grad is not None) and (b.grad is not None):</span><br><span class="line">        a.grad.data.zero_() #清空a的数值</span><br><span class="line">        b.grad.data.zero_() #清空b的数值</span><br><span class="line">    #计算在当前a、b条件下的模型预测数值</span><br><span class="line">    predictions = a.expand_as(x) * x + b.expand_as(x)</span><br><span class="line">    #通过与标签数据y比较，计算误差</span><br><span class="line">    loss = torch.mean((predictions - y) ** 2)</span><br><span class="line">    print(&apos;loss:&apos;, loss.data.numpy())</span><br><span class="line">    loss.backward() #对损失函数进行梯度反传</span><br><span class="line">    #利用上一步计算中得到的a的梯度信息更新a中的data数值</span><br><span class="line">    a.data.add_(- learning_rate * a.grad.data)</span><br><span class="line">    #利用上一步计算中得到的b的梯度信息更新b中的data数值</span><br><span class="line">    b.data.add_(- learning_rate * b.grad.data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>a.expand_as(x) : 将a升级为同x一样维度的张量</p>
</blockquote>
<p>step 3: 将训练后的结果展示出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x_data = x.data.numpy() # 获得x包裹的数据</span><br><span class="line">plt.figure(figsize = (10, 7)) #设定绘图窗口大小</span><br><span class="line">xplot, = plt.plot(x_data, y.data.numpy(), &apos;o&apos;) # 绘制原始数据</span><br><span class="line">yplot, = plt.plot(x_data, a.data.numpy() * x_data + b.data.numpy())  #绘制拟合数据</span><br><span class="line">plt.xlabel(&apos;X&apos;) #更改坐标轴标注</span><br><span class="line">plt.ylabel(&apos;Y&apos;) #更改坐标轴标注</span><br><span class="line">str1 = str(a.data.numpy()[0]) + &apos;x +&apos; + str(b.data.numpy()[0]) #图例信息</span><br><span class="line">plt.legend([xplot, yplot],[&apos;Data&apos;, str1]) #绘制图例</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>以下是拟合结果<br><br><img src="/images/pytorch01/t3.png" alt="pic"></p>
<h2 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h2><pre><code>x_test = Variable(torch.FloatTensor([1, 2, 10, 100, 1000])) #随便选择一些点1，2，……，1000
predictions = a.expand_as(x_test) * x_test + b.expand_as(x_test) #计算模型的预测结果
print(predictions) #输出</code></pre><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/oneCoderMan/myCodes/blob/master/PyTorch/linearRegression.py" target="_blank" rel="noopener">完整代码</a></p>
<p>source: <a href="https://www.shiyanlou.com/courses/1073/learning/?id=5821" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/1073/learning/?id=5821</a></p>
]]></content>
      <categories>
        <category>deepLearing</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>shell-auto</title>
    <url>/2019/09/11/shell-auto/</url>
    <content><![CDATA[<h1 id="shell脚本实现Linux系统监控"><a href="#shell脚本实现Linux系统监控" class="headerlink" title="shell脚本实现Linux系统监控"></a>shell脚本实现Linux系统监控</h1><hr>
<p>代码见 <a href="https://github.com/oneCoderMan/myCodes/blob/master/shell/auto.sh" target="_blank" rel="noopener">https://github.com/oneCoderMan/myCodes/blob/master/shell/auto.sh</a></p>
<hr>
<a id="more"></a>

<h2 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一. 预备知识"></a>一. 预备知识</h2><h3 id="1-1-getopts"><a href="#1-1-getopts" class="headerlink" title="1.1 getopts"></a>1.1 getopts</h3><blockquote>
<p>作用: 处理参数复杂的命令行选项和参数<br><br>格式：getopts option_string args<br><br>说明： option_string中是参数列表， args从命令行中接受的值</p>
</blockquote>
<p>示例代码：option.sh<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">while getopts f:e:p: option</span><br><span class="line">do</span><br><span class="line">   case &quot;$&#123;option&#125;&quot; in</span><br><span class="line">       f) file_name=$&#123;OPTARG&#125;;;</span><br><span class="line">       e) editor=$&#123;OPTARG&#125;;;</span><br><span class="line">       p) page=$&#123;OPTARG&#125;;;</span><br><span class="line">       *) echo &quot;invalid&quot;;;</span><br><span class="line">   esac</span><br><span class="line">done</span><br><span class="line">echo &quot;$&#123;file_name&#125;&quot;</span><br><span class="line">echo &quot;$&#123;editor&#125;&quot;</span><br><span class="line">echo $&#123;page&#125;</span><br></pre></td></tr></table></figure>

<p>运行命令：<code>./option.sh -f bool.pdf -e YiJun -p HUANAN</code> <br><br>option_string是匹配的参数,字符后面有：表示该命令中必须加上参数，如-e yijun。否则会出现错误。参数的值会保存在<strong>OPTARG</strong>变量中。<br></p>
<blockquote>
<p>检测到非法参数就会停止</p>
</blockquote>
<h3 id="1-2-sign各含义"><a href="#1-2-sign各含义" class="headerlink" title="1.2 $+sign各含义"></a>1.2 $+sign各含义</h3><blockquote>
<ol>
<li><strong>$#</strong>   :Stores the number of command-line arguments that<br>   were passed to the shell program.<br></li>
<li><strong>$?</strong>    :Stores the exit value of the last command that was<br>   executed.<br></li>
<li><strong>$0</strong>   :Stores the first word of the entered command (the<br>   name of the shell program).<br></li>
<li><strong>$*</strong>   :Stores all the arguments that were entered on the<br>   command line ($1 $2 …).<br></li>
<li><strong>$@</strong>  :Stores all the arguments that were entered<br>   on the command line, individually quoted (“$1” “$2” …). <br></li>
<li><strong>$&gt;</strong> : 1&gt;是标准输出重定向， 可以省去1(变为 &gt; )； 2&gt;错误重定向。$&gt;是两种的结合，标准与错误重定向<br></li>
<li><strong>&gt;$1</strong> : 将重定向到1管道， 即定向到标准输出</li>
</ol>
</blockquote>
<p>如下例子：<br><br><code>./command -yes -no /home/username</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$# = 3</span><br><span class="line">$* = -yes -no /home/username</span><br><span class="line">$@ = array: &#123;&quot;-yes&quot;, &quot;-no&quot;, &quot;/home/username&quot;&#125;</span><br><span class="line">$0 = ./command, $1 = -yes etc.</span><br></pre></td></tr></table></figure>

<h3 id="1-3-tput与颜色转义"><a href="#1-3-tput与颜色转义" class="headerlink" title="1.3 tput与颜色转义"></a>1.3 tput与颜色转义</h3><p><a href="https://www.cnblogs.com/technologylife/p/8275044.html" target="_blank" rel="noopener">参考链接</a></p>
<blockquote>
<p><strong>tput作用</strong>：更改终端功能<br></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tput sgr0       # 恢复默认终端</span><br><span class="line">tput blink      # 文本闪烁</span><br></pre></td></tr></table></figure>

<p>一个例子1-3：<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tecreset=$(tput sgr0)</span><br><span class="line">echo -e &apos;\E[32m&apos;&quot;Operating System Type :&quot; $tecreset $os</span><br></pre></td></tr></table></figure>

<p>结果：<br><br><img src="/assets/shell/p1.png" alt="结果"></p>
<blockquote>
<p><strong>说明:</strong> <br></p>
<ol>
<li>如果把1-3中的$tecreset去掉，都会是绿色。<br></li>
<li>方便操作，不用每次都使用命令替换$(), ``， 因此用一个变量tecreset存储命令。</li>
</ol>
</blockquote>
<p><strong>linux终端的颜色由转义序列控制<br></strong></p>
<blockquote>
<p>转义序列由控制符 <code>esc</code>开头，控制序列引导符为：<code>\033</code>或者<code>\e[</code>，m为转义结束。<br></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式1：\033[ Param &#123;;Param;...&#125; m</span><br><span class="line"></span><br><span class="line">格式2：\e[ Param &#123;;Param;...&#125;m</span><br></pre></td></tr></table></figure>

<p>例子1-3   <a href="http://c.biancheng.net/linux/echo.html" target="_blank" rel="noopener">参考资料</a>  <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;\033[颜色1;颜色2m 要展示的文字 \033[0m&quot;</span><br><span class="line">\033[0m：表示将颜色恢复回原来的颜色</span><br></pre></td></tr></table></figure>

<h3 id="1-4-各种括号"><a href="#1-4-各种括号" class="headerlink" title="1.4 各种括号"></a>1.4 各种括号</h3><p><a href="https://blog.csdn.net/x1269778817/article/details/46535729" target="_blank" rel="noopener">参考文献</a></p>
<ul>
<li>$()与``<blockquote>
<p>用来做命令替换的，简化shell脚本的编写</p>
</blockquote>
</li>
<li>${}<blockquote>
<p>变量替换的，即变量引用</p>
</blockquote>
</li>
<li>$[]与 $(())<blockquote>
<p>都是用来做数学运算的<br><br><strong>注意</strong> : $(())中的变量前面可以加$,也可不用</p>
</blockquote>
</li>
<li>[]<blockquote>
<p>test命令的一种形式 左右需留空格，即判断true或者false</p>
</blockquote>
</li>
<li>(())与[[]]<blockquote>
<p>分别是数学表达式和字符表达式[]的加强版</p>
</blockquote>
<h2 id="二-监控系统脚本各模块"><a href="#二-监控系统脚本各模块" class="headerlink" title="二.监控系统脚本各模块"></a>二.监控系统脚本各模块</h2><h3 id="2-1-脚本安装-i"><a href="#2-1-脚本安装-i" class="headerlink" title="2.1 脚本安装 -i"></a>2.1 脚本安装 -i</h3>代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [[ $iopt -eq 1 ]]; then   #对变量的引用要加上$  then如果是同一行的话要加上;</span><br><span class="line">  &#123;</span><br><span class="line">    #获得它的路径</span><br><span class="line">    wd=`pwd`</span><br><span class="line">    #获得它的文件名</span><br><span class="line">    basename `echo $0` &gt; /tmp/script</span><br><span class="line">    #拼接</span><br><span class="line">    scriptname=`echo -e -n $wd/ &amp;&amp; cat /tmp/script`</span><br><span class="line">    # 加载到环境变量中去</span><br><span class="line">    su -c &quot;cp $scriptname /usr/bin/monitor&quot; root &amp;&amp; echo &quot;congratulations! install successful!&quot; || echo &quot;install failed!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>代码说明</strong><br></p>
<ol>
<li>``(反引号)是执行shell命令，可将结果保存在变量中。同$(),这个有些shell不支持。<br></li>
<li>basename 命令是将前缀和最后的/删除，保留最后一个字符串显示出来<br></li>
<li>$0 是指shell本生的文件名，<code>sh test.sh</code>得到 test.sh。<code>./test.sh</code> 得到的是./test.sh <br></li>
<li>echo中的-e 用来打印转义符， -n不换行打印<br></li>
<li>su -c command USER 切换用户USER执行命令command，执行完之后返回原用户<br></li>
<li>||  &amp;&amp; 在命令组合中具有短路左右，可以看成if else结构<br></li>
<li>[[ ]] (())这个是进行数学表达式和字符表达式运算的加强版。推荐使用 ,<strong>左右需留空格</strong><br></li>
<li>-eq 是数字等于判断， 对于字符串等于使用=</li>
</ol>
</blockquote>
<h3 id="2-2-关于模块-v"><a href="#2-2-关于模块-v" class="headerlink" title="2.2 关于模块 -v"></a>2.2 关于模块 -v</h3><p>代码如下:<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [[ $vopt -eq 1]]</span><br><span class="line">then</span><br><span class="line">  &#123;</span><br><span class="line">    echo -e &quot;monitor version 1\nreleased Under ....&quot;</span><br><span class="line">  &#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="2-3-帮助模块-h"><a href="#2-3-帮助模块-h" class="headerlink" title="2.3 帮助模块 -h"></a>2.3 帮助模块 -h</h3><p>代码如下： <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [[ $hopt -eq 1 ]]</span><br><span class="line">then</span><br><span class="line">  &#123;</span><br><span class="line">    echo -e &quot;  -i\tinstall the scripts &quot;</span><br><span class="line">    echo -e &quot;  -v\tprint version &quot;</span><br><span class="line">    echo -e &quot; -h\t print help info&quot;</span><br><span class="line">  &#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="2-4-查看操作系统类型"><a href="#2-4-查看操作系统类型" class="headerlink" title="2.4 查看操作系统类型"></a>2.4 查看操作系统类型</h3><blockquote>
<p><strong>注意</strong> ：不同操作系统对应的代码不一样啊， 本文中只讨论centOS系统.不同版本的代码见附录1</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看系统版本和名称</span><br><span class="line">OS=`uname -s`</span><br><span class="line">REV=`uname -r`</span><br><span class="line">MACH=`uname -m`</span><br><span class="line"></span><br><span class="line">#查看操作系统类型，这里适用于redHat</span><br><span class="line">if [[ $&#123;OS&#125; = &quot;Linux&quot; ]]; then</span><br><span class="line">&#123;</span><br><span class="line">  KERNEL=`uname -r`  #内核发布版本</span><br><span class="line">  if [ -f /etc/redhat-release ]; then  # test -f filename, 测试是否为普通文件</span><br><span class="line">  &#123;</span><br><span class="line">    DIST=&quot;RedHat&quot;</span><br><span class="line">    Psuedoname=`cat /etc/redhat-release | sed s/.*\(// | sed s/\)//`</span><br><span class="line">    REV=`cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//`</span><br><span class="line">  &#125;</span><br><span class="line">  fi</span><br><span class="line">  OSSTR=&quot;$&#123;OS&#125; $&#123;DIST&#125; $&#123;REV&#125;($&#123;Psuedoname&#125; $&#123;KERNEL&#125; $&#123;MACH&#125;)&quot;</span><br><span class="line">&#125;</span><br><span class="line">fi</span><br><span class="line">echo $&#123;OSSTR&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<blockquote>
<ol>
<li>uname是查看系统版本的命令 <br></li>
<li><code>[ -f /etc/redhat-release ]</code> 文件测试指令<br></li>
<li>可以查看 <a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">http://coolshell.cn/articles/9104.html</a> 获取sed帮助</li>
</ol>
</blockquote>
<h3 id="2-5-监控系统的各种信息"><a href="#2-5-监控系统的各种信息" class="headerlink" title="2.5 监控系统的各种信息"></a>2.5 监控系统的各种信息</h3><ul>
<li>查看DNS<br><br><code>cat /etc/resolv.conf | sed &#39;1d&#39; | awk &#39;{print $2}&#39;</code><blockquote>
<p><strong>解释说明</strong> <br><br>读取配置文件，删除第一行， 打印第二个字段</p>
</blockquote>
</li>
<li>查看系统负载<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadverage=$(top -n 1 -b | grep &quot;load average:&quot; | awk &apos;&#123;print $10 $11 $12&#125;&apos;)</span><br><span class="line">echo -e &quot;\E[32m load average: \E[0m &quot;$&#123;loadverage&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>说明</strong> <br><br>top -n 1 只迭代一次，不会动态刷新， top -n 1 -b 示非动态打印系统资源使用情况</p>
<ul>
<li>查看系统运行时间</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tecuptime=$(uptime | awk &apos;&#123;print $3,$4&#125;&apos; | cut -f1 -d&apos;,&apos;)</span><br><span class="line">echo -e &quot;\E[32m System Uptime Days: \E[0m &quot;$&#123;loadverage&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong> <br><br>cut -f1 -d’,’:   -f1选定第一列， -d&#39;* &#39; 表示用*分割</p>
</blockquote>
<p>来源：<a href="https://superuser.com/questions/247127/what-is-and-in-linux" target="_blank" rel="noopener">https://superuser.com/questions/247127/what-is-and-in-linux</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="附录1：-不同操作系统查看操作系统类型"><a href="#附录1：-不同操作系统查看操作系统类型" class="headerlink" title="附录1： 不同操作系统查看操作系统类型"></a>附录1： 不同操作系统查看操作系统类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ &quot;$&#123;OS&#125;&quot; = &quot;SunOS&quot; ] ; then</span><br><span class="line">    OS=Solaris</span><br><span class="line">    ARCH=`uname -p`</span><br><span class="line">    OSSTR=&quot;$&#123;OS&#125; $&#123;REV&#125;($&#123;ARCH&#125; `uname -v`)&quot;</span><br><span class="line"># uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</span><br><span class="line">elif [ &quot;$&#123;OS&#125;&quot; = &quot;AIX&quot; ] ; then</span><br><span class="line">    OSSTR=&quot;$&#123;OS&#125; `oslevel` (`oslevel -r`)&quot;</span><br><span class="line">#AIX是IBM开发的一套类UNIX操作系统，关于它更多的指令可以查看http://www.cnblogs.com/sbaicl/articles/2947795.html</span><br><span class="line">elif [ &quot;$&#123;OS&#125;&quot; = &quot;Linux&quot; ] ; then</span><br><span class="line">    KERNEL=`uname -r`</span><br><span class="line">    if [ -f /etc/redhat-release ] ; then</span><br><span class="line">        DIST=&apos;RedHat&apos;</span><br><span class="line">        PSUEDONAME=`cat /etc/redhat-release | sed s/.*\(// | sed s/\)//`</span><br><span class="line">        REV=`cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//`</span><br><span class="line">#sed通常用来匹配一个或多个正则表达式的文本进行处理,可以查看http://coolshell.cn/articles/9104.html</span><br><span class="line">    elif [ -f /etc/SuSE-release ] ; then</span><br><span class="line">        DIST=`cat /etc/SuSE-release | tr &quot;\n&quot; &apos; &apos;| sed s/VERSION.*//`</span><br><span class="line">        REV=`cat /etc/SuSE-release | tr &quot;\n&quot; &apos; &apos; | sed s/.*=\ //`</span><br><span class="line">    elif [ -f /etc/mandrake-release ] ; then</span><br><span class="line">        DIST=&apos;Mandrake&apos;</span><br><span class="line">        PSUEDONAME=`cat /etc/mandrake-release | sed s/.*\(// | sed s/\)//`</span><br><span class="line">        REV=`cat /etc/mandrake-release | sed s/.*release\ // | sed s/\ .*//`</span><br><span class="line">    elif [ -f /etc/debian_version ] ; then</span><br><span class="line">        DIST=&quot;Debian `cat /etc/debian_version`&quot;</span><br><span class="line">        REV=&quot;&quot;</span><br><span class="line"></span><br><span class="line">    fi</span><br><span class="line">    if $&#123;OSSTR&#125; [ -f /etc/UnitedLinux-release ] ; then</span><br><span class="line">        DIST=&quot;$&#123;DIST&#125;[`cat /etc/UnitedLinux-release | tr &quot;\n&quot; &apos; &apos; | sed s/VERSION.*//`]&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    OSSTR=&quot;$&#123;OS&#125; $&#123;DIST&#125; $&#123;REV&#125;($&#123;PSUEDONAME&#125; $&#123;KERNEL&#125; $&#123;MACH&#125;)&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux Shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
</search>
