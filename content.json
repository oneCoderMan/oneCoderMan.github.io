{"meta":{"title":"CoderSim's Growth Diary","subtitle":"extoll the world's best C and Java","description":null,"author":"CoderSim","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-10-05T12:25:06.172Z","updated":"2019-10-05T12:25:06.172Z","comments":true,"path":"README.html","permalink":"http://yoursite.com/README.html","excerpt":"","text":"我的学习笔记说明标签类tages Linux VNC PyTorch shell 线性回归分类categories Linux Shell deepLearing tool(一些工具软件，环境搭建的学习笔记)"},{"title":"about","date":"2019-09-23T12:26:08.000Z","updated":"2019-09-23T12:27:19.023Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"V1.0created By CoderSim"},{"title":"categories ALL Log","date":"2019-09-23T12:23:34.000Z","updated":"2019-09-23T12:36:08.287Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"TagCloud","date":"2019-09-23T12:17:17.000Z","updated":"2019-09-23T12:19:27.634Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"docker-IDAPro","slug":"docker-IDAPro","date":"2019-10-30T01:43:57.000Z","updated":"2019-10-30T03:19:34.138Z","comments":true,"path":"2019/10/30/docker-IDAPro/","link":"","permalink":"http://yoursite.com/2019/10/30/docker-IDAPro/","excerpt":"docker与IDAPRO搭建二进制漏洞环境","text":"docker与IDAPRO搭建二进制漏洞环境 1. docker安装与基本操作1.1 安装官网runoob安装教程 1.2 基本操作导入镜像(别人已经准备好的)1cat ubuntu.17.04.amd64 | docker import - ubuntu/17.04.amd64(可自己命名) ubuntu.17.04.amd64是一个本地的镜像文件，后面一个名字可以自己定义 查看镜像导入成功后，可以使用命令查看docker所有的已经导入的镜像 1docker images 运行容器可以看作是启动一个任务docker run命令 123docker run -it -p 23946:23946 ubuntu/17.04.amd64 /bin/bash#或者docker run -i -t -p 23946:23946 ubuntu/17.04.amd64 /bin/bash -i 允许对容器内的标准输入-t 在新的容器内指定一个伪终端或者终端-p 容器内部使用的网络端口映射到使用的主机上面，后面一个是本地主机端口ubuntu/17.04.amd64 这是镜像名字/bin/bash 运行的命令 查看docker运行的所有容器在运行的主机上打开一个新的shell 1docker ps #查看所有正在运行的容器 1docker container ls -a #查看所有的容器情况 拓展：可以修改容器的名字docker container rename [autoname] [yourname]docker start id/name 启动容器 在已经运行的镜像或者容器内打开一个新的bash shell有时候一个容器的shell阻塞了，我们需要新的bash shell，可以使用如下的命令 123docker exec -it ubuntu17.04 /bin/bash#或者 containerID是一个id号docker exec -it containerID /bin/bash 容器和主机之间的文件传送可以使用如下命令在容器和主机之间双向传送文件 1docker container cp [localhostFilePath] [imageName]:[filePath] eg: docker container cp linux_server ubuntu.17.04.i386:/root/linux_server 退出容器此时拥有shell，使用命令exit或者键盘ctrl+D如果没有shell，先docker ps得到容器id或者name，然后使用docker stop id/name结束容器 删除容器1docker rm id/name 2. IDAPro简单使用在远程连接时候，需要关闭docke远程执行命令保护 1docker run --security-opt seccomp:unconfined -it -p 23945:23946 ubuntu.17.04.i386 /bin/bash 将IDA所在文件夹下的dbgsrv的linux_server或则linux_server64复制到主机上，并使用docker container cp命令传送到容器的某一个路径下。加权限然后运行，可以看到侦听端口，新打开一个bash shell。 快捷键功能 F2设置断点/取消断点 F7单步进入函数 F8单步跨过函数 F9运行程序","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"IDAPro","slug":"IDAPro","permalink":"http://yoursite.com/tags/IDAPro/"}]},{"title":"languageEnvConf","slug":"languageEnvConf","date":"2019-10-28T13:51:16.000Z","updated":"2019-10-29T13:30:21.916Z","comments":true,"path":"2019/10/28/languageEnvConf/","link":"","permalink":"http://yoursite.com/2019/10/28/languageEnvConf/","excerpt":"语言环境的安装和配置","text":"语言环境的安装和配置 ubuntu16.04下的python3.7安装 ubuntu16.04默认安装有python3.5和python2.7安装路径在/usr/local/lib下 可以通过如下命令查看python的指向 1ll /usr/bin | grep python 可以知道python的默认指向时python2.7 step1： 下载python3.7 1wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz step2: 解压安装包 1tar -zxvf Pyhon-3.7.1.tgz step3: 编译安装 1234cd Python-3.7.1./configure --prefix=/usr/local/python3.7.1makemake install 经过上面步骤有 文件路径 可执行文件/usr/local/python3.7.1/bin 库文件/usr/local/python3.7/lib 配置文件/usr/local/python3.7/share step4：配置环境变量 123456#查看环境变量echo $PATHvim ~/bashrc#添加如下的语句PATH=$PATH:$HOME/bin:/usr/local/python3.7.1/binsource ~/bashrc step5: 测试：输入python3.7可进入python解释器即可python -V查看版本。或者 123import sysprint(sys.version)print(sys.version_info) zlib模块缺失的解决方法：官网下载zlibwget http://zlib.net/zlib-1.2.11.tar.gz，可以查看最新版本然后解压，配置，安装tar -xvf zlib-1.2.11.tar.gzcd zlib-1.2.11./configuremakemake install最后重新编译安装python3.7 No module named ‘_ctypes’解决方案sudo apt-get install libffi-dev最后重新编译安装python3.7 step6: 修改系统默认指向12345678删除原有链接备份mv /usr/bin/python /usr/bin/python.bak建立新的链接ln -s /usr/local/python3.7.1/bin/python3.7 /usr/bin/python修改pipmv /usr/bin/pip /usr/bin/pip.bak建立新的pipln -s /usr/local/python3.7.1/bin/pip3 /usr/bin/pip 参考文献[1] https://blog.csdn.net/u014775723/article/details/85213793","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"语言环境安装配置","slug":"语言环境安装配置","permalink":"http://yoursite.com/tags/语言环境安装配置/"}]},{"title":"IISFTP","slug":"IISFTP","date":"2019-10-24T08:21:00.000Z","updated":"2019-10-24T09:00:54.000Z","comments":true,"path":"2019/10/24/IISFTP/","link":"","permalink":"http://yoursite.com/2019/10/24/IISFTP/","excerpt":"win10搭建ftp服务实践win10下面用自带的iis搭建ftp服务用于文件传输","text":"win10搭建ftp服务实践win10下面用自带的iis搭建ftp服务用于文件传输 1.开启IIS服务 2.使用搜索功能打开IIS，添加ftp站点经过上面的步骤在本机上是可以访问到文件的，在局域网或者其它网络的机器是无法访问的。接下来继续配置。 1ftp://ip 3.配置防火墙一个简单的方法是关闭防火墙，这里配置其他方法不用关闭防火墙。 3.1 放行21端口点击高级设置入站规则-&gt; 新建规则选择端口，下一步然后一直下一步。 3.2 设置ftp允许通过防火墙然后点击允许其他应用大功告成。","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"字符串格式化漏洞","slug":"字符串格式化漏洞","permalink":"http://yoursite.com/tags/字符串格式化漏洞/"}]},{"title":"gccAndgdb","slug":"gccAndgdb","date":"2019-10-09T06:12:03.000Z","updated":"2019-10-22T03:35:01.543Z","comments":true,"path":"2019/10/09/gccAndgdb/","link":"","permalink":"http://yoursite.com/2019/10/09/gccAndgdb/","excerpt":"linux下的c编程工具的使用","text":"linux下的c编程工具的使用 test.c的代码如下: 12345#include&lt;stdio.h&gt;main()&#123; printf(&quot;Hello, World\\n&quot;);&#125; 1.gcc工具的使用 不带任何参数1gcc test.c 会在同一个目录下面生成一个a.out文件，输入命令./a.out就可直接运行。 直接经历了四个步骤：预处理Preprocessing，编译Compilation，汇编Assembly，链接Linking。 指定生成的文件名1gcc test.c -o test 不会使用默认的a.out。 gcc保留中间文件gcc编译过程中，会删除中间的文件，可通过下面命令参数来保留各个阶段的文件 1gcc -save_temps test.c gcc生成调试信息 1gcc -g test.c -o test gcc编译生成32bit代码 1gcc -m32 hello.c -o hello 如果-m32无法运行，请安装下载相关包 12sudo apt-get install build-essential module-assistant sudo apt-get install gcc-multilib g++-multilib gcc版本信息查看1gcc -v 2.gcc的各个阶段分析2.1 预处理1gcc -E test.c -o test.i 功能：主要处理源代码中以 “#” 开始的预编译指令生成文件：test.i指定参数: -E 2.2 编译123gcc -S test.c -o test.s#或者gcc -S test.i -o test.s 输入的文件可以是源文件，也可以是预处理后的文件功能：对预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件生成文件：test.s指定参数：-S 2.3 汇编123gcc -c test.c -o test.o#或者gcc -c test.s -o test.o 输入的文件可以是源文件，也可以是编译后的文件功能：汇编器将汇编代码转变成机器可以执行的指令生成文件：test.o(不能直接执行)指定参数：-c objdump：一种可阅读的格式让你更多地了解二进制文件（反汇编） objdump -sd hello.o可查看test.o的信息 2.4 链接1gcc test.o -o test 输入文件可以是源文件也可以是汇编后的文件指定参数：无生成文件：test(可以执行)目标文件需要链接一大堆文件才能得到最终的可执行文件通过以下命令可查看反汇编代码 1objdump -d -j .text text 3.gdb的使用测试程序如下test.c: 1234567#include &lt;stdio.h&gt;int main()&#123; int a = 1; int b = a; printf(&quot;a = %d, b =%d\\n&quot;, a, b); return 0;&#125; GDB主要帮助你完成下面四个方面的功能： 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 可让被调试的程序在你所指定的调置的断点处停住。 当程序被停住时，可以检查此时你的程序中所发生的事。 你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。3.1 gbd调试程序的简易入门操作 安装 1sudo apt install gdb 启动调试 1234#编译文件，加上调试信息。不加参数-g可能无法调试gcc -g test.c -o test#开始启动调试gdb test 拓展: 启动调试的时候输入gdb -tui test会有一个漂亮的交互窗口 调试的操作 注意* :括号内的东西不用输入 显示当前的代码，一次10行，继续输入l继续显示。 1(gdb) l 单步 1(gdb) start 这个时候会进入程序运行状态，单步运行需要输入n，输入一次执行一条语句。s单步会进入子程序中去。 断点+单步启动的时候start程序会在第一行停止。这个时候可以设置断点，如下所示：123(gdb) b 5(gdb) c #运行程序到断点处，一般在设置完断点后使用(gdb) r #重新运行程序 run 表示在第5行设置断点，输入命令c会直接运行到第5行；其中b后面的参数也可以是一个函数名。可以按照单步的方法继续运行。可以同时设置多个断点 1(gdb) display b 这个display 可以查看变量的值 查看所有断点和删除查看已经设置的断点123(gdb) info breakpoints#可以简写成(gdb) i b 注意到每一个断点有编号，使用编号可删除断点 1(gdb) delete 2 设置条件断点 1(gdb) b 5 if a == 2 观察变量改变的地方 12(gdb) watch b(gdb) c 变量内存值被修改的时候会展示出来 反汇编命令123(gdb) disassemble main#可简写成(gdb) disas main 其中的main是一个函数名称。 3.2 gdb插件—gdb-pedaPEDA(Python Exploit Development Assistance for GDB)是一个强大的 gdb 插件。它提供了高亮显示反汇编代码、寄存器、内存信息等人性化的功能。同时，PEDA 还有一些实用的新命令，比如checksec 可以查看程序开启了哪些安全机制等等。 安装12$ git clone https://github.com/longld/peda.git ~/peda$ echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit 4. Linux代码执行漏洞分析实战主要工作：出发一个NoIP本地运行的栈溢出漏洞，用gdb调试工具找出漏洞发生的地点。 4.1 准备NoIP本地栈溢出漏洞 step1 注册NO-IP账号 12https://my.noip.com/#!/accounthttps://www.noip.com step2 在Linux下安装No-ip官网 123456cd /usr/local/srcwget http://www.no-ip.com/client/linux/noip-duc-linux.tar.gztar xzf noip-duc-linux.tar.gzcd no-ip-2.1.9makemake install 由PoC出发漏洞 12gdb noip2run -i $(python -c &apos;print (&quot;\\x41&quot;*500)&apos;) 如果没有触发漏洞，将数值可以加大为1000，直到有漏洞触发 图1 使用静态反汇编工具idaProwin系统下远程连接linux编译文件调试参考文献1 4.2实验过程由图1可知，漏洞发生之前，打印输出了字符串IP address detected on command line.我们先定位到这个字符串输出的位置。 step1: IDAPro远程连接到Noip程序打开搜索框，输入上面的那个字符串进行搜索。 可以看到这里有一个mov操作，之后调用了call Msg。 因此我们在这个地点下一个断点，红色框框对应的地址()。 step2: 切换回linux，设置断点退出之前的gdb, quit重新进入gdb noip2通过第一步得到的地址设置断点1b *0x00000000004021AB 可观察到在源码中对应的行数为line 607 step3: 执行得到漏洞的命令1run -i $(python -c &apos;print (&quot;\\x41&quot;*1000)&apos;) 可以看到在0x4021ab处发生了中断，即我们设置的断点的地方。 step4: 单步执行123ni#或者n 在这个过程中，可以看到运行到了call Msg，并且打印出了字符串继续单步执行，可以看到输出另一串Running in single use mode.如果之前进行了push操作，可以使用命令这可以查看栈顶的的值 123456(gdb) x/10x $esp# 查看内存的值(gdb) x/10x 0x4083b5(视情况)(gdb) x/100x 0x4083b5# 也可以以字符串形式输出内存的值(gdb) x/10s 0x4083b5 step5 继续单步，一直到出现漏洞 可以发现，当程序调用dynamic_update的前中后出现了问题。有可能是在这个函数里面出现问题，也有可能是该函数嵌套的函数出现了问题。得到调用dynamic_update函数的地址为：0x40233c step6: 重新设置断点切换回IDAPro，以此选择jump-&gt;jump address输入上面得到的函数地址。切换到graph view按住F5可查看c伪代码。找到调用dynamic_update函数之前的一个地址0x402337，重新设置断点 12(gdb) b *0x0x402337(gdb) run -i $(python -c &apos;print (&quot;\\x41&quot;*1000)&apos;) step7 进入到函数内部这里使用si或者s进行单步。进入到dynamic_update函数后，使用n来单步，确定程序崩溃的地方。 [1] https://blog.csdn.net/lacoucou/article/details/71079552 windows下使用IDA远程调试linux(ubuntu)下编译的程序","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"gcc","slug":"gcc","permalink":"http://yoursite.com/tags/gcc/"}]},{"title":"balanceLvs","slug":"balanceLvs","date":"2019-10-08T00:52:44.000Z","updated":"2019-10-08T13:40:13.634Z","comments":true,"path":"2019/10/08/balanceLvs/","link":"","permalink":"http://yoursite.com/2019/10/08/balanceLvs/","excerpt":"负载均衡之lvs官方文档","text":"负载均衡之lvs官方文档 1.基础知识1.1 linux命令 route 查看本机的路由表 -n 不带地址转换，IP显示route -n netstat -natp 查看本机的TCP链接程序 -n 不进行转换，全以IP地址显示-a 是所有的链接-t tcp链接 arp -a查看MAC地址表 1.2 一些名称 全称 缩写 描述 虚拟IP地址Virtual IP address VIP 提供服务的IP地址,如www.baidu.com通过DNS得到的地址 转发的网络地址Director IP address DIP 负载均衡器上面的IP 真实IP地址Real IP address RIP 后端集群主机 客户端地址IP Client IP address CIP 源IP地址 lvs负载均衡的拓扑结构 说明 负载均衡器工作在网络层，只转发数据包，不进行握手连接 要保证同一个客户端三次握手，四次分手不可分割，即转发到同一个服务器镜像 后端的真实服务器都是镜像，一模一样的。 1.3 模型概述1.3.1 D_NAT与S_NAT客户端请求的数据包源地址和目的地址CIP-VIP当其到达负载均衡器入口时，如果不对该数据包做处理就转发，那么RealServer看到的目的IP地址就是VIP，不属于RealServer的IP,不会做出回应。因此在负载均衡器中需要对数据包中的目的地址进行转换修改目的地址(D_NAT技术)，数据包变为CIP-RIP,这个时候RealServer可处理该数据包 问题 此时RealServer建立的Sockt连接是：RIP:Port---CIP:Port,所以响应包的源地址和目的地址是：RIP-CIP。当这个数据包达到客户端的时候，与客户端发的请求包中的地址不对应了？ 因此，负载均衡器还需要负责将响应包的源地址修改为VIP(S_NAT技术)。为了实现这个，RealServer的默认网关(default/0.0.0.0)需要指向LVS负载均衡器。 缺点：所有数据(上行，下行)都要经过LVS，I/O瓶颈在这里会产生。可行方案： 每一个RealServer不要将响应数据发给LVS,直接将响应包发给客户端。 1.3.2 DR模型 让RealServer拥有一个VIP这样的IP地址，但是不暴露在公网，自己有一个隐藏的VIP地址 客户端发送CIP-VIP数据包，经过LVS到达RealServer,因为RealServre有一个隐藏的VIP地址，所以会接收该数据包，然后将响应包VIP-CIP直接发送给客户端，不用通过lvs负载均衡器。 问题： 客户端的数据包是CIP-VIP，RealServer暴露的IP是RIP，lvs如何将客户端数据包发给RealServer。 解答： 通过arp欺骗。lvs与RealServer必须在同一个局域网内 缺点 :要求lvs与RealServer在同一个局域网内，对分布在地理位置不同的数据中心无法做负载均衡。 1.3.3 Tunnel与VPN模型客户端发出数据包CIP-VIP。数据包到达lvs的时候，建立一个新的请求，发送数据包DIP-RIP,这个数据包会将客户端的所有数据都封装起来。然后通过公网到RealServer。RealServer会拆包，得到里面的CIP-VIP请求。自己有隐藏的VIP地址。 1.4 linux隐藏IP的方法对内可见，对外隐藏。需要隐藏的IP配置到外部无法访问的网卡上就是lo网卡，环回接口注意：一个网卡可以添加多个IP地址，所以环回地址127.0.0.1不受影响。 基础知识：在一个局域网内，如果主机A的arp表中无主机B的mac地址且要发送数据包到主机B，就会进行arp请求。这个时候主机B会发送响应请求，告诉主机A它的IP和对应的MAC地址。 配置文件：/proc/sys/net/ipv4/conf/ 对于arp_ignore控制系统在收到外部的arp请求时，是否要返回arp响应,配置为1 arp_ignore为0：回应任何网络接口（网卡）上对任何本机IP地址的arp查询请求为1：只回答目标IP地址是本机上来访网络接口（网卡）IP地址的ARP查询请求 。比如eth0=192.168.0.1/24,eth1=10.1.1.1/24,那么即使eth0收到来自10.1.1.2这样地址发起的对192.168.0.1的查询会回应，而对10.1.1.1 的arp查询不会回应。 arp_announce定义将自己地址向外通告时的通告级别，配置为2 0：将本地任何接口上的任何地址向外通告；1：试图仅向目标网络通告与其网络匹配的地址；2：仅向与本地接口上地址匹配的网络进行通告 2. DR实验2.1 lvs简介lvs： Linux Virtual Server，linux虚拟服务器。核心程序：ipvs（嵌入到了Linux内核中）管理程序：ipvsadm调度算法： 调度方式英文描述 静态调度轮询调度Round Robin 简称'RR'依次循环的方式将请求调度到不同的服务器上 加权轮询调度Weight Round Robin 简称'WRR'权值越高的服务器，处理的请求越多 目标地址散列调度Destination Hashing 简称'DH'算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空 源地址散列调度Source Hashing 简称'SH'先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。 动态调度最小连接调度Least Connections 简称'LC'新的连接请求分配到当前连接数最小的服务器 加权最小连接调度Weight Least Connections 简称'WLC'加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值 最短的期望的延迟Shortest Expected Delay 简称'SED'请求交给得出运算结果最小的服务器 最少队列调度Never Queue 简称'NQ'无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。 带复制的基于局部性的最少连接Locality-Based Least Connections with Replication 简称'LBLCR'按'最小连接'原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按'最小连接'原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。 基于局部的最少连接Locality-Based Least Connections 简称'LBLC'LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用'最少连接'的原则选出一个可用的服务器，将请求发送到服务器。 2.2 ipvsadm的使用配置主要分为两个阶段，第一配置哪些数据包需要进行转发，第二配置数据包转发到哪里去。 安装管理模块 1centOS: yum install ipvsadm -y 配置哪些数据包需要lvs转发 1234格式： ipvsadm -A -t|u|f ServerAddress [-s schduler]-t: tcp协议的集群 地址为IP:PORT-u: udp协议的集群 地址为IP:PORT-f: 防火墙标记 地址为MarkNumber eg：ipvsadm -A -t 192.168.10.10:80 -s rr 目的地址为192.168.10.10:80的tcp协议的数据包需要进行lvs，使用rr调度算法进行负载均衡。 配置数据包转发到RealServer1234567格式：ipvsadm -a -t|u|f service-address -r server-address [-g|i|m] [-w weight]前部分是配置的哪些数据包需要lvs转发，即配置的集群服务-r 该参数后面是RealServer的地址，可以是IP:PORT-g DR模式-i Tunnel模式-m NAT模式-w 该参数和值定义服务器权重 eg: ipvsadm -a -t 192.168.10.10:80 -r 192.168.10.8 –g 2.3 实验拓扑蓝色的路径是请求数据包的路线，绿色的是响应数据包的路线。忽略了网关。 2.4 实验过程 step1: 三台虚拟机，eth0在同一个网络192.168.10.0 step2: 配置node1(lvs)的VIP12ifconfig eth0:0 192.168.10.10/24echo “1” &gt; /proc/sys/net/ipv4/ip_forward 注意：当计算机收到一个目的地址不属于自己IP的数据包时候默认会丢弃，因此lvs这个需要设置ip_forward的值为1，充当路由器的功能，将数据包转发出去。 step3: 修改RealServer的arp响应和通告级别 12345echo “1” &gt; /proc/sys/net/ipv4/ip_forwardecho 1 &gt; /proc/sys/net/ipv4/conf/eth0/arp_ignoreecho 2 &gt; /proc/sys/net/ipv4/conf/eth0/arp_announceecho 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignoreecho 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce step4: 配置每一台RealSerer的VIP(隐藏IP)1ifconfig lo:8 192.168.10.10 netmask 255.255.255.255 注意: 响应和通告级别一定要先配置，不然VIP后被通告出去。 至此，三个节点的信息如下 step5: 启动RrealServer上的httpd123yum install httpd -y#启动命令service httpd start 静态网页的路径/var/www/html #参考文献[1] http://www.linuxvirtualserver.org/zh/index.html[2] https://www.cnblogs.com/gaoxu387/p/7941381.html[3] https://blog.csdn.net/weixin_40470303/article/details/80541639","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"configurationARGS","slug":"configurationARGS","date":"2019-10-07T07:24:00.000Z","updated":"2019-10-09T03:49:12.388Z","comments":true,"path":"2019/10/07/configurationARGS/","link":"","permalink":"http://yoursite.com/2019/10/07/configurationARGS/","excerpt":"常用配置参数1. vim的配置参数","text":"常用配置参数1. vim的配置参数 针对每一个用户修改，在/etc/vimrc中是所有用户生效 1vim ~/.vimrc 输入如下配置： 12345678910111213141516171819202122232425262728293031323334353637&quot;关闭vim一致性原则set nocompatible&quot;显示行号set number&quot;设置在编辑过程中右下角显示光标的行列信息set ruler&quot;在状态栏显示正在输入的命令set showcmd&quot;设置历史记录条数set history=1000&quot;设置取消备份 禁止临时文件的生成set nobackupset noswapfile&quot;设置匹配模式set showmatch&quot;设置C/C++方式自动对齐set autoindentset cindent&quot;开启语法高亮功能syntax on&quot;指定配色方案为256色set t_Co=256&quot;设置搜索时忽略大小写set ignorecase&quot;配置backspace的工作方式set backspace=indent,eol,start&quot;设置在vim中可以使用鼠标set mouse=a&quot;设置tab宽度set tabstop=4&quot;设置自动对齐空格数set shiftwidth=4&quot;设置退格键时可以删除4个空格set smarttabset softtabstop=4&quot;将tab键自动转换为空格set expandtab 最后使配置生效 1source ~/.vimrc","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"conf","slug":"conf","permalink":"http://yoursite.com/tags/conf/"}]},{"title":"pytorchEnvInUbuntu1604","slug":"pytorchEnvInUbuntu1604","date":"2019-10-07T02:53:23.000Z","updated":"2019-10-07T03:13:08.472Z","comments":true,"path":"2019/10/07/pytorchEnvInUbuntu1604/","link":"","permalink":"http://yoursite.com/2019/10/07/pytorchEnvInUbuntu1604/","excerpt":"ubuntu16.04中搭建PyTorch环境官网链接","text":"ubuntu16.04中搭建PyTorch环境官网链接 1.选择的环境 Anaconda原因：python搭建torch，numpy等模块太费劲，需要下载源代码编译安装等。直接选择anaconda比较简单。不需要处理复杂的包依赖关系 2.安装过程 step1: 安装Anaconda 123# The version of Anaconda may be different depending on when you are installing`curl -O https://repo.anaconda.com/archive/Anaconda3-5.2.0-Linux-x86_64.shsh Anaconda3-5.2.0-Linux-x86_64.sh step2: 使配置文件生效 1source ~/.bashrc 还可以通过重启来使之生效reboot step3: 安装pyTorch 1conda install pytorch torchvision cpuonly -c pytorch 3.安装过程的一些麻烦事Anaconda安装后默认使用它带的python环境，为了不影响其他python程序的运行，如（VNCServer），会出现终端调不出来的情况。需要重新配置环境变量。找到~/.bashrc文件中的如下语句（路径可能随系统不同而变化）： 1export PATH=&quot;/root/anaconda2/bin:$PATH&quot; 修改为下面的语句： 1export PATH=&quot;$PATH:/root/anaconda2/bin&quot; 这个时候在终端运行python --version是系统配置的python环境了，需要anaconda的python环境，只需要找到anaconda安装目录下的bin文件即可。","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://yoursite.com/tags/PyTorch/"}]},{"title":"numpyPractice","slug":"numpyPractice","date":"2019-10-05T12:08:05.000Z","updated":"2019-10-05T12:10:50.640Z","comments":true,"path":"2019/10/05/numpyPractice/","link":"","permalink":"http://yoursite.com/2019/10/05/numpyPractice/","excerpt":"numpy (Numerical Python)数值计算基础官网链接","text":"numpy (Numerical Python)数值计算基础官网链接 一. 简介 python 语言数值计算扩充库 强大的高维数组处理和矩阵运算能力 NumPy 的主要对象是多维数组 Ndarray 二. 应用demo1.导入模块与查看版本信息12import numpy as npprint(np.__version__) 2.创建数组 主要创建数组的途径 从 Python 数组结构列表，元组等转换。 使用 np.arange、np.ones、np.zeros 等 NumPy 原生方法。 从存储空间读取数组。 通过使用字符串或缓冲区从原始字节创建数组。 使用特殊函&emsp;&emsp;数，如 random。 2.1 通过列表创建数组123456# 一维数组a = np.array([1, 2, 3])print(a)# 二维数组b = np.array([(1, 2, 3), (4, 5, 6)])print(b) 2.2 使用原生方法1234567#创建全为0的数组a = np.zeros((3, 3))print(a)#创建全为1的数组b = np.ones((2, 2, 4))print(b) 说明 : numpy.ones(shape, dtype=None, order=’C’)，shape指定数组的形状,每个轴的长度 12345678910#创建一维等差数组a = np.arange(5)print(a)# 结果：[0 1 2 3 4]#创建二维等差数组b = np.arange(6).reshape(2, 3)print(b)# 结果：[[0 1 2]# [3 4 5]] arange说明 格式： numpy.arange(start, stop, step, dtype=None) [start, stop) 半开半闭区间内创建一系列均匀间隔的值 1234567# 创建二维单位阵a = np.eye(3)print(a)# 结果：# [[1. 0. 0.]# [0. 1. 0.]# [0. 0. 1.]] eye说明 格式： numpy.eye(N, M=None, k=0, dtype=&lt;type ‘float’&gt;) k：对角线索引：0（默认）是指主对角线，正值是指上对角线，负值是指下对角线 1234# 创建等间隔的一维数组a = np.linspace(1, 10, num=7)print(a)# 结果 [ 1 2.5 4 5.5 7 8.5 10. ] linspace说明 格式： numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 同arange endpoint 指示是否最后一个样本包含在序列内 2.3 使用特殊函数创建数组123456# 创建二维随机数组a = np.random.rand(2, 3)print(a)# 结果： [[0.72448631 0.19235668 0.00701753] [0.05801567 0.9642479 0.22793563]] rand()说明 括号内指定数组的形状 使用[0, 1)之间的数随机填充 123456# 创建二维随机数组(数值&lt;5)a = np.random.randint(5, size=(2, 4))print(a)# 结果：[[3 1 2 0] [1 4 2 2]] randint()说明 格式： randint(low, high, size, dtype) 生成[low, high) 的随机数一维数组的时候size参数可直接填数字 eg:randint(1, 3, 10) 2.4 从已知数据创建1234567# 使用lambda创建数组a = np.fromfunction(lambda i, j: i + j, (3, 3))print(a)# 结果：#[[0. 1. 2.]#[1. 2. 3.]#[2. 3. 4.]] fromfunction说明格式： fromfunction（function，shape）：通过函数返回值来创建多维数组 3. 数组运算3.1 一维数组的四则运算生成两个Ndarry 123a = np.array([10, 20, 30, 40, 50])b = np.arange(1, 6)#b数组：[1 2 3 4 5] 123456c = a + bprint(&quot;c: &quot;, end=&quot;&quot;)#结果： [11 22 33 44 55]c = a - bc = a * bc = a / b 注意 ：数组大小不一样会发生异常 3.2 二维数组（矩阵）的运算生成两个Ndarry 12a = np.array([[1, 2], [3, 4]])b = np.array([[5, 6], [7, 8]]) 同一维数组一样，可以进行个元素分别的四则运算 12c = a + bc = a * b 但是矩阵乘法是不一样的： 矩阵m*n与矩阵n*p的矩阵是m*p 1234#矩阵乘法c = np.dot(a, b)c = np.mat(a) * np.mat(b) 注意这里的a, b都是二维数组，所以用dot进行运算可以使用np.mat(a)将二维数组转换为矩阵，直接使用* 12345678# 矩阵数乘c = 2 * a# 矩阵转置c = a.T# 矩阵求逆c = np.linalg.inv(a) np.linalg中涉及到矩阵的计算方法，求解特征值、特征向量、逆矩阵等 4. 数组索引和切片4.1 一维数组一个一维数组 1a = np.array([1, 2, 3, 4, 5]) 一维数组索引 12print(a[0], a[-1])# 结果： 1 5 一维数组切片 1234567a = np.array([1, 2, 3, 4, 5])print(a[0:2])# 结果 [1 2]print(a[:-1])# 结果 [1 2 3 4] 4.2 二维数组一个二维数组 1a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)]) 二维数组索引 123456a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)])print(a[0])# 结果： [1 2 3]print(a[-1])# 结果： [7 8 9] 二维数组切片 12345678910a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)])print(a[0:3, 1]) #等价于a[:, 1]# 结果： [2 5 8] 取第2列# 取第二三行print(a[1:3, :])# 结果：# [[4 5 6]# [7 8 9]] (a, c)括号前面控制的是选取的行， 后面控制的是列。 5. 数组形状操作 查看数组形状 1234a = np.random.random((3, 2))print(a)print(a.shape)# result: (3, 2) 更改数组形状（不改变原始数组） 1234a = np.random.randint(1, 10, 6).reshape(3, 2)print(a)c = a.reshape((2, 3))print(c) 说明 numpy.reshape() 等效于 ndarray.reshape()。 numpy.reshape(a, newshape)。 其中newshape 用于指定新的形状(整数或者元组)。 更改数组形状（改变原始数组） 1234a = np.random.randint(1, 10, 6).reshape(3, 2)print(a)a.resize(2, 3)print(a) 数组扁平化(变为一维数组) 1234a = np.random.randint(1, 10, 6).reshape(3, 2)print(a)c = np.ravel(a)d = a.ravel() numpy.ravel(a, order=’C’) 按行读取numpy.ravel(a, order=’F’) 按列读取 垂直方向堆叠数组123456a = np.random.randint(10, size=(2, 2))b = np.random.randint(10, size=(2, 2))print(a)print(b)c = np.vstack((a, b))print(c) 输出 a: [[2 9] [8 1]] b: [[1 5] [0 1]]c: [[2 9] [8 1] [1 5] [0 1]] 拓展 d = np.hstack((a, b)) 水平方向上堆叠数组 6. 数组排序与统计 返回每列最大值 1234a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))c = np.max(a, axis=0)print(c)# result： [6 7 9] 返回每行最小值 1234a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))c = np.min(a, axis=1)print(c)# result: [1 2 2] 返回每列最大值索引 1234a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))c = np.argmax(a, axis=0)print(c)# result: [1 2 1] 返回每行最小值索引 1234a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))c = np.argmin(a, axis=1)print(c)# result: [0 1 2] 统计数组各列的中位数 1234a = np.array(([1, 4, 3], [6, 2, 9], [4, 7, 2]))c = np.median(a, axis=0)print(c)# result: [4. 4. 3.] 其他 np.mean(a, axis=1)统计数组各行的算术平均值 np.average(a, axis=0)统计数组各列的加权平均值 np.var(a, axis=1)统计数组各行的方差 np.std(a, axis=0) 统计数组各列的标准偏差","categories":[{"name":"Numpy","slug":"Numpy","permalink":"http://yoursite.com/categories/Numpy/"}],"tags":[{"name":"Numpy","slug":"Numpy","permalink":"http://yoursite.com/tags/Numpy/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"ubuntu1604vnc","slug":"ubuntu1604vnc","date":"2019-10-05T11:40:54.000Z","updated":"2019-10-05T11:56:15.910Z","comments":true,"path":"2019/10/05/ubuntu1604vnc/","link":"","permalink":"http://yoursite.com/2019/10/05/ubuntu1604vnc/","excerpt":"ubuntu16.04 VNC远程桌面1. VNC简介","text":"ubuntu16.04 VNC远程桌面1. VNC简介 VNC(Virtual Network Console):虚拟网络控制台，一个远程控制的工具软件 VNC包括四个命令：vncserver, vncviewer, vncpasswd, vncconnect. VNC由两部分组成，客户端的应用软件(vncviewer)&emsp;+&emsp;服务器端的应用程序(vncserver) 2. ubuntu16.04中安装服务端程序使用SSH登录到系统 step1 1sudo apt-get update step 2 1sudo apt-get install vnc4server step 3启动vncserver 1vncserver 步骤三中会出现如下界面输入密码即可，这是客户端登陆密码。出现如下界面说明服务端安装成功 此时使用vncviewer登录出现的界面如下所示，对此需要安装一个图形化桌面 3. ubuntu16.04安装图形化桌面3.1 全ubuntu16.04桌面(不推荐)gnome环境 缺点：占用资源多 step1&emsp;安装x-windows 1sudo apt-get install x-window-system-core step2&emsp;安装登录管理器(可不选) 1sudo apt-get install gdm step3&emsp;安装ubuntu桌面 1sudo apt-get install ubuntu-desktop step4&emsp;安装gnome配套软件 1sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal step5&emsp;修改VNC配置文件，使桌面生效 1vim ~/.vnc/xstartup 变成如下文件配置 1234567891011#!/bin/sh# Uncomment the following two lines for normal desktop:export XKL_XMODMAP_DISABLE=1 unset SESSION_MANAGER# exec /etc/X11/xinit/xinitrcunset DBUS_SESSION_BUS_ADDRESSgnome-panel &amp;gnmoe-settings-daemon &amp;metacity &amp;nautilus &amp;gnome-terminal &amp; 重新启动就可以了 12vncserver -kill :1 #杀掉原桌面进程（:1)就是vncserver :1 #重新启动 3.2 ubuntu16.04剪切版(推荐)&emsp;gnome环境 优点：占用系统资源少，仅安装核心组件：不安装例如 office、浏览器、等等的额外组件 step1&emsp;安装x-windows 1sudo apt-get install x-window-system-core step2&emsp;安装登录管理器(可不选) 1sudo apt-get install gdm step3&emsp;安装ubuntu桌面(剪切版) 1apt-get install --no-install-recommends ubuntu-desktop step4&emsp;安装gnome配套软件 1sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal step5&emsp;修改VNC配置文件，使桌面生效 1vim ~/.vnc/xstartup 在文件最后添加如下记录 1234gnome-panel &amp;gnome-settings-daemon &amp;metacity &amp;nautilus &amp; 3.3 安装xfce4桌面 优点：Xfce占用的内存和CPU使用量非常小；Xfce桌面很简单，而且没有乱七八糟的东西参考文献 step 1: 1sudo apt-get install xfce4 step 2:修改配置文件该文件路径一般在下面1vi ~/.vnc/xstartup 123456#x-window-manager &amp;sesion-manager &amp; xfdesktop &amp; xfce4-panel &amp;xfce4-menu-plugin &amp;xfsettingsd &amp;xfconfd &amp;xfwm4 &amp; 4. 卸载桌面程序4.1 卸载gnome桌面 step1: 卸载掉gnome-shell主程序及其配套软件 123sudo apt-get remove gnome-shellsudo apt-get remove ubuntu-desktopsudo apt-get remove gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal step2: 清理安装gnome时候留下的缓存程序软件包 12sudo apt-get autocleansudo apt-get clean 4.2 卸载xfce4桌面 step1: 卸载xfce4 1sudo apt-get remove xfce4 step2: 卸载相关软件 1sudo apt-get remove xfce4* step3: 自动卸载不必要的软件 1sudo apt-get autoremove step4: 系统清理 1apt-get clean 5. vnc相关的重要命令 启动vncserver :1是桌面号 1vncserver :1 关闭vncserver 1vncserver -kill :1 客户端连接vncserver 12ip:1ip:5901 参考文献[1] https://blog.csdn.net/u014389734/article/details/79513517[2] http://dblab.xmu.edu.cn/blog/1998-2/[3] https://www.cnblogs.com/chenmingjun/p/8506995.html Linux的桌面环境gnome、kde、xfce、lxde 等等使用比较","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"Linux VNC","slug":"Linux-VNC","permalink":"http://yoursite.com/tags/Linux-VNC/"}]},{"title":"pytorch01","slug":"pytorch01","date":"2019-09-24T07:57:24.000Z","updated":"2019-10-05T11:56:12.853Z","comments":true,"path":"2019/09/24/pytorch01/","link":"","permalink":"http://yoursite.com/2019/09/24/pytorch01/","excerpt":"PyTorch入门之线性回归torch参考链接","text":"PyTorch入门之线性回归torch参考链接 1. 安装 python 3.7 Torch 1.2.0 用于计算 matplotlib 用于画图 踩坑点 Torch安装需要用到pip命令，直接在pycharm中会失败 去官网获得pip的安装的命令 Torch官网 2. PyTorch基础知识 Tensor是PyTorch的基础数据结构 另一个重要的变量是Variable变量，该变量进行自动微分运算 反向传播算法随时进行该变量三个重要的值： 数据（data），父节点（creator），以及梯度（grad） 使用之前需要导入两个包 创建变量方法如下 123456import torch#导入自动梯度的运算包，主要用Variable这个类from torch.autograd import Variable#创建一个Variable，包裹了一个2*2张量，将需要计算梯度属性置为Truex = Variable(torch.ones(2, 2), requires_grad=True) x变量如下所示 &emsp;&emsp;注意 .data 可以返回一个 Variable 所包裹的 Tensor torch.rand(5, 3)产生[0,1]的均匀分布的随机数值，参数指定形状(一维时第二个参数可不要) torch.randn(100)产生均值为0，方差为1，正态分布随机数值(同样可以指定形状) torch.linspace(start, end, steps=100, out=None) → Tensor线性间隔的数值，返回一个一维张量 y.t()完成张量的转置 Tensor可以与numpy.ndarray进行转换 ndarray转换为Tensor 12a = np.ones([5, 3]) #建立一个5*3全是1的二维数组（矩阵）b = torch.from_numpy(a) #利用from_numpy将其转换为tensor Tensor转换为ndarry 1c = b.numpy() #b为Tensor 区别 ：Tesnsor可以在GPU上运算 使用backward进行反向传播，计算一些导数信息，可通过.grad获得梯度 3. 单变量线性回归 y = ax + b 3.1 产生数据12345678910# linspace可以生成0-100之间的均匀的100个数字x = Variable(torch.linspace(0, 100).type(torch.FloatTensor))# 随机生成100个满足标准正态分布的随机数，均值为0，方差为1.# 将这个数字乘以10，标准方差变为10rand = Variable(torch.randn(100)) * 10# 将x和rand相加，得到伪造的标签数据y。# 所以(x,y)应能近似地落在y=x这条直线上y = x + rand 使用画图工具画图 1234567plt.figure(figsize=(10,8)) #设定绘制窗口大小为10*8 inch# 绘制数据，考虑到x和y都是Variable，# 需要用data获取它们包裹的Tensor，并专成numpyplt.plot(x.data.numpy(), y.data.numpy(), &apos;o&apos;)plt.xlabel(&apos;X&apos;) #添加X轴的标注plt.ylabel(&apos;Y&apos;) #添加Y轴的标注plt.show() #将图形画在下面 结果如下所示 3.2 递归下降step 1: 初始化参数（随机初始） 1234#创建a变量，并随机赋值初始化a = Variable(torch.rand(1), requires_grad = True)#创建b变量，并随机赋值初始化b = Variable(torch.rand(1), requires_grad = True) step 2: 训练1000次 123456789101112131415161718learning_rate = 0.0001 #设置学习率for i in range(1000): ### 下面这三行代码非常重要，这部分代码，清空存储在变量a，b中的梯度信息， ### 以免在backward的过程中会反复不停地累加 #如果a和b的梯度都不是空 if (a.grad is not None) and (b.grad is not None): a.grad.data.zero_() #清空a的数值 b.grad.data.zero_() #清空b的数值 #计算在当前a、b条件下的模型预测数值 predictions = a.expand_as(x) * x + b.expand_as(x) #通过与标签数据y比较，计算误差 loss = torch.mean((predictions - y) ** 2) print(&apos;loss:&apos;, loss.data.numpy()) loss.backward() #对损失函数进行梯度反传 #利用上一步计算中得到的a的梯度信息更新a中的data数值 a.data.add_(- learning_rate * a.grad.data) #利用上一步计算中得到的b的梯度信息更新b中的data数值 b.data.add_(- learning_rate * b.grad.data) a.expand_as(x) : 将a升级为同x一样维度的张量 step 3: 将训练后的结果展示出来 123456789x_data = x.data.numpy() # 获得x包裹的数据plt.figure(figsize = (10, 7)) #设定绘图窗口大小xplot, = plt.plot(x_data, y.data.numpy(), &apos;o&apos;) # 绘制原始数据yplot, = plt.plot(x_data, a.data.numpy() * x_data + b.data.numpy()) #绘制拟合数据plt.xlabel(&apos;X&apos;) #更改坐标轴标注plt.ylabel(&apos;Y&apos;) #更改坐标轴标注str1 = str(a.data.numpy()[0]) + &apos;x +&apos; + str(b.data.numpy()[0]) #图例信息plt.legend([xplot, yplot],[&apos;Data&apos;, str1]) #绘制图例plt.show() 以下是拟合结果 3.3 测试x_test = Variable(torch.FloatTensor([1, 2, 10, 100, 1000])) #随便选择一些点1，2，……，1000 predictions = a.expand_as(x_test) * x_test + b.expand_as(x_test) #计算模型的预测结果 print(predictions) #输出附录完整代码 source: https://www.shiyanlou.com/courses/1073/learning/?id=5821","categories":[{"name":"deepLearing","slug":"deepLearing","permalink":"http://yoursite.com/categories/deepLearing/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"http://yoursite.com/tags/PyTorch/"},{"name":"线性回归","slug":"线性回归","permalink":"http://yoursite.com/tags/线性回归/"}]},{"title":"shell-auto","slug":"shell-auto","date":"2019-09-11T08:32:38.000Z","updated":"2019-09-23T12:37:10.488Z","comments":true,"path":"2019/09/11/shell-auto/","link":"","permalink":"http://yoursite.com/2019/09/11/shell-auto/","excerpt":"shell脚本实现Linux系统监控 代码见 https://github.com/oneCoderMan/myCodes/blob/master/shell/auto.sh","text":"shell脚本实现Linux系统监控 代码见 https://github.com/oneCoderMan/myCodes/blob/master/shell/auto.sh 一. 预备知识1.1 getopts 作用: 处理参数复杂的命令行选项和参数格式：getopts option_string args说明： option_string中是参数列表， args从命令行中接受的值 示例代码：option.sh 12345678910111213#! /bin/bashwhile getopts f:e:p: optiondo case &quot;$&#123;option&#125;&quot; in f) file_name=$&#123;OPTARG&#125;;; e) editor=$&#123;OPTARG&#125;;; p) page=$&#123;OPTARG&#125;;; *) echo &quot;invalid&quot;;; esacdoneecho &quot;$&#123;file_name&#125;&quot;echo &quot;$&#123;editor&#125;&quot;echo $&#123;page&#125; 运行命令：./option.sh -f bool.pdf -e YiJun -p HUANAN option_string是匹配的参数,字符后面有：表示该命令中必须加上参数，如-e yijun。否则会出现错误。参数的值会保存在OPTARG变量中。 检测到非法参数就会停止 1.2 $+sign各含义 $# :Stores the number of command-line arguments that were passed to the shell program. $? :Stores the exit value of the last command that was executed. $0 :Stores the first word of the entered command (the name of the shell program). $* :Stores all the arguments that were entered on the command line ($1 $2 …). $@ :Stores all the arguments that were entered on the command line, individually quoted (“$1” “$2” …). $&gt; : 1&gt;是标准输出重定向， 可以省去1(变为 &gt; )； 2&gt;错误重定向。$&gt;是两种的结合，标准与错误重定向 &gt;$1 : 将重定向到1管道， 即定向到标准输出 如下例子：./command -yes -no /home/username 1234$# = 3$* = -yes -no /home/username$@ = array: &#123;&quot;-yes&quot;, &quot;-no&quot;, &quot;/home/username&quot;&#125;$0 = ./command, $1 = -yes etc. 1.3 tput与颜色转义参考链接 tput作用：更改终端功能 12tput sgr0 # 恢复默认终端tput blink # 文本闪烁 一个例子1-3： 12tecreset=$(tput sgr0)echo -e &apos;\\E[32m&apos;&quot;Operating System Type :&quot; $tecreset $os 结果： 说明: 如果把1-3中的$tecreset去掉，都会是绿色。 方便操作，不用每次都使用命令替换$(), ``， 因此用一个变量tecreset存储命令。 linux终端的颜色由转义序列控制 转义序列由控制符 esc开头，控制序列引导符为：\\033或者\\e[，m为转义结束。 123格式1：\\033[ Param &#123;;Param;...&#125; m格式2：\\e[ Param &#123;;Param;...&#125;m 例子1-3 参考资料 12echo -e &quot;\\033[颜色1;颜色2m 要展示的文字 \\033[0m&quot;\\033[0m：表示将颜色恢复回原来的颜色 1.4 各种括号参考文献 $()与`` 用来做命令替换的，简化shell脚本的编写 ${} 变量替换的，即变量引用 $[]与 $(()) 都是用来做数学运算的注意 : $(())中的变量前面可以加$,也可不用 [] test命令的一种形式 左右需留空格，即判断true或者false (())与[[]] 分别是数学表达式和字符表达式[]的加强版 二.监控系统脚本各模块2.1 脚本安装 -i代码如下：123456789101112if [[ $iopt -eq 1 ]]; then #对变量的引用要加上$ then如果是同一行的话要加上; &#123; #获得它的路径 wd=`pwd` #获得它的文件名 basename `echo $0` &gt; /tmp/script #拼接 scriptname=`echo -e -n $wd/ &amp;&amp; cat /tmp/script` # 加载到环境变量中去 su -c &quot;cp $scriptname /usr/bin/monitor&quot; root &amp;&amp; echo &quot;congratulations! install successful!&quot; || echo &quot;install failed!&quot; &#125;fi 代码说明 ``(反引号)是执行shell命令，可将结果保存在变量中。同$(),这个有些shell不支持。 basename 命令是将前缀和最后的/删除，保留最后一个字符串显示出来 $0 是指shell本生的文件名，sh test.sh得到 test.sh。./test.sh 得到的是./test.sh echo中的-e 用来打印转义符， -n不换行打印 su -c command USER 切换用户USER执行命令command，执行完之后返回原用户 || &amp;&amp; 在命令组合中具有短路左右，可以看成if else结构 [[ ]] (())这个是进行数学表达式和字符表达式运算的加强版。推荐使用 ,左右需留空格 -eq 是数字等于判断， 对于字符串等于使用= 2.2 关于模块 -v代码如下: 123456if [[ $vopt -eq 1]]then &#123; echo -e &quot;monitor version 1\\nreleased Under ....&quot; &#125;fi 2.3 帮助模块 -h代码如下： 12345678if [[ $hopt -eq 1 ]]then &#123; echo -e &quot; -i\\tinstall the scripts &quot; echo -e &quot; -v\\tprint version &quot; echo -e &quot; -h\\t print help info&quot; &#125;fi 2.4 查看操作系统类型 注意 ：不同操作系统对应的代码不一样啊， 本文中只讨论centOS系统.不同版本的代码见附录1 代码如下： 1234567891011121314151617181920#查看系统版本和名称OS=`uname -s`REV=`uname -r`MACH=`uname -m`#查看操作系统类型，这里适用于redHatif [[ $&#123;OS&#125; = &quot;Linux&quot; ]]; then&#123; KERNEL=`uname -r` #内核发布版本 if [ -f /etc/redhat-release ]; then # test -f filename, 测试是否为普通文件 &#123; DIST=&quot;RedHat&quot; Psuedoname=`cat /etc/redhat-release | sed s/.*\\(// | sed s/\\)//` REV=`cat /etc/redhat-release | sed s/.*release\\ // | sed s/\\ .*//` &#125; fi OSSTR=&quot;$&#123;OS&#125; $&#123;DIST&#125; $&#123;REV&#125;($&#123;Psuedoname&#125; $&#123;KERNEL&#125; $&#123;MACH&#125;)&quot;&#125;fiecho $&#123;OSSTR&#125; 代码说明： uname是查看系统版本的命令 [ -f /etc/redhat-release ] 文件测试指令 可以查看 http://coolshell.cn/articles/9104.html 获取sed帮助 2.5 监控系统的各种信息 查看DNScat /etc/resolv.conf | sed &#39;1d&#39; | awk &#39;{print $2}&#39; 解释说明 读取配置文件，删除第一行， 打印第二个字段 查看系统负载12loadverage=$(top -n 1 -b | grep &quot;load average:&quot; | awk &apos;&#123;print $10 $11 $12&#125;&apos;)echo -e &quot;\\E[32m load average: \\E[0m &quot;$&#123;loadverage&#125; 说明 top -n 1 只迭代一次，不会动态刷新， top -n 1 -b 示非动态打印系统资源使用情况 查看系统运行时间 12tecuptime=$(uptime | awk &apos;&#123;print $3,$4&#125;&apos; | cut -f1 -d&apos;,&apos;)echo -e &quot;\\E[32m System Uptime Days: \\E[0m &quot;$&#123;loadverage&#125; 说明 cut -f1 -d’,’: -f1选定第一列， -d&#39;* &#39; 表示用*分割 来源：https://superuser.com/questions/247127/what-is-and-in-linux 附录附录1： 不同操作系统查看操作系统类型12345678910111213141516171819202122232425262728293031323334if [ &quot;$&#123;OS&#125;&quot; = &quot;SunOS&quot; ] ; then OS=Solaris ARCH=`uname -p` OSSTR=&quot;$&#123;OS&#125; $&#123;REV&#125;($&#123;ARCH&#125; `uname -v`)&quot;# uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。elif [ &quot;$&#123;OS&#125;&quot; = &quot;AIX&quot; ] ; then OSSTR=&quot;$&#123;OS&#125; `oslevel` (`oslevel -r`)&quot;#AIX是IBM开发的一套类UNIX操作系统，关于它更多的指令可以查看http://www.cnblogs.com/sbaicl/articles/2947795.htmlelif [ &quot;$&#123;OS&#125;&quot; = &quot;Linux&quot; ] ; then KERNEL=`uname -r` if [ -f /etc/redhat-release ] ; then DIST=&apos;RedHat&apos; PSUEDONAME=`cat /etc/redhat-release | sed s/.*\\(// | sed s/\\)//` REV=`cat /etc/redhat-release | sed s/.*release\\ // | sed s/\\ .*//`#sed通常用来匹配一个或多个正则表达式的文本进行处理,可以查看http://coolshell.cn/articles/9104.html elif [ -f /etc/SuSE-release ] ; then DIST=`cat /etc/SuSE-release | tr &quot;\\n&quot; &apos; &apos;| sed s/VERSION.*//` REV=`cat /etc/SuSE-release | tr &quot;\\n&quot; &apos; &apos; | sed s/.*=\\ //` elif [ -f /etc/mandrake-release ] ; then DIST=&apos;Mandrake&apos; PSUEDONAME=`cat /etc/mandrake-release | sed s/.*\\(// | sed s/\\)//` REV=`cat /etc/mandrake-release | sed s/.*release\\ // | sed s/\\ .*//` elif [ -f /etc/debian_version ] ; then DIST=&quot;Debian `cat /etc/debian_version`&quot; REV=&quot;&quot; fi if $&#123;OSSTR&#125; [ -f /etc/UnitedLinux-release ] ; then DIST=&quot;$&#123;DIST&#125;[`cat /etc/UnitedLinux-release | tr &quot;\\n&quot; &apos; &apos; | sed s/VERSION.*//`]&quot; fi OSSTR=&quot;$&#123;OS&#125; $&#123;DIST&#125; $&#123;REV&#125;($&#123;PSUEDONAME&#125; $&#123;KERNEL&#125; $&#123;MACH&#125;)&quot;fi","categories":[{"name":"Linux Shell","slug":"Linux-Shell","permalink":"http://yoursite.com/categories/Linux-Shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]}]}